{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"EDEN","text":"<p>EDEN is a 3D world simulation engine where AI-driven NPCs build, trade, and interact in a living world. To make an AI-Driven NPC you would bring either a paid API frontier model such as Claude, ChatGPT, Grok or Gemini, or you would use a free model from Ollama running locally on your machine. A full guide to integrating LLMs in EDEN is found here. Once in the game, the NPC becomes an AI Architect (AIA); players communicate with AIAs using natural language, and AIAs execute actions through Grove \u2014 EDEN's built-in scripting language.</p>"},{"location":"#grove-scripting","title":"Grove Scripting","text":"<p>Grove is how things happen in EDEN. When you tell the AI architect to build a house, he writes a Grove script. When you program an AlgoBot to patrol, that's Grove. When you buy land or check your balance, Grove handles it.</p> <p>This documentation covers everything you can do with Grove scripts.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Language Basics \u2014 Variables, loops, conditionals</li> <li>Construction \u2014 Spawning objects and building structures</li> <li>AlgoBot Programming \u2014 Programming worker bots</li> <li>Economy &amp; Land \u2014 Credits, plots, and zones</li> <li>Function Reference \u2014 All 38 functions in one place</li> </ul>"},{"location":"conventions/","title":"EDEN Conventions","text":""},{"location":"conventions/#units","title":"Units","text":"<p>1 unit = 1 meter</p> <p>All measurements in EDEN use real-world metric scale.</p>"},{"location":"conventions/#player-dimensions","title":"Player Dimensions","text":"Property Value Real-world Eye height 1.7m ~5'7\" eye level Total height ~1.85m ~6'1\" Collision radius 1.5m Personal space"},{"location":"conventions/#terrain","title":"Terrain","text":"Property Value Chunk resolution 64 vertices Tile size 2.0m Chunk world size 126m (63 tiles x 2m) Default bounds 32x32 chunks (-16 to 15) Total terrain size ~4km x 4km (16 sq km) Height scale 200m (max elevation)"},{"location":"conventions/#default-primitives","title":"Default Primitives","text":"Primitive Dimensions Cube (model editor) 1m \u00d7 1m \u00d7 1m Cylinder 4m height, 4m diameter (r=2m), 32 segments Spawn marker (uses cylinder)"},{"location":"conventions/#physics","title":"Physics","text":"Property Value Gravity 40 m/s\u00b2 Jump velocity 15 m/s Max slope angle 80\u00b0"},{"location":"conventions/#action-system","title":"Action System","text":"<p>See ENTITY_SYSTEM.md for the behavior/action instruction set.</p>"},{"location":"getting-started/","title":"EDEN Engine - Getting Started","text":"<p>A minimal Vulkan game engine with a high-level API.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>C++17 compiler</li> <li>CMake 3.16+</li> <li>Vulkan SDK</li> <li>GLFW3</li> <li>GLM</li> </ul> <p>Install on Ubuntu/Debian: <pre><code>sudo apt install cmake build-essential libvulkan-dev vulkan-validationlayers glslc libglfw3-dev libglm-dev\n</code></pre></p>"},{"location":"getting-started/#building-the-library","title":"Building the Library","text":"<pre><code>cd EDEN\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake -j$(nproc)\n</code></pre> <p>This produces <code>libeden.a</code> static library.</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<pre><code>#include &lt;eden/Eden.hpp&gt;\n\nint main() {\n    eden::Core engine;\n    engine.init({\n        .title = \"My Game\",\n        .width = 800,\n        .height = 600\n    });\n\n    auto triangle = engine.createMesh({\n        .vertices = {{0, -0.5f}, {0.5f, 0.5f}, {-0.5f, 0.5f}},\n        .colors = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}\n    });\n\n    engine.run([&amp;](float dt) {\n        triangle-&gt;rotate(dt * 90.0f);\n    });\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/#api-reference","title":"API Reference","text":""},{"location":"getting-started/#core","title":"Core","text":"<p>The main engine class. Manages window, rendering, and scene.</p> <pre><code>eden::Core engine;\n\n// Initialize with config\nengine.init({.title = \"App\", .width = 800, .height = 600});\n\n// Create meshes (automatically added to scene)\nauto mesh = engine.createMesh({...});\n\n// Run main loop with update callback\nengine.run([](float deltaTime) {\n    // Your game logic here\n});\n\n// Or manual loop\nwhile (engine.isRunning()) {\n    engine.update(deltaTime);\n    engine.render();\n}\n</code></pre>"},{"location":"getting-started/#mesh","title":"Mesh","text":"<p>Geometry with transform. Created via <code>engine.createMesh()</code>.</p> <pre><code>// Create mesh\nauto mesh = engine.createMesh({\n    .vertices = {{x, y}, ...},      // 2D positions\n    .colors = {{r, g, b}, ...},     // RGB colors per vertex\n    .indices = {0, 1, 2, ...}       // Optional index buffer\n});\n\n// Transform\nmesh-&gt;setPosition(x, y, z);\nmesh-&gt;rotate(degrees);              // Around Z axis\nmesh-&gt;rotate(degrees, {0, 1, 0});   // Around custom axis\nmesh-&gt;setScale(uniform);\nmesh-&gt;setScale({x, y, z});\n\n// Get transform matrix\nglm::mat4 model = mesh-&gt;getModelMatrix();\n</code></pre>"},{"location":"getting-started/#transform","title":"Transform","text":"<p>Position, rotation, scale component. Accessed via <code>mesh-&gt;getTransform()</code>.</p> <pre><code>Transform&amp; t = mesh-&gt;getTransform();\n\nt.setPosition({x, y, z});\nt.translate({dx, dy, dz});\nt.rotate(degrees, axis);\nt.setRotation(degrees, axis);\nt.setScale(uniform);\nt.scale(factor);\n\nglm::mat4 matrix = t.getMatrix();\n</code></pre>"},{"location":"getting-started/#scene","title":"Scene","text":"<p>Collection of meshes. Accessed via <code>engine.getScene()</code>.</p> <pre><code>Scene&amp; scene = engine.getScene();\n\nscene.add(mesh);\nscene.remove(mesh);\nscene.clear();\n\nfor (auto&amp; m : scene.getMeshes()) {\n    // iterate meshes\n}\n</code></pre>"},{"location":"getting-started/#linking-in-your-project","title":"Linking in Your Project","text":""},{"location":"getting-started/#cmake","title":"CMake","text":"<pre><code>add_executable(my_game main.cpp)\n\ntarget_include_directories(my_game PRIVATE /path/to/EDEN/include)\ntarget_link_libraries(my_game PRIVATE\n    /path/to/EDEN/build/libeden.a\n    vulkan glfw glm\n)\n\n# Copy shaders to your build directory\nfile(COPY /path/to/EDEN/build/shaders DESTINATION ${CMAKE_BINARY_DIR})\n</code></pre>"},{"location":"getting-started/#manual-compilation","title":"Manual Compilation","text":"<pre><code>g++ -std=c++17 main.cpp \\\n    -I/path/to/EDEN/include \\\n    -L/path/to/EDEN/build -leden \\\n    -lvulkan -lglfw -lm \\\n    -o my_game\n</code></pre>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<pre><code>EDEN/\n\u251c\u2500\u2500 include/eden/     # Public headers\n\u2502   \u251c\u2500\u2500 Eden.hpp      # Main include (includes all)\n\u2502   \u251c\u2500\u2500 Core.hpp      # Engine facade\n\u2502   \u251c\u2500\u2500 Mesh.hpp      # Mesh + vertex data\n\u2502   \u251c\u2500\u2500 Transform.hpp # Position/rotation/scale\n\u2502   \u251c\u2500\u2500 Scene.hpp     # Object collection\n\u2502   \u2514\u2500\u2500 Window.hpp    # Window interface\n\u251c\u2500\u2500 src/              # Implementation (internal)\n\u251c\u2500\u2500 shaders/          # GLSL shaders\n\u251c\u2500\u2500 examples/         # Example projects\n\u2514\u2500\u2500 docs/             # Documentation\n</code></pre>"},{"location":"llm-integration/","title":"Integrating LLMs into EDEN","text":"<p>This guide walks you through adding AI-powered NPCs to your EDEN world. By the end, you'll have an NPC that responds to natural language, moves around, builds structures, and executes Grove scripts.</p>"},{"location":"llm-integration/#what-you-need","title":"What You Need","text":"<p>Pick one:</p> <ul> <li>Paid API \u2014 A key from xAI (Grok), OpenAI, Anthropic, or Google</li> <li>Free local model \u2014 Ollama running on your machine</li> </ul>"},{"location":"llm-integration/#step-1-start-the-backend","title":"Step 1: Start the Backend","text":"<p>The backend is a Python server that bridges your NPCs to the LLM.</p> <pre><code>cd backend\npython3 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n</code></pre> <p>Copy the example config and add your credentials:</p> <pre><code>cp .env.example .env\n</code></pre> <p>Edit <code>.env</code> with your provider:</p> <p>=== \"Grok (xAI)\"</p> <pre><code>```bash\nXAI_API_KEY=your-key-from-console.x.ai\nGROK_MODEL=grok-3\nDEFAULT_PROVIDER=grok\n```\n</code></pre> <p>=== \"Ollama (Free, Local)\"</p> <pre><code>```bash\nOLLAMA_URL=http://localhost:11434\nOLLAMA_MODEL=dolphin-mixtral:8x7b\nDEFAULT_PROVIDER=ollama\n```\n\nInstall Ollama first, then pull a model:\n```bash\nollama pull dolphin-mixtral:8x7b\nollama serve\n```\n</code></pre> <p>Start the server:</p> <pre><code>python server.py\n</code></pre> <p>You should see: <code>Starting server on http://localhost:8080</code></p> <p>Verify it's working:</p> <pre><code>curl http://localhost:8080/health\n</code></pre>"},{"location":"llm-integration/#step-2-create-an-npc-in-the-editor","title":"Step 2: Create an NPC in the Editor","text":"<ol> <li>Open the Terrain Editor and load or create a level</li> <li>Spawn an object \u2014 a cube, cylinder, or load a <code>.glb</code> model</li> <li>Name it something memorable (e.g., \"Xenk\", \"Guard_1\", \"Merchant\")</li> <li>In the Properties panel, set the Being Type</li> </ol>"},{"location":"llm-integration/#being-types","title":"Being Types","text":"Type ID Personality Best For Human 1 Natural, conversational Merchants, villagers Clone 2 Existential, identity-questioning Story NPCs Robot 3 Mechanical, efficient Workers, guards Android 4 Polite, human-like Assistants Cyborg 5 Aggressive, military Combat NPCs Alien 6 Non-human, unusual speech Exotic encounters Eve 7 Companion android Ship companion AI Architect 8 Logical, builder-focused Construction, economy, bots AlgoBot 9 No chat \u2014 script-driven Programmable workers <p>The AI Architect (type 8) is the most capable \u2014 it can build structures, program AlgoBots, manage the economy, and execute Grove scripts. Start with this type if you're experimenting.</p>"},{"location":"llm-integration/#step-3-talk-to-your-npc","title":"Step 3: Talk to Your NPC","text":"<ol> <li>Save your level (File &gt; Save)</li> <li>Press P to enter Play Mode</li> <li>Walk up to your NPC (within ~15 meters)</li> <li>Press E to interact</li> <li>Type a message and press Enter</li> </ol> <p>The NPC sees what's around it through a perception cone \u2014 a 120-degree, 50-meter scan of nearby objects. It knows the names, positions, and types of everything in view, so you can say things like \"go to that cube\" or \"pick up the timber.\"</p>"},{"location":"llm-integration/#what-npcs-can-do","title":"What NPCs Can Do","text":"<p>Every sentient NPC can:</p> <ul> <li>Look around \u2014 scan the environment</li> <li>Move to locations \u2014 walk to a world position</li> <li>Turn to face objects or directions</li> <li>Follow the player continuously</li> <li>Stop any current action</li> </ul> <p>The AI Architect (type 8) can additionally:</p> <ul> <li>Build structures \u2014 spawn cubes, cylinders, models via Grove</li> <li>Program AlgoBots \u2014 upload behavior scripts to worker bots</li> <li>Manage economy \u2014 buy/sell land, check credits</li> <li>Run scripts \u2014 execute any Grove code on demand</li> </ul>"},{"location":"llm-integration/#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":"<p>When you press E and type a message:</p> <ol> <li>The editor captures a perception snapshot of what the NPC can see</li> <li>Your message + perception data is sent to the backend via HTTP</li> <li>The backend forwards it to the LLM with the NPC's personality prompt</li> <li>The LLM responds with dialogue and optional action commands</li> <li>The editor displays the dialogue and executes any actions</li> </ol> <pre><code>Player types \"build a house\"\n        \u2193\n   [HTTP POST /chat]\n        \u2193\n   Backend (server.py)\n        \u2193\n   LLM (Grok/Ollama/Claude)\n        \u2193\n   {\"response\": \"Initiating construction.\", \"action\": {\"type\": \"run_script\", \"script\": \"...\"}}\n        \u2193\n   Editor executes Grove script \u2192 objects appear in world\n</code></pre> <p>The NPC's response can include motor commands like <code>move_to</code>, <code>pickup</code>, <code>run_script</code>, etc. The editor parses the JSON action and executes it in the game world.</p>"},{"location":"llm-integration/#configuring-providers","title":"Configuring Providers","text":""},{"location":"llm-integration/#switching-providers-at-runtime","title":"Switching Providers at Runtime","text":"<p>The backend supports multiple providers simultaneously. You can override the default per-request by specifying a provider in the API call. The editor uses whatever <code>DEFAULT_PROVIDER</code> is set in <code>.env</code>.</p>"},{"location":"llm-integration/#provider-comparison","title":"Provider Comparison","text":"Provider Cost Speed Quality Offline Grok (xAI) Paid API Fast High No Ollama Free Varies by model/hardware Good Yes"},{"location":"llm-integration/#ollama-model-recommendations","title":"Ollama Model Recommendations","text":"Model Size Notes <code>dolphin-mixtral:8x7b</code> ~26 GB Best quality, needs good GPU <code>mistral</code> ~4 GB Good balance of speed and quality <code>llama2</code> ~4 GB Solid general purpose <code>neural-chat</code> ~4 GB Good at conversational dialogue"},{"location":"llm-integration/#persistent-memory","title":"Persistent Memory","text":"<p>The AI Architect and Eve NPCs maintain persistent context across sessions:</p> <ul> <li><code>backend/xenk_context.txt</code> \u2014 The architect's accumulated world knowledge</li> <li><code>backend/xenk_briefing.txt</code> \u2014 Current session briefing</li> <li><code>backend/logs/chat_history.jsonl</code> \u2014 Full conversation logs</li> </ul> <p>This means your AI architect remembers what it built, what land was purchased, and what instructions you gave \u2014 even after restarting the game.</p>"},{"location":"llm-integration/#troubleshooting","title":"Troubleshooting","text":"<p>NPC says \"(AI unavailable)\"</p> <ul> <li>Backend server isn't running \u2014 start it with <code>python server.py</code></li> <li>Wrong URL \u2014 the editor connects to <code>http://localhost:8080</code> by default</li> </ul> <p>NPC doesn't respond</p> <ul> <li>Check the terminal where <code>server.py</code> is running for error messages</li> <li>Verify your API key is correct in <code>.env</code></li> <li>Run <code>curl http://localhost:8080/health</code> to check provider status</li> </ul> <p>Ollama is slow</p> <ul> <li>Larger models need more VRAM \u2014 try a smaller model like <code>mistral</code></li> <li>Check GPU utilization with <code>nvidia-smi</code></li> </ul> <p>NPC doesn't move when asked</p> <ul> <li>Only being types with motor control can move (Robot, Eve, AI Architect)</li> <li>Make sure you're in Play Mode (press P)</li> <li>The NPC needs perception data to know where objects are \u2014 it can only reference things it can \"see\"</li> </ul>"},{"location":"grove/algobots/","title":"AlgoBot Programming","text":"<p>AlgoBots are worker robots that execute Grove scripts autonomously. You program them by selecting a target bot, queuing actions, and running the behavior.</p>"},{"location":"grove/algobots/#basic-pattern","title":"Basic Pattern","text":"<pre><code>bot_target(\"Worker1\")           -- select the bot\nbot_clear()                     -- clear previous program\nmove_to(vec3(10, 0, 20), 3.0)  -- queue actions\nwait(1.0)\nmove_to(vec3(0, 0, 0), 3.0)\nbot_loop(true)                  -- repeat forever\nbot_run()                       -- activate\n</code></pre>"},{"location":"grove/algobots/#movement","title":"Movement","text":""},{"location":"grove/algobots/#move_toposition-duration-animation","title":"move_to(position, duration, animation?)","text":"<p>Move the bot to a world position over a duration in seconds.</p> <pre><code>move_to(vec3(50, 0, 80), 5.0)              -- walk over 5 seconds\nmove_to(vec3(50, 0, 80), 3.0, \"run\")       -- run animation while moving\n</code></pre>"},{"location":"grove/algobots/#turn_toposition-duration","title":"turn_to(position, duration?)","text":"<p>Rotate the bot to face a world position (yaw only). Default duration is 0.5 seconds.</p> <pre><code>turn_to(vec3(100, 0, 0), 1.0)   -- turn to face position over 1 second\n</code></pre>"},{"location":"grove/algobots/#follow_pathpath_name","title":"follow_path(path_name)","text":"<p>Follow a named AI path created in the editor.</p> <pre><code>follow_path(\"patrol_route_1\")\n</code></pre>"},{"location":"grove/algobots/#timing","title":"Timing","text":""},{"location":"grove/algobots/#waitseconds","title":"wait(seconds)","text":"<p>Pause before the next action.</p> <pre><code>wait(2.0)   -- wait 2 seconds\n</code></pre>"},{"location":"grove/algobots/#visibility-animation","title":"Visibility &amp; Animation","text":"<pre><code>set_visible(false)              -- hide the bot\nset_visible(true)               -- show it again\nplay_anim(\"wave\", 2.0)         -- play animation for 2 seconds\n</code></pre>"},{"location":"grove/algobots/#signals","title":"Signals","text":"<p>Send a named signal that can trigger other entities' behaviors:</p> <pre><code>send_signal(\"alarm\")            -- broadcast to all\nsend_signal(\"open\", \"Gate_01\")  -- send to specific object\n</code></pre>"},{"location":"grove/algobots/#looping","title":"Looping","text":"<pre><code>bot_loop(true)    -- repeat the program when it finishes\nbot_loop(false)   -- run once and stop (default)\n</code></pre>"},{"location":"grove/algobots/#examples","title":"Examples","text":""},{"location":"grove/algobots/#patrol-between-two-points","title":"Patrol Between Two Points","text":"<pre><code>bot_target(\"Guard_1\")\nbot_clear()\nmove_to(vec3(10, 0, 0), 4.0)\nwait(2.0)\nturn_to(vec3(-10, 0, 0), 0.5)\nmove_to(vec3(-10, 0, 0), 4.0)\nwait(2.0)\nturn_to(vec3(10, 0, 0), 0.5)\nbot_loop(true)\nbot_run()\n</code></pre>"},{"location":"grove/algobots/#circular-route","title":"Circular Route","text":"<pre><code>bot_target(\"Bot_1\")\nbot_clear()\nmove_to(vec3(10, 0, 0), 3.0)\nmove_to(vec3(0, 0, 10), 3.0)\nmove_to(vec3(-10, 0, 0), 3.0)\nmove_to(vec3(0, 0, -10), 3.0)\nbot_loop(true)\nbot_run()\n</code></pre>"},{"location":"grove/algobots/#resource-collector","title":"Resource Collector","text":"<pre><code>bot_target(\"Hauler_1\")\nbot_clear()\n-- Check if there's wood at the destination\nlocal res = zone_resource(vec3(500, 0, 500))\nif res == \"wood\" then\n  move_to(vec3(500, 0, 500), 10.0)\n  wait(5.0)\n  move_to(vec3(0, 0, 0), 10.0)\n  wait(2.0)\n  bot_loop(true)\n  bot_run()\nelse\n  log(\"No wood at target location\")\nend\n</code></pre> <p>Warning</p> <p>Always call <code>bot_clear()</code> before adding new commands, or actions will append to the previous program. Always call <code>bot_run()</code> last.</p>"},{"location":"grove/basics/","title":"Language Basics","text":"<p>Grove is a lightweight scripting language designed for EDEN. If you've used Lua, it will feel familiar.</p>"},{"location":"grove/basics/#variables","title":"Variables","text":"<pre><code>local x = 10\nlocal name = \"post_01\"\nlocal pos = vec3(5, 0, 10)\n</code></pre> <p>Use <code>local</code> to declare variables. Grove supports numbers, strings, booleans, <code>vec3</code>, arrays, and tables.</p>"},{"location":"grove/basics/#vec3","title":"Vec3","text":"<p>The <code>vec3</code> type represents 3D positions and directions.</p> <pre><code>local p = vec3(10, 0, 20)\nlocal x = p.x    -- 10\nlocal y = p.y    -- 0\nlocal z = p.z    -- 20\n</code></pre>"},{"location":"grove/basics/#strings","title":"Strings","text":"<p>Strings use double quotes. Concatenate with <code>..</code>:</p> <pre><code>local greeting = \"Hello \" .. \"world\"\nlocal msg = \"Balance: \" .. get_credits() .. \" CR\"\n</code></pre>"},{"location":"grove/basics/#conditionals","title":"Conditionals","text":"<pre><code>if x &gt; 10 then\n  log(\"big\")\nelseif x &gt; 5 then\n  log(\"medium\")\nelse\n  log(\"small\")\nend\n</code></pre>"},{"location":"grove/basics/#loops","title":"Loops","text":"<pre><code>-- While loop\nlocal i = 0\nwhile i &lt; 5 do\n  log(\"count: \" .. i)\n  i = i + 1\nend\n\n-- For loop\nfor i = 1, 10 do\n  log(\"i = \" .. i)\nend\n\n-- Repeat-until\nlocal n = 0\nrepeat\n  n = n + 1\nuntil n &gt;= 5\n</code></pre> <p><code>break</code> exits a loop early. <code>continue</code> skips to the next iteration.</p>"},{"location":"grove/basics/#functions","title":"Functions","text":"<p>Grove scripts call host functions provided by EDEN. You cannot define your own functions in Grove (yet). All available functions are listed in the Function Reference.</p>"},{"location":"grove/basics/#output","title":"Output","text":"<p>Use <code>log()</code> to print messages. Output appears in the Grove console and in NPC chat responses.</p> <pre><code>log(\"Build complete.\")\nlog(\"Height at origin: \" .. terrain_height(vec3(0, 0, 0)))\n</code></pre>"},{"location":"grove/basics/#comments","title":"Comments","text":"<pre><code>-- This is a comment\nlocal x = 10  -- inline comment\n</code></pre>"},{"location":"grove/construction/","title":"Construction","text":"<p>Grove provides two ways to build structures: instant and animated.</p>"},{"location":"grove/construction/#instant-construction","title":"Instant Construction","text":"<p>Objects appear immediately. Use these in <code>run_script</code> actions or the Grove console.</p>"},{"location":"grove/construction/#spawning-primitives","title":"Spawning Primitives","text":"<pre><code>-- Spawn a brown wooden post (cylinder)\nspawn_cylinder(\"post_01\", vec3(10, 0, 20), 0.15, 3.0, 0.6, 0.4, 0.2)\n\n-- Spawn a gray concrete block (cube)\nspawn_cube(\"base_01\", vec3(10, 0, 20), 0.5, 0.65, 0.63, 0.58)\n\n-- Spawn a 3D model\nspawn_model(\"tree_01\", \"models/oak_tree.glb\", vec3(15, 0, 25))\n</code></pre> <p>All spawn functions automatically place the object's bottom on the terrain surface. The Y coordinate in the position is ignored \u2014 terrain height is sampled at X,Z.</p>"},{"location":"grove/construction/#modifying-objects","title":"Modifying Objects","text":"<pre><code>-- Rotate a wall 90 degrees around Y axis\nset_object_rotation(\"wall_01\", 0, 90, 0)\n\n-- Scale a beam to be long and thin\nset_object_scale(\"beam_01\", 4.0, 1.0, 1.0)\n\n-- Remove an object\ndelete_object(\"post_01\")\n</code></pre>"},{"location":"grove/construction/#example-build-a-simple-shelter","title":"Example: Build a Simple Shelter","text":"<pre><code>local p = get_player_pos()\nlocal x = p.x\nlocal z = p.z\nlocal w = 4  -- 4 meter square\n\n-- Four corner posts\nspawn_cylinder(\"post_sw\", vec3(x - w/2, 0, z - w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nspawn_cylinder(\"post_se\", vec3(x + w/2, 0, z - w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nspawn_cylinder(\"post_nw\", vec3(x - w/2, 0, z + w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nspawn_cylinder(\"post_ne\", vec3(x + w/2, 0, z + w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\n\n-- Roof slab\nspawn_cube(\"roof\", vec3(x, 0, z), 0.3, 0.5, 0.2, 0.2)\nset_object_scale(\"roof\", w + 1, 0.5, w + 1)\n\nlog(\"Shelter built.\")\n</code></pre>"},{"location":"grove/construction/#animated-construction","title":"Animated Construction","text":"<p>The NPC walks to each location and builds step by step. Use <code>bot_target()</code> with the NPC's own name, queue movement and spawn actions, then call <code>bot_run()</code>.</p>"},{"location":"grove/construction/#queue-functions","title":"Queue Functions","text":"<p>These schedule actions to execute during the behavior sequence rather than immediately:</p> Function Purpose <code>queue_spawn_cube(name, pos, size, r, g, b)</code> Spawn cube when reached in sequence <code>queue_spawn_cylinder(name, pos, radius, height, r, g, b)</code> Spawn cylinder when reached <code>queue_set_rotation(name, rx, ry, rz)</code> Set rotation when reached <code>queue_set_scale(name, sx, sy, sz)</code> Set scale when reached <code>queue_delete(name)</code> Delete object when reached"},{"location":"grove/construction/#movement-functions","title":"Movement Functions","text":"Function Purpose <code>move_to(vec3, duration)</code> Walk to position over N seconds <code>turn_to(vec3, duration)</code> Turn to face a position <code>wait(seconds)</code> Pause before next action"},{"location":"grove/construction/#example-animated-frame-build","title":"Example: Animated Frame Build","text":"<p>Xenk walks to each corner, spawns a post, then adds beams and a roof:</p> <pre><code>local p = get_player_pos()\nlocal cx = p.x + 6   -- build 6m ahead of player\nlocal cz = p.z\nlocal w = 4\n\nbot_target(\"Xenk\")    -- target yourself\nbot_clear()           -- clear any previous behavior\n\n-- Walk to SW corner, spawn post\nmove_to(vec3(cx - w/2, 0, cz - w/2), 3.0)\nturn_to(vec3(cx, 0, cz), 0.5)\nqueue_spawn_cylinder(\"post_sw\", vec3(cx - w/2, 0, cz - w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nwait(0.5)\n\n-- Walk to SE corner, spawn post\nmove_to(vec3(cx + w/2, 0, cz - w/2), 2.0)\nturn_to(vec3(cx, 0, cz), 0.5)\nqueue_spawn_cylinder(\"post_se\", vec3(cx + w/2, 0, cz - w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nwait(0.5)\n\n-- Walk to NE corner, spawn post\nmove_to(vec3(cx + w/2, 0, cz + w/2), 2.0)\nturn_to(vec3(cx, 0, cz), 0.5)\nqueue_spawn_cylinder(\"post_ne\", vec3(cx + w/2, 0, cz + w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nwait(0.5)\n\n-- Walk to NW corner, spawn post\nmove_to(vec3(cx - w/2, 0, cz + w/2), 2.0)\nturn_to(vec3(cx, 0, cz), 0.5)\nqueue_spawn_cylinder(\"post_nw\", vec3(cx - w/2, 0, cz + w/2), 0.15, 3.0, 0.6, 0.4, 0.2)\nwait(0.5)\n\n-- Walk to center, add roof\nmove_to(vec3(cx, 0, cz), 1.5)\nqueue_spawn_cube(\"roof\", vec3(cx, 0, cz), 0.3, 0.5, 0.2, 0.2)\nqueue_set_scale(\"roof\", w + 1, 0.5, w + 1)\nwait(0.5)\n\nbot_loop(false)       -- run once, don't repeat\nbot_run()             -- start the sequence\nlog(\"Build sequence started.\")\n</code></pre> <p>Note</p> <p><code>bot_run()</code> must always be the last call. The NPC begins walking immediately if the game is in play mode.</p>"},{"location":"grove/construction/#terrain-height","title":"Terrain Height","text":"<p>On sloped terrain, each post may sit at a different height. Use <code>terrain_height()</code> to query the ground level:</p> <pre><code>local h1 = terrain_height(vec3(10, 0, 20))\nlocal h2 = terrain_height(vec3(14, 0, 20))\nlog(\"Height difference: \" .. (h2 - h1) .. \" meters\")\n</code></pre> <p>Spawn functions handle this automatically \u2014 you only need <code>terrain_height()</code> when computing offsets between objects (e.g., angling a beam between posts at different heights).</p>"},{"location":"grove/economy/","title":"Economy &amp; Land","text":"<p>Grove provides functions for managing credits and purchasing land plots.</p>"},{"location":"grove/economy/#credits","title":"Credits","text":"<pre><code>-- Check balance\nlocal balance = get_credits()\nlog(\"Balance: \" .. balance .. \" CR\")\n\n-- Add credits\nadd_credits(1000)\n\n-- Deduct credits (returns true if sufficient funds)\nlocal ok = deduct_credits(500)\nif ok then\n  log(\"Payment processed.\")\nelse\n  log(\"Insufficient funds.\")\nend\n</code></pre>"},{"location":"grove/economy/#land-ownership","title":"Land Ownership","text":"<p>The world is divided into a grid of plots. Each plot has a zone type and can be purchased.</p>"},{"location":"grove/economy/#checking-plot-status","title":"Checking Plot Status","text":"<p>Always check before buying:</p> <pre><code>local pos = vec3(100, 0, 200)\nlocal status = plot_status(pos)\n\nif status == \"available\" then\n  log(\"Plot available for \" .. plot_price(pos) .. \" CR\")\nelseif status == \"owned\" then\n  log(\"Already owned.\")\nelseif status == \"spawn_zone\" then\n  log(\"Spawn zone \u2014 not for sale.\")\nelseif status == \"battlefield\" then\n  log(\"Battlefield \u2014 not for sale.\")\nelseif status == \"too_expensive\" then\n  log(\"Can't afford it. Price: \" .. plot_price(pos) .. \" CR\")\nend\n</code></pre>"},{"location":"grove/economy/#buying-and-selling","title":"Buying and Selling","text":"<pre><code>-- Buy a plot\nlocal ok = buy_plot(vec3(100, 0, 200))\nif ok then\n  log(\"Purchased!\")\nend\n\n-- Sell a plot (50% refund)\nsell_plot(vec3(100, 0, 200))\n</code></pre>"},{"location":"grove/economy/#zone-queries","title":"Zone Queries","text":"<pre><code>-- What type of zone is this?\nlocal zt = zone_type(vec3(100, 0, 200))\n-- Returns: \"wilderness\", \"battlefield\", \"spawn_safe\", \"residential\",\n--          \"commercial\", \"industrial\", \"resource\"\n\n-- What resource is here?\nlocal res = zone_resource(vec3(500, 0, 500))\n-- Returns: \"wood\", \"limestone\", \"iron\", \"oil\", \"none\"\n\n-- Who owns this plot? (0 = unclaimed)\nlocal owner = zone_owner(vec3(100, 0, 200))\n\n-- Can I build here?\nlocal allowed = can_build(vec3(100, 0, 200))\n</code></pre>"},{"location":"grove/economy/#example-buy-land-and-build","title":"Example: Buy Land and Build","text":"<pre><code>local pos = get_player_pos()\nlocal status = plot_status(pos)\n\nif status == \"available\" then\n  local price = plot_price(pos)\n  if deduct_credits(price) then\n    buy_plot(pos)\n    -- Build a marker post\n    spawn_cylinder(\"claim_post\", pos, 0.1, 2.0, 1.0, 0.85, 0.0)\n    log(\"Plot purchased and marked. \" .. get_credits() .. \" CR remaining.\")\n  end\nelse\n  log(\"Cannot buy: \" .. status)\nend\n</code></pre>"},{"location":"grove/reference/","title":"Function Reference","text":"<p>Complete list of all Grove host functions available in EDEN.</p>"},{"location":"grove/reference/#utility","title":"Utility","text":"Function Returns Description <code>log(...)</code> \u2014 Print values to the Grove console. Accepts any number/type of arguments. <code>terrain_height(vec3)</code> number Returns terrain surface height at the X,Z position. <code>get_player_pos()</code> vec3 Returns the player's current world position."},{"location":"grove/reference/#instant-construction","title":"Instant Construction","text":"<p>These execute immediately when the script runs.</p> Function Returns Description <code>spawn_cube(name, pos, size, r, g, b)</code> bool Spawn a colored cube. Bottom placed on terrain. <code>spawn_cylinder(name, pos, radius, height, r, g, b)</code> bool Spawn a colored cylinder. Bottom placed on terrain. <code>spawn_model(name, path, pos)</code> bool Load a <code>.glb</code> or <code>.lime</code> model at position. Bottom placed on terrain. <code>spawn(name, pos)</code> object Spawn a posthole object at position (legacy). <code>set_object_rotation(name, rx, ry, rz)</code> bool Set euler rotation in degrees on a named object. <code>set_object_scale(name, sx, sy, sz)</code> bool Set scale on a named object. <code>delete_object(name)</code> bool Remove the first object matching the name from the scene."},{"location":"grove/reference/#parameter-details","title":"Parameter Details","text":"Parameter Type Description <code>name</code> string Unique identifier for the object <code>pos</code> vec3 World position \u2014 Y is auto-sampled from terrain, so <code>vec3(x, 0, z)</code> works <code>size</code> number Cube edge length in meters <code>radius</code> number Cylinder radius in meters <code>height</code> number Cylinder height in meters <code>r, g, b</code> number Color components, 0.0 to 1.0 <code>path</code> string Model file path (relative to level directory or absolute) <code>rx, ry, rz</code> number Rotation in degrees <code>sx, sy, sz</code> number Scale factors"},{"location":"grove/reference/#queued-construction","title":"Queued Construction","text":"<p>These schedule actions in a behavior sequence. They only execute when the NPC reaches that point in the sequence. Requires <code>bot_target()</code> to be set first.</p> Function Returns Description <code>queue_spawn_cube(name, pos, size, r, g, b)</code> bool Queue a cube spawn in the behavior sequence. <code>queue_spawn_cylinder(name, pos, radius, height, r, g, b)</code> bool Queue a cylinder spawn in the behavior sequence. <code>queue_set_rotation(name, rx, ry, rz)</code> bool Queue a rotation change in the behavior sequence. <code>queue_set_scale(name, sx, sy, sz)</code> bool Queue a scale change in the behavior sequence. <code>queue_delete(name)</code> bool Queue an object deletion in the behavior sequence."},{"location":"grove/reference/#algobot-behavior","title":"AlgoBot Behavior","text":"<p>These queue actions on a target SceneObject's behavior. Call <code>bot_target()</code> first, queue actions, then <code>bot_run()</code> to start.</p> Function Returns Description <code>bot_target(name)</code> bool Select a scene object by name to program. <code>move_to(vec3, duration?, animation?)</code> \u2014 Queue movement to a position over N seconds. Default: 2s. <code>rotate_to(vec3, duration?)</code> \u2014 Queue rotation to euler angles. Default: 1s. <code>turn_to(vec3, duration?)</code> \u2014 Queue turning to face a world position (yaw only). Default: 0.5s. <code>wait(seconds)</code> \u2014 Queue a pause. <code>set_visible(bool)</code> \u2014 Queue visibility toggle. <code>play_anim(name, duration?)</code> \u2014 Queue an animation. Duration 0 = play indefinitely. <code>send_signal(name, target?)</code> \u2014 Queue a signal broadcast. Optional target name. <code>follow_path(path_name)</code> \u2014 Queue following a named AI path. <code>bot_loop(bool)</code> \u2014 Set whether the behavior repeats. Default: false. <code>bot_clear()</code> \u2014 Clear all queued actions on the target. <code>bot_run()</code> \u2014 Start the behavior. Must be called last."},{"location":"grove/reference/#economy","title":"Economy","text":"Function Returns Description <code>get_credits()</code> number Returns the player's current credit balance. <code>add_credits(amount)</code> number Add credits. Returns new balance. <code>deduct_credits(amount)</code> bool Deduct credits. Returns true if sufficient funds. <code>buy_plot(vec3)</code> bool Purchase the land plot at position. Auto-checks price, funds, and ownership. <code>sell_plot(vec3)</code> bool Sell an owned plot for 50% refund. <code>plot_price(vec3)</code> number Returns the price of the plot at position. <code>plot_status(vec3)</code> string Returns <code>\"available\"</code>, <code>\"owned\"</code>, <code>\"spawn_zone\"</code>, <code>\"battlefield\"</code>, or <code>\"too_expensive\"</code>."},{"location":"grove/reference/#zones","title":"Zones","text":"Function Returns Description <code>zone_type(vec3)</code> string Returns zone type: <code>\"wilderness\"</code>, <code>\"battlefield\"</code>, <code>\"spawn_safe\"</code>, <code>\"residential\"</code>, <code>\"commercial\"</code>, <code>\"industrial\"</code>, <code>\"resource\"</code>. <code>zone_resource(vec3)</code> string Returns resource type: <code>\"wood\"</code>, <code>\"limestone\"</code>, <code>\"iron\"</code>, <code>\"oil\"</code>, <code>\"none\"</code>. <code>zone_owner(vec3)</code> number Returns owner ID of the plot (0 = unclaimed). <code>can_build(vec3)</code> bool Returns whether building is allowed at position."}]}
#include "ModelingMode.hpp"
#include "Editor/GLBLoader.hpp"
#include "Renderer/Swapchain.hpp"

#include <imgui.h>
#include <nfd.h>
#include <GLFW/glfw3.h>
#include <stb_image.h>

#include <iostream>
#include <queue>
#include <filesystem>
#include <limits>
#include <random>

using namespace eden;

// Debug flag for wireframe rendering (reset when mesh is rebuilt)
static bool g_wireframeDebugPrinted = false;

// Bridge edges segment count (shared between UI and keyboard shortcut)
static int g_bridgeSegments = 1;

// Helper to check if a vertex is on a UV seam (boundary edge)
static bool isSeamVertex(const EditableMesh& mesh, uint32_t vertIdx) {
    // Get all half-edges emanating from this vertex
    auto edges = mesh.getVertexEdges(vertIdx);
    for (uint32_t heIdx : edges) {
        const HalfEdge& he = mesh.getHalfEdge(heIdx);
        // If this half-edge has no twin, it's a boundary edge
        if (he.twinIndex == UINT32_MAX) {
            return true;
        }
    }
    return false;
}

ModelingMode::ModelingMode(EditorContext& ctx)
    : IEditorMode(ctx)
{
}

void ModelingMode::onActivate() {
    // Build editable mesh if we have a selected object
    if (m_ctx.selectedObject && m_ctx.selectedObject->hasMeshData()) {
        buildEditableMeshFromObject();
    }
}

void ModelingMode::onDeactivate() {
    // Nothing special needed
}

void ModelingMode::processInput(float deltaTime) {
    bool gizmoConsumedInput = processGizmoInput();
    processModelingInput(deltaTime, gizmoConsumedInput);
}

void ModelingMode::update(float deltaTime) {
    // Update mode notification timer
    if (m_modeNotificationTimer > 0.0f) {
        m_modeNotificationTimer -= deltaTime;
    }

    // Process deferred mesh updates (must happen before rendering, not during)
    if (m_ctx.meshDirty) {
        updateMeshFromEditable();
    }

    // Process deferred clone image deletions (must happen before ImGui rendering)
    if (m_pendingCloneImageDelete >= 0 && m_pendingCloneImageDelete < static_cast<int>(m_ctx.cloneSourceImages.size())) {
        int idx = m_pendingCloneImageDelete;
        m_pendingCloneImageDelete = -1;  // Clear before deletion

        // Destroy Vulkan texture
        if (m_ctx.destroyCloneImageTextureCallback) {
            m_ctx.destroyCloneImageTextureCallback(m_ctx.cloneSourceImages[idx]);
        }
        m_ctx.cloneSourceImages.erase(m_ctx.cloneSourceImages.begin() + idx);

        // Adjust selected index
        if (m_ctx.imageRefSelectedIndex >= static_cast<int>(m_ctx.cloneSourceImages.size())) {
            m_ctx.imageRefSelectedIndex = static_cast<int>(m_ctx.cloneSourceImages.size()) - 1;
        }
    }

    // Process deferred stamp preview update (must happen before ImGui rendering)
    if (m_pendingStampPreviewUpdate && !m_ctx.stampData.empty()) {
        m_pendingStampPreviewUpdate = false;
        if (m_ctx.updateStampPreviewCallback) {
            m_ctx.updateStampPreviewCallback(m_ctx.stampData.data(), m_ctx.stampWidth, m_ctx.stampHeight);
        }
    }
}

void ModelingMode::renderUI() {
    // Display mode notification overlay
    if (m_modeNotificationTimer > 0.0f) {
        const char* modeText = m_ctx.objectMode ? "OBJECT MODE" : "COMPONENT MODE";

        // Center the notification horizontally, near top of screen
        ImVec2 windowSize = ImGui::GetIO().DisplaySize;
        ImVec2 textSize = ImGui::CalcTextSize(modeText);
        ImVec2 pos((windowSize.x - textSize.x * 2.0f) * 0.5f, 50.0f);

        ImGui::SetNextWindowPos(pos);
        ImGui::SetNextWindowBgAlpha(0.7f * m_modeNotificationTimer);  // Fade out
        ImGui::Begin("##ModeNotification", nullptr,
            ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize |
            ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs);

        ImGui::SetWindowFontScale(2.0f);
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, m_modeNotificationTimer), "%s", modeText);
        ImGui::SetWindowFontScale(1.0f);

        ImGui::End();
    }

    renderModelingEditorUI();

    // WYSIWYG stamp preview - actually render the stamp on the texture
    if (m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData()) {
        bool shouldShowPreview = m_ctx.isPainting && m_ctx.useStamp && !m_ctx.stampData.empty();
        bool mouseOverImGui = ImGui::GetIO().WantCaptureMouse;

        if (shouldShowPreview && !mouseOverImGui) {
            glm::vec3 rayOrigin, rayDir;
            m_ctx.getMouseRay(rayOrigin, rayDir);

            auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
            if (hit.hit) {
                // Apply preview stamp to texture
                m_ctx.selectedObject->stampPreviewAt(hit.uv, m_ctx.stampData.data(),
                                                      m_ctx.stampWidth, m_ctx.stampHeight,
                                                      m_ctx.stampScale * m_ctx.stampScaleH, m_ctx.stampScale * m_ctx.stampScaleV,
                                                      m_ctx.stampRotation, m_ctx.stampOpacity, m_ctx.stampFlipH, m_ctx.stampFlipV);

                // Upload modified texture to GPU for preview
                uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                auto& texData = m_ctx.selectedObject->getTextureData();
                int w = m_ctx.selectedObject->getTextureWidth();
                int h = m_ctx.selectedObject->getTextureHeight();
                m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
                m_ctx.selectedObject->clearTextureModified();
            } else {
                // Not hovering over model - clear preview
                if (m_ctx.selectedObject->hasStampPreview()) {
                    m_ctx.selectedObject->clearStampPreview();
                    // Upload restored texture
                    uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                    auto& texData = m_ctx.selectedObject->getTextureData();
                    int w = m_ctx.selectedObject->getTextureWidth();
                    int h = m_ctx.selectedObject->getTextureHeight();
                    m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
                    m_ctx.selectedObject->clearTextureModified();
                }
            }
        } else {
            // Not in stamp mode - clear any existing preview
            if (m_ctx.selectedObject->hasStampPreview()) {
                m_ctx.selectedObject->clearStampPreview();
                // Upload restored texture
                uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                auto& texData = m_ctx.selectedObject->getTextureData();
                int w = m_ctx.selectedObject->getTextureWidth();
                int h = m_ctx.selectedObject->getTextureHeight();
                m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
                m_ctx.selectedObject->clearTextureModified();
            }
        }
    }

    // Check if Alt is held for eyedropper mode
    bool altHeld = Input::isKeyDown(Input::KEY_LEFT_ALT) || Input::isKeyDown(Input::KEY_RIGHT_ALT);
    bool ctrlHeld = Input::isKeyDown(Input::KEY_LEFT_CONTROL) || Input::isKeyDown(Input::KEY_RIGHT_CONTROL);
    bool eyedropperActive = altHeld && m_ctx.isPainting;
    bool cloneSourceMode = ctrlHeld && m_ctx.isPainting;

    // Draw vertex paint brush cursor
    if (m_vertexPaintMode && m_ctx.selectedObject && m_ctx.editableMesh.isValid()) {
        bool mouseOverImGui = ImGui::GetIO().WantCaptureMouse;
        if (!mouseOverImGui) {
            ImVec2 mousePos = ImGui::GetMousePos();

            // Raycast to find hit point
            glm::vec3 rayOrigin, rayDir;
            m_ctx.getMouseRay(rayOrigin, rayDir);

            glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
            glm::mat4 invModel = glm::inverse(modelMatrix);
            glm::vec3 localRayOrigin = glm::vec3(invModel * glm::vec4(rayOrigin, 1.0f));
            glm::vec3 localRayDir = glm::normalize(glm::vec3(invModel * glm::vec4(rayDir, 0.0f)));

            auto hit = m_ctx.editableMesh.raycastFace(localRayOrigin, localRayDir);

            float screenRadius = 20.0f;  // Default fallback

            if (hit.hit) {
                // Transform hit position to world space for screen projection
                glm::vec3 worldHitPos = glm::vec3(modelMatrix * glm::vec4(hit.position, 1.0f));

                // Get world-space brush radius (apply object scale)
                glm::vec3 scale = m_ctx.selectedObject->getTransform().getScale();
                float avgScale = (scale.x + scale.y + scale.z) / 3.0f;
                float worldRadius = m_vertexPaintRadius * avgScale;

                // Project to screen space
                Camera& cam = m_ctx.getActiveCamera();
                float screenWidth = static_cast<float>(m_ctx.window.getWidth());
                float screenHeight = static_cast<float>(m_ctx.window.getHeight());
                float aspect = screenWidth / screenHeight;
                glm::mat4 viewProj = cam.getProjectionMatrix(aspect) * cam.getViewMatrix();

                glm::vec4 clipCenter = viewProj * glm::vec4(worldHitPos, 1.0f);
                glm::vec4 clipOffset = viewProj * glm::vec4(worldHitPos + cam.getRight() * worldRadius, 1.0f);

                if (clipCenter.w > 0.001f && clipOffset.w > 0.001f) {
                    glm::vec2 screenCenter = glm::vec2(clipCenter.x / clipCenter.w, clipCenter.y / clipCenter.w);
                    glm::vec2 screenOffset = glm::vec2(clipOffset.x / clipOffset.w, clipOffset.y / clipOffset.w);

                    screenCenter = (screenCenter * 0.5f + 0.5f) * glm::vec2(screenWidth, screenHeight);
                    screenOffset = (screenOffset * 0.5f + 0.5f) * glm::vec2(screenWidth, screenHeight);

                    screenRadius = glm::length(screenOffset - screenCenter);
                }
            }

            if (screenRadius < 5.0f) screenRadius = 5.0f;

            // Draw green circle for vertex paint brush
            ImDrawList* drawList = ImGui::GetForegroundDrawList();
            ImU32 circleColor = IM_COL32(
                static_cast<int>(m_vertexPaintColor.r * 255),
                static_cast<int>(m_vertexPaintColor.g * 255),
                static_cast<int>(m_vertexPaintColor.b * 255),
                200
            );
            drawList->AddCircle(mousePos, screenRadius, circleColor, 32, 2.0f);
            // Add white outline for visibility
            drawList->AddCircle(mousePos, screenRadius + 1, IM_COL32(255, 255, 255, 150), 32, 1.0f);
        }
    }

    // Draw clone source cursor (Ctrl held in paint mode)
    if (cloneSourceMode) {
        bool mouseOverImGui = ImGui::GetIO().WantCaptureMouse;
        if (!mouseOverImGui) {
            ImVec2 mousePos = ImGui::GetMousePos();
            ImDrawList* drawList = ImGui::GetForegroundDrawList();

            // Draw crosshair with "+" symbol for clone source
            float size = 15.0f;
            ImU32 cyan = IM_COL32(100, 200, 255, 255);
            ImU32 black = IM_COL32(0, 0, 0, 255);

            // Crosshair with outline
            drawList->AddLine(ImVec2(mousePos.x - size, mousePos.y), ImVec2(mousePos.x + size, mousePos.y), black, 3.0f);
            drawList->AddLine(ImVec2(mousePos.x, mousePos.y - size), ImVec2(mousePos.x, mousePos.y + size), black, 3.0f);
            drawList->AddLine(ImVec2(mousePos.x - size, mousePos.y), ImVec2(mousePos.x + size, mousePos.y), cyan, 2.0f);
            drawList->AddLine(ImVec2(mousePos.x, mousePos.y - size), ImVec2(mousePos.x, mousePos.y + size), cyan, 2.0f);

            // Circle around crosshair
            drawList->AddCircle(mousePos, size + 3, black, 16, 3.0f);
            drawList->AddCircle(mousePos, size + 3, cyan, 16, 1.5f);
        }
    }

    // Draw eyedropper cursor indicator (Alt held in paint mode)
    if (eyedropperActive) {
        bool mouseOverImGui = ImGui::GetIO().WantCaptureMouse;
        if (!mouseOverImGui) {
            ImVec2 mousePos = ImGui::GetMousePos();
            ImDrawList* drawList = ImGui::GetForegroundDrawList();

            // Draw eyedropper icon (a small crosshair with color preview)
            float size = 12.0f;
            ImU32 white = IM_COL32(255, 255, 255, 255);
            ImU32 black = IM_COL32(0, 0, 0, 255);

            // Crosshair with outline
            drawList->AddLine(ImVec2(mousePos.x - size, mousePos.y), ImVec2(mousePos.x + size, mousePos.y), black, 3.0f);
            drawList->AddLine(ImVec2(mousePos.x, mousePos.y - size), ImVec2(mousePos.x, mousePos.y + size), black, 3.0f);
            drawList->AddLine(ImVec2(mousePos.x - size, mousePos.y), ImVec2(mousePos.x + size, mousePos.y), white, 1.0f);
            drawList->AddLine(ImVec2(mousePos.x, mousePos.y - size), ImVec2(mousePos.x, mousePos.y + size), white, 1.0f);

            // Show current color preview
            ImU32 previewColor = IM_COL32(
                static_cast<int>(m_ctx.paintColor.r * 255),
                static_cast<int>(m_ctx.paintColor.g * 255),
                static_cast<int>(m_ctx.paintColor.b * 255),
                255
            );
            drawList->AddRectFilled(
                ImVec2(mousePos.x + size + 4, mousePos.y - size),
                ImVec2(mousePos.x + size + 24, mousePos.y + size),
                previewColor
            );
            drawList->AddRect(
                ImVec2(mousePos.x + size + 4, mousePos.y - size),
                ImVec2(mousePos.x + size + 24, mousePos.y + size),
                white, 0.0f, 0, 1.0f
            );
        }
    }
}

void ModelingMode::renderSceneOverlay(VkCommandBuffer cmd, const glm::mat4& viewProj) {
    // Render grid if enabled
    if (m_ctx.showGrid) {
        renderGrid3D(cmd, viewProj);
    }

    // Debug: check what objects we're rendering
    static int renderDebugCounter = 0;
    if (++renderDebugCounter % 300 == 1) {
        std::cout << "[Render] sceneObjects count: " << m_ctx.sceneObjects.size() << std::endl;
        for (size_t i = 0; i < m_ctx.sceneObjects.size(); i++) {
            auto& obj = m_ctx.sceneObjects[i];
            glm::mat4 m = obj->getTransform().getMatrix();
            glm::vec3 pos(m[3]);
            std::cout << "[Render] obj[" << i << "] name=" << obj->getName()
                      << " pos=(" << pos.x << "," << pos.y << "," << pos.z << ")"
                      << " selected=" << (obj.get() == m_ctx.selectedObject) << std::endl;
        }
    }

    // Render all scene objects
    for (auto& obj : m_ctx.sceneObjects) {
        if (!obj->isVisible()) continue;
        glm::mat4 modelMatrix = obj->getTransform().getMatrix();
        // X-ray mode disables backface culling for this object
        bool twoSided = obj->isXRay();
        m_ctx.modelRenderer.render(cmd, viewProj, obj->getBufferHandle(), modelMatrix, 0.0f, 1.0f, 1.0f, twoSided);
    }

    // Render modeling overlay (selection highlighting)
    renderModelingOverlay(cmd, viewProj);

    // Render wireframe with depth testing
    if (m_ctx.showModelingWireframe) {
        renderWireframeOverlay3D(cmd, viewProj);
    }

    // Render gizmo
    renderGizmo(cmd, viewProj);

    // Render snap source face highlight (red)
    if (m_snapMode && m_snapSourceObject && m_snapSourceFace >= 0) {
        if (m_snapSourceObject->hasEditableMeshData()) {
            const auto& heVerts = m_snapSourceObject->getHEVertices();
            const auto& heEdges = m_snapSourceObject->getHEHalfEdges();
            const auto& heFaces = m_snapSourceObject->getHEFaces();

            if (m_snapSourceFace < static_cast<int>(heFaces.size())) {
                // Collect face vertices by walking half-edges
                std::vector<uint32_t> faceVertIndices;
                uint32_t startHE = heFaces[m_snapSourceFace].halfEdgeIndex;
                uint32_t currHE = startHE;
                do {
                    faceVertIndices.push_back(heEdges[currHE].vertexIndex);
                    currHE = heEdges[currHE].nextIndex;
                } while (currHE != startHE && faceVertIndices.size() < 10);

                glm::mat4 srcModelMatrix = m_snapSourceObject->getTransform().getMatrix();

                // Draw face edges in red
                std::vector<glm::vec3> faceEdges;
                for (size_t i = 0; i < faceVertIndices.size(); ++i) {
                    uint32_t vi0 = faceVertIndices[i];
                    uint32_t vi1 = faceVertIndices[(i + 1) % faceVertIndices.size()];
                    glm::vec3 p0 = glm::vec3(srcModelMatrix * glm::vec4(heVerts[vi0].position, 1.0f));
                    glm::vec3 p1 = glm::vec3(srcModelMatrix * glm::vec4(heVerts[vi1].position, 1.0f));
                    faceEdges.push_back(p0);
                    faceEdges.push_back(p1);
                }
                if (!faceEdges.empty()) {
                    m_ctx.modelRenderer.renderLines(cmd, viewProj, faceEdges, glm::vec3(1.0f, 0.0f, 0.0f));
                }
            }
        }
    }
}

void ModelingMode::drawOverlays(float vpX, float vpY, float vpW, float vpH) {
    // Wireframe and vertices are now rendered with Vulkan (depth-tested) in renderSceneOverlay
    // ImGui overlays are only used for face normals and reference images now

    // Determine which camera to use based on viewport
    // In split view, right viewport (vpX > 0) uses camera2 (ortho), left uses camera (perspective)
    Camera& activeCamera = (m_ctx.splitView && vpX > 0) ? m_ctx.camera2 : m_ctx.camera;

    // Draw face normals
    if (m_ctx.showFaceNormals) {
        drawFaceNormalsOverlay(activeCamera, vpX, vpY, vpW, vpH);
    }

    // Draw reference images for ortho views
    drawReferenceImages(activeCamera, vpX, vpY, vpW, vpH);

    // Draw rectangle selection overlay
    if (m_ctx.isRectSelecting) {
        ImDrawList* drawList = ImGui::GetBackgroundDrawList();
        ImU32 fillColor = IM_COL32(100, 150, 255, 50);
        ImU32 borderColor = IM_COL32(100, 150, 255, 200);

        float minX = std::min(m_ctx.rectSelectStart.x, m_ctx.rectSelectEnd.x);
        float maxX = std::max(m_ctx.rectSelectStart.x, m_ctx.rectSelectEnd.x);
        float minY = std::min(m_ctx.rectSelectStart.y, m_ctx.rectSelectEnd.y);
        float maxY = std::max(m_ctx.rectSelectStart.y, m_ctx.rectSelectEnd.y);

        drawList->AddRectFilled(ImVec2(minX, minY), ImVec2(maxX, maxY), fillColor);
        drawList->AddRect(ImVec2(minX, minY), ImVec2(maxX, maxY), borderColor, 0.0f, 0, 2.0f);
    }

    // Draw paint select brush cursor
    if (m_ctx.selectionTool == SelectionTool::Paint && !m_ctx.isPainting) {
        ImDrawList* drawList = ImGui::GetBackgroundDrawList();
        ImU32 brushColor = IM_COL32(255, 200, 100, 150);
        glm::vec2 mousePos = Input::getMousePosition();
        drawList->AddCircle(ImVec2(mousePos.x, mousePos.y), m_ctx.paintSelectRadius, brushColor, 32, 2.0f);
    }

    // Draw selection outline for all selected objects (in object mode)
    if (m_ctx.objectMode && !m_ctx.selectedObjects.empty()) {
        ImDrawList* drawList = ImGui::GetBackgroundDrawList();
        drawList->PushClipRect(ImVec2(vpX, vpY), ImVec2(vpX + vpW, vpY + vpH), true);

        glm::mat4 view = activeCamera.getViewMatrix();
        float aspectRatio = vpW / vpH;
        glm::mat4 proj = activeCamera.getProjectionMatrix(aspectRatio);
        glm::mat4 vp = proj * view;

        auto worldToScreen = [&](const glm::vec3& worldPos) -> ImVec2 {
            glm::vec4 clip = vp * glm::vec4(worldPos, 1.0f);
            if (clip.w <= 0.0f) return ImVec2(-1000, -1000);
            glm::vec3 ndc = glm::vec3(clip) / clip.w;
            return ImVec2(vpX + (ndc.x + 1.0f) * 0.5f * vpW, vpY + (1.0f - ndc.y) * 0.5f * vpH);
        };

        // Orange outline for selected objects
        ImU32 selectionColor = IM_COL32(255, 165, 0, 200);
        float lineThickness = 2.0f;

        for (SceneObject* obj : m_ctx.selectedObjects) {
            if (!obj || !obj->isVisible() || !obj->hasMeshData()) continue;
            // Skip the primary selected object if wireframe is already shown
            if (obj == m_ctx.selectedObject && m_ctx.showModelingWireframe) continue;

            const auto& verts = obj->getVertices();
            const auto& indices = obj->getIndices();
            glm::mat4 modelMatrix = obj->getTransform().getMatrix();

            // Draw triangle edges
            for (size_t i = 0; i + 2 < indices.size(); i += 3) {
                glm::vec3 p0 = glm::vec3(modelMatrix * glm::vec4(verts[indices[i]].position, 1.0f));
                glm::vec3 p1 = glm::vec3(modelMatrix * glm::vec4(verts[indices[i+1]].position, 1.0f));
                glm::vec3 p2 = glm::vec3(modelMatrix * glm::vec4(verts[indices[i+2]].position, 1.0f));

                ImVec2 s0 = worldToScreen(p0);
                ImVec2 s1 = worldToScreen(p1);
                ImVec2 s2 = worldToScreen(p2);

                // Only draw if all points are in front of camera
                if (s0.x > -500 && s1.x > -500) drawList->AddLine(s0, s1, selectionColor, lineThickness);
                if (s1.x > -500 && s2.x > -500) drawList->AddLine(s1, s2, selectionColor, lineThickness);
                if (s2.x > -500 && s0.x > -500) drawList->AddLine(s2, s0, selectionColor, lineThickness);
            }
        }

        drawList->PopClipRect();
    }

    // Draw snap vertex mode overlay (numbered vertices)
    if (m_snapVertexMode) {
        drawSnapVertexOverlay(vpX, vpY, vpW, vpH);
    }
}

void ModelingMode::drawSnapVertexOverlay(float vpX, float vpY, float vpW, float vpH) {
    Camera& activeCamera = (m_ctx.splitView && vpX > 0) ? m_ctx.camera2 : m_ctx.camera;

    glm::mat4 view = activeCamera.getViewMatrix();
    float aspectRatio = vpW / vpH;
    glm::mat4 proj = activeCamera.getProjectionMatrix(aspectRatio);
    glm::mat4 vp = proj * view;

    auto worldToScreen = [&](const glm::vec3& worldPos) -> ImVec2 {
        glm::vec4 clip = vp * glm::vec4(worldPos, 1.0f);
        if (clip.w <= 0.0f) return ImVec2(-1000, -1000);
        glm::vec3 ndc = glm::vec3(clip) / clip.w;
        return ImVec2(vpX + (ndc.x + 1.0f) * 0.5f * vpW, vpY + (1.0f - ndc.y) * 0.5f * vpH);
    };

    ImDrawList* drawList = ImGui::GetBackgroundDrawList();
    drawList->PushClipRect(ImVec2(vpX, vpY), ImVec2(vpX + vpW, vpY + vpH), true);

    // Draw all vertices on source object (if set)
    if (m_snapSrcObj && m_snapSrcObj->hasEditableMeshData()) {
        glm::mat4 modelMatrix = m_snapSrcObj->getTransform().getMatrix();
        const auto& heVerts = m_snapSrcObj->getHEVertices();

        // Draw unselected vertices in cyan
        ImU32 vertColor = IM_COL32(0, 200, 255, 200);
        float vertRadius = 6.0f;

        for (size_t vi = 0; vi < heVerts.size(); ++vi) {
            // Skip if already selected
            bool isSelected = false;
            for (uint32_t selIdx : m_snapSrcVertIndices) {
                if (selIdx == vi) { isSelected = true; break; }
            }
            if (isSelected) continue;

            glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(heVerts[vi].position, 1.0f));
            ImVec2 screenPos = worldToScreen(worldPos);
            if (screenPos.x > -500) {
                drawList->AddCircleFilled(screenPos, vertRadius, vertColor);
                drawList->AddCircle(screenPos, vertRadius, IM_COL32(0, 0, 0, 255), 0, 1.5f);
            }
        }
    }

    // Draw all vertices on target object (if set and different from source)
    if (m_snapDstObj && m_snapDstObj != m_snapSrcObj && m_snapDstObj->hasEditableMeshData()) {
        glm::mat4 modelMatrix = m_snapDstObj->getTransform().getMatrix();
        const auto& heVerts = m_snapDstObj->getHEVertices();

        // Draw unselected vertices in magenta
        ImU32 vertColor = IM_COL32(255, 100, 200, 200);
        float vertRadius = 6.0f;

        for (size_t vi = 0; vi < heVerts.size(); ++vi) {
            // Skip if already selected
            bool isSelected = false;
            for (uint32_t selIdx : m_snapDstVertIndices) {
                if (selIdx == vi) { isSelected = true; break; }
            }
            if (isSelected) continue;

            glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(heVerts[vi].position, 1.0f));
            ImVec2 screenPos = worldToScreen(worldPos);
            if (screenPos.x > -500) {
                drawList->AddCircleFilled(screenPos, vertRadius, vertColor);
                drawList->AddCircle(screenPos, vertRadius, IM_COL32(0, 0, 0, 255), 0, 1.5f);
            }
        }
    }

    // Draw selected source vertices with numbers (green)
    ImU32 srcSelectedColor = IM_COL32(50, 255, 50, 255);
    float selectedRadius = 10.0f;
    for (size_t i = 0; i < m_snapSrcVerts.size(); ++i) {
        ImVec2 screenPos = worldToScreen(m_snapSrcVerts[i]);
        if (screenPos.x > -500) {
            drawList->AddCircleFilled(screenPos, selectedRadius, srcSelectedColor);
            drawList->AddCircle(screenPos, selectedRadius, IM_COL32(0, 0, 0, 255), 0, 2.0f);
            // Draw number
            char numStr[8];
            snprintf(numStr, sizeof(numStr), "%zu", i + 1);
            ImVec2 textSize = ImGui::CalcTextSize(numStr);
            drawList->AddText(ImVec2(screenPos.x - textSize.x * 0.5f, screenPos.y - textSize.y * 0.5f),
                             IM_COL32(0, 0, 0, 255), numStr);
        }
    }

    // Draw selected target vertices with numbers (orange)
    ImU32 dstSelectedColor = IM_COL32(255, 165, 0, 255);
    for (size_t i = 0; i < m_snapDstVerts.size(); ++i) {
        ImVec2 screenPos = worldToScreen(m_snapDstVerts[i]);
        if (screenPos.x > -500) {
            drawList->AddCircleFilled(screenPos, selectedRadius, dstSelectedColor);
            drawList->AddCircle(screenPos, selectedRadius, IM_COL32(0, 0, 0, 255), 0, 2.0f);
            // Draw number
            char numStr[8];
            snprintf(numStr, sizeof(numStr), "%zu", i + 1);
            ImVec2 textSize = ImGui::CalcTextSize(numStr);
            drawList->AddText(ImVec2(screenPos.x - textSize.x * 0.5f, screenPos.y - textSize.y * 0.5f),
                             IM_COL32(0, 0, 0, 255), numStr);
        }
    }

    drawList->PopClipRect();
}

void ModelingMode::renderModelingEditorUI() {
    // Scene window
    ImGui::SetNextWindowPos(ImVec2(0, 20), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(250, 350), ImGuiCond_FirstUseEver);

    if (m_ctx.showSceneWindow) {
    if (ImGui::Begin("Scene", &m_ctx.showSceneWindow)) {
        // Object list
        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Objects");
        ImGui::Separator();

        static int lastClickedIndex = -1;  // For shift-click range selection

        for (size_t i = 0; i < m_ctx.sceneObjects.size(); ++i) {
            auto& obj = m_ctx.sceneObjects[i];
            ImGui::PushID(static_cast<int>(i));

            // Check if in multi-selection set or is primary selection
            bool isInMultiSelect = m_ctx.selectedObjects.count(obj.get()) > 0;
            bool isPrimary = (obj.get() == m_ctx.selectedObject);
            bool isSelected = isInMultiSelect || isPrimary;

            // Visibility toggle
            bool visible = obj->isVisible();
            if (ImGui::Checkbox("##vis", &visible)) {
                obj->setVisible(visible);
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("Visible");
            ImGui::SameLine();

            // X-Ray toggle
            bool xray = obj->isXRay();
            if (ImGui::Checkbox("##xray", &xray)) {
                obj->setXRay(xray);
            }
            if (ImGui::IsItemHovered()) ImGui::SetTooltip("X-Ray");
            ImGui::SameLine();

            // Object name (selectable)
            if (m_ctx.renamingObjectIndex == static_cast<int>(i)) {
                ImGui::SetKeyboardFocusHere();
                if (ImGui::InputText("##rename", m_ctx.renameBuffer, m_ctx.renameBufferSize,
                    ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_AutoSelectAll)) {
                    obj->setName(m_ctx.renameBuffer);
                    m_ctx.renamingObjectIndex = -1;
                }
                if (!ImGui::IsItemActive() && ImGui::IsMouseClicked(0)) {
                    m_ctx.renamingObjectIndex = -1;
                }
            } else {
                if (ImGui::Selectable(obj->getName().c_str(), isSelected)) {
                    bool ctrlHeld = ImGui::GetIO().KeyCtrl;
                    bool shiftHeld = ImGui::GetIO().KeyShift;

                    if (ctrlHeld) {
                        // Ctrl+Click: Toggle individual selection
                        if (isInMultiSelect) {
                            m_ctx.selectedObjects.erase(obj.get());
                        } else {
                            m_ctx.selectedObjects.insert(obj.get());
                        }
                        // Update primary selection
                        if (m_ctx.selectedObject != obj.get()) {
                            m_ctx.selectedObject = obj.get();
                            buildEditableMeshFromObject();
                        }
                        lastClickedIndex = static_cast<int>(i);
                    } else if (shiftHeld && lastClickedIndex >= 0) {
                        // Shift+Click: Range selection
                        int start = std::min(lastClickedIndex, static_cast<int>(i));
                        int end = std::max(lastClickedIndex, static_cast<int>(i));
                        for (int j = start; j <= end; ++j) {
                            m_ctx.selectedObjects.insert(m_ctx.sceneObjects[j].get());
                        }
                        // Update primary selection
                        if (m_ctx.selectedObject != obj.get()) {
                            m_ctx.selectedObject = obj.get();
                            buildEditableMeshFromObject();
                        }
                    } else {
                        // Normal click: Select single, clear others
                        m_ctx.selectedObjects.clear();
                        m_ctx.selectedObjects.insert(obj.get());
                        if (m_ctx.selectedObject != obj.get()) {
                            m_ctx.selectedObject = obj.get();
                            buildEditableMeshFromObject();
                        }
                        lastClickedIndex = static_cast<int>(i);
                    }
                }
                if (ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked(0)) {
                    m_ctx.renamingObjectIndex = static_cast<int>(i);
                    strncpy(m_ctx.renameBuffer, obj->getName().c_str(), m_ctx.renameBufferSize - 1);
                }
            }

            ImGui::PopID();
        }

        if (m_ctx.sceneObjects.empty()) {
            ImGui::TextDisabled("No objects in scene");
        }

        ImGui::Spacing();

        // Object mode toggle and object operations
        ImGui::Checkbox("Object Mode", &m_ctx.objectMode);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("When enabled, gizmo moves entire object instead of components");
        }

        if (m_ctx.selectedObject) {
            ImGui::SameLine();
            if (ImGui::Button("Duplicate")) {
                // Ensure mesh is synced before duplicating (meshDirty means EditableMesh has changes not yet saved to SceneObject)
                if (m_ctx.meshDirty) {
                    updateMeshFromEditable();
                }

                // Duplicate selected object
                auto& srcObj = m_ctx.selectedObject;
                auto newObj = std::make_unique<SceneObject>(srcObj->getName() + "_copy");

                // Copy mesh data
                const auto& srcVerts = srcObj->getVertices();
                const auto& srcIndices = srcObj->getIndices();

                if (!srcVerts.empty() && !srcIndices.empty()) {
                    uint32_t handle = m_ctx.modelRenderer.createModel(srcVerts, srcIndices, nullptr, 0, 0);
                    newObj->setBufferHandle(handle);
                    newObj->setIndexCount(static_cast<uint32_t>(srcIndices.size()));
                    newObj->setVertexCount(static_cast<uint32_t>(srcVerts.size()));
                    newObj->setMeshData(srcVerts, srcIndices);

                    // CRITICAL: Also copy EditableMesh half-edge data (preserves quad topology)
                    if (srcObj->hasEditableMeshData()) {
                        newObj->setEditableMeshData(
                            srcObj->getHEVertices(),
                            srcObj->getHEHalfEdges(),
                            srcObj->getHEFaces()
                        );
                        std::cout << "Copied EditableMesh data to duplicate: "
                                  << srcObj->getHEVertices().size() << " verts, "
                                  << srcObj->getHEFaces().size() << " faces" << std::endl;
                    } else {
                        std::cout << "WARNING: Source object has no EditableMesh data to copy!" << std::endl;
                    }

                    // Copy source transform (including scale and rotation), then offset position
                    auto& srcTransform = srcObj->getTransform();
                    auto& transform = newObj->getTransform();
                    transform.setScale(srcTransform.getScale());
                    transform.setRotation(srcTransform.getRotation());
                    transform.setPosition(srcTransform.getPosition() + glm::vec3(1, 0, 0));

                    // Copy texture data if source has a texture
                    if (srcObj->hasTextureData()) {
                        const auto& texData = srcObj->getTextureData();
                        int texW = srcObj->getTextureWidth();
                        int texH = srcObj->getTextureHeight();
                        newObj->setTextureData(texData, texW, texH);
                    }
                }

                m_ctx.sceneObjects.push_back(std::move(newObj));
            }

            // Mirror buttons - duplicate, flip geometry, and move to mirrored world position
            ImGui::SameLine();
            if (ImGui::Button("Mirror X")) {
                if (m_ctx.meshDirty) {
                    updateMeshFromEditable();
                }

                auto& srcObj = m_ctx.selectedObject;
                auto newObj = std::make_unique<SceneObject>(srcObj->getName() + "_mirrorX");

                // Copy and flip mesh data on X axis
                auto srcVerts = srcObj->getVertices();
                const auto& srcIndices = srcObj->getIndices();

                // Flip X coordinate of all vertices
                for (auto& v : srcVerts) {
                    v.position.x = -v.position.x;
                    v.normal.x = -v.normal.x;
                }

                // Reverse triangle winding order (mirroring inverts winding)
                auto newIndices = srcIndices;
                for (size_t i = 0; i + 2 < newIndices.size(); i += 3) {
                    std::swap(newIndices[i], newIndices[i + 2]);
                }

                if (!srcVerts.empty() && !newIndices.empty()) {
                    uint32_t handle = m_ctx.modelRenderer.createModel(srcVerts, newIndices, nullptr, 0, 0);
                    newObj->setBufferHandle(handle);
                    newObj->setIndexCount(static_cast<uint32_t>(newIndices.size()));
                    newObj->setVertexCount(static_cast<uint32_t>(srcVerts.size()));
                    newObj->setMeshData(srcVerts, newIndices);

                    // Copy and flip EditableMesh data
                    if (srcObj->hasEditableMeshData()) {
                        auto heVerts = srcObj->getHEVertices();
                        for (auto& v : heVerts) {
                            v.position.x = -v.position.x;
                        }
                        newObj->setEditableMeshData(heVerts, srcObj->getHEHalfEdges(), srcObj->getHEFaces());
                    }

                    // Mirror position around world origin
                    auto& srcTransform = srcObj->getTransform();
                    auto& transform = newObj->getTransform();
                    transform.setScale(srcTransform.getScale());
                    transform.setRotation(srcTransform.getRotation());
                    glm::vec3 pos = srcTransform.getPosition();
                    pos.x = -pos.x;
                    transform.setPosition(pos);

                    if (srcObj->hasTextureData()) {
                        const auto& texData = srcObj->getTextureData();
                        newObj->setTextureData(texData, srcObj->getTextureWidth(), srcObj->getTextureHeight());
                    }
                }
                m_ctx.sceneObjects.push_back(std::move(newObj));
            }

            ImGui::SameLine();
            if (ImGui::Button("Mirror Y")) {
                if (m_ctx.meshDirty) {
                    updateMeshFromEditable();
                }

                auto& srcObj = m_ctx.selectedObject;
                auto newObj = std::make_unique<SceneObject>(srcObj->getName() + "_mirrorY");

                auto srcVerts = srcObj->getVertices();
                const auto& srcIndices = srcObj->getIndices();

                for (auto& v : srcVerts) {
                    v.position.y = -v.position.y;
                    v.normal.y = -v.normal.y;
                }

                // Reverse triangle winding order (mirroring inverts winding)
                auto newIndices = srcIndices;
                for (size_t i = 0; i + 2 < newIndices.size(); i += 3) {
                    std::swap(newIndices[i], newIndices[i + 2]);
                }

                if (!srcVerts.empty() && !newIndices.empty()) {
                    uint32_t handle = m_ctx.modelRenderer.createModel(srcVerts, newIndices, nullptr, 0, 0);
                    newObj->setBufferHandle(handle);
                    newObj->setIndexCount(static_cast<uint32_t>(newIndices.size()));
                    newObj->setVertexCount(static_cast<uint32_t>(srcVerts.size()));
                    newObj->setMeshData(srcVerts, newIndices);

                    if (srcObj->hasEditableMeshData()) {
                        auto heVerts = srcObj->getHEVertices();
                        for (auto& v : heVerts) {
                            v.position.y = -v.position.y;
                        }
                        newObj->setEditableMeshData(heVerts, srcObj->getHEHalfEdges(), srcObj->getHEFaces());
                    }

                    auto& srcTransform = srcObj->getTransform();
                    auto& transform = newObj->getTransform();
                    transform.setScale(srcTransform.getScale());
                    transform.setRotation(srcTransform.getRotation());
                    glm::vec3 pos = srcTransform.getPosition();
                    pos.y = -pos.y;
                    transform.setPosition(pos);

                    if (srcObj->hasTextureData()) {
                        const auto& texData = srcObj->getTextureData();
                        newObj->setTextureData(texData, srcObj->getTextureWidth(), srcObj->getTextureHeight());
                    }
                }
                m_ctx.sceneObjects.push_back(std::move(newObj));
            }

            ImGui::SameLine();
            if (ImGui::Button("Mirror Z")) {
                if (m_ctx.meshDirty) {
                    updateMeshFromEditable();
                }

                auto& srcObj = m_ctx.selectedObject;
                auto newObj = std::make_unique<SceneObject>(srcObj->getName() + "_mirrorZ");

                auto srcVerts = srcObj->getVertices();
                const auto& srcIndices = srcObj->getIndices();

                for (auto& v : srcVerts) {
                    v.position.z = -v.position.z;
                    v.normal.z = -v.normal.z;
                }

                // Reverse triangle winding order (mirroring inverts winding)
                auto newIndices = srcIndices;
                for (size_t i = 0; i + 2 < newIndices.size(); i += 3) {
                    std::swap(newIndices[i], newIndices[i + 2]);
                }

                if (!srcVerts.empty() && !newIndices.empty()) {
                    uint32_t handle = m_ctx.modelRenderer.createModel(srcVerts, newIndices, nullptr, 0, 0);
                    newObj->setBufferHandle(handle);
                    newObj->setIndexCount(static_cast<uint32_t>(newIndices.size()));
                    newObj->setVertexCount(static_cast<uint32_t>(srcVerts.size()));
                    newObj->setMeshData(srcVerts, newIndices);

                    if (srcObj->hasEditableMeshData()) {
                        auto heVerts = srcObj->getHEVertices();
                        for (auto& v : heVerts) {
                            v.position.z = -v.position.z;
                        }
                        newObj->setEditableMeshData(heVerts, srcObj->getHEHalfEdges(), srcObj->getHEFaces());
                    }

                    auto& srcTransform = srcObj->getTransform();
                    auto& transform = newObj->getTransform();
                    transform.setScale(srcTransform.getScale());
                    transform.setRotation(srcTransform.getRotation());
                    glm::vec3 pos = srcTransform.getPosition();
                    pos.z = -pos.z;
                    transform.setPosition(pos);

                    if (srcObj->hasTextureData()) {
                        const auto& texData = srcObj->getTextureData();
                        newObj->setTextureData(texData, srcObj->getTextureWidth(), srcObj->getTextureHeight());
                    }
                }
                m_ctx.sceneObjects.push_back(std::move(newObj));
            }

            ImGui::SameLine();
            if (ImGui::Button("Delete")) {
                // Queue object for deferred deletion (processed at start of next frame)
                m_ctx.pendingDeletions.push_back(m_ctx.selectedObject);

                // Reset gizmo state
                m_ctx.gizmoDragging = false;
                m_ctx.gizmoActiveAxis = GizmoAxis::None;
                m_ctx.gizmoHoveredAxis = GizmoAxis::None;

                // Clear selection and mesh state immediately
                m_ctx.selectedObject = nullptr;
                m_ctx.editableMesh.clear();
                m_ctx.meshDirty = false;
            }
        }

        // Snap tool - requires at least 2 objects
        if (m_ctx.sceneObjects.size() >= 2) {
            if (m_snapVertexMode) {
                // Vertex selection mode for Snap & Merge
                ImGui::TextColored(ImVec4(1.0f, 0.3f, 0.3f, 1.0f), "SNAP & MERGE - VERTEX MODE");
                ImGui::Separator();

                // Show current state
                if (m_snapSrcObj && m_snapDstObj) {
                    ImGui::Text("Source: %s (%zu verts)", m_snapSrcObj->getName().c_str(), m_snapSrcVerts.size());
                    ImGui::Text("Target: %s (%zu verts)", m_snapDstObj->getName().c_str(), m_snapDstVerts.size());
                } else if (m_snapSrcObj) {
                    ImGui::Text("Source: %s (%zu verts)", m_snapSrcObj->getName().c_str(), m_snapSrcVerts.size());
                    ImGui::Text("Target: (click target object)");
                } else {
                    ImGui::Text("Click vertices on SOURCE object");
                    ImGui::Text("(in order around the face)");
                }

                ImGui::Spacing();
                if (!m_snapSrcVerts.empty() || !m_snapDstVerts.empty()) {
                    ImGui::Text("Source verts: %zu", m_snapSrcVerts.size());
                    ImGui::Text("Target verts: %zu", m_snapDstVerts.size());
                }

                // Confirm button (only if we have matching vertices)
                bool canMerge = !m_snapSrcVerts.empty() &&
                               m_snapSrcVerts.size() == m_snapDstVerts.size() &&
                               m_snapSrcObj && m_snapDstObj;
                if (canMerge) {
                    ImGui::Spacing();
                    if (ImGui::Button("Confirm Merge")) {
                        snapAndMergeWithVertexCorrespondence();
                        cancelSnapVertexMode();
                    }
                }

                ImGui::Spacing();
                if (ImGui::Button("Clear Source Verts")) {
                    m_snapSrcVerts.clear();
                    m_snapSrcVertIndices.clear();
                    m_snapSrcObj = nullptr;
                }
                ImGui::SameLine();
                if (ImGui::Button("Clear Target Verts")) {
                    m_snapDstVerts.clear();
                    m_snapDstVertIndices.clear();
                    m_snapDstObj = nullptr;
                }

                if (ImGui::Button("Cancel (ESC)")) {
                    cancelSnapVertexMode();
                }
            } else if (m_snapMode) {
                if (m_snapMergeMode) {
                    ImGui::TextColored(ImVec4(1.0f, 0.3f, 0.3f, 1.0f), "SNAP & MERGE MODE");
                } else {
                    ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "SNAP MODE");
                }
                if (m_snapSourceFace == -1) {
                    ImGui::Text("Select source face...");
                } else {
                    ImGui::Text("Select target face...");
                }
                if (ImGui::Button("Cancel (ESC)")) {
                    cancelSnapMode();
                }
            } else {
                if (ImGui::Button("Snap Faces")) {
                    m_snapMode = true;
                    m_snapMergeMode = false;
                    m_snapSourceObject = nullptr;
                    m_snapSourceFace = -1;
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Snap one object's face to another (keeps separate)");
                }
                ImGui::SameLine();
                if (ImGui::Button("Snap & Merge")) {
                    // Enter vertex selection mode
                    m_snapVertexMode = true;
                    m_snapSrcObj = nullptr;
                    m_snapDstObj = nullptr;
                    m_snapSrcVerts.clear();
                    m_snapDstVerts.clear();
                    m_snapSrcVertIndices.clear();
                    m_snapDstVertIndices.clear();
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Click vertices in order on source, then target object");
                }
            }
        }

        // Vertex color for solid-colored objects
        if (m_ctx.selectedObject && m_ctx.selectedObject->hasMeshData()) {
            ImGui::TextColored(ImVec4(1, 1, 0, 1), "Vertex Color");
            ImGui::Separator();

            static glm::vec3 solidColor(0.7f, 0.7f, 0.7f);
            ImGui::ColorEdit3("Color", &solidColor.x);

            if (ImGui::Button("Apply to Object")) {
                // Sync current edits first
                if (m_ctx.meshDirty) {
                    updateMeshFromEditable();
                }

                // Get current mesh data
                auto verts = m_ctx.selectedObject->getVertices();  // Copy
                const auto& indices = m_ctx.selectedObject->getIndices();

                // Apply color to all vertices
                for (auto& v : verts) {
                    v.color = glm::vec4(solidColor, 1.0f);
                }

                // Update GPU mesh
                uint32_t oldHandle = m_ctx.selectedObject->getBufferHandle();
                uint32_t newHandle = m_ctx.modelRenderer.createModel(verts, indices, nullptr, 0, 0);
                m_ctx.selectedObject->setBufferHandle(newHandle);
                m_ctx.selectedObject->setMeshData(verts, indices);

                // Update editable mesh vertex colors too
                if (m_ctx.editableMesh.isValid()) {
                    for (size_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                        m_ctx.editableMesh.getVertex(i).color = glm::vec4(solidColor, 1.0f);
                    }
                }

                std::cout << "[Color] Applied solid color (" << solidColor.r << ", "
                          << solidColor.g << ", " << solidColor.b << ") to "
                          << verts.size() << " vertices" << std::endl;
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Set all vertices to this solid color.\nUseful for detail pieces before combining.");
            }
            ImGui::Spacing();
        }

        // Combine selected objects button
        if (m_ctx.selectedObjects.size() >= 2) {
            if (ImGui::Button("Combine Selected")) {
                // Sync current edits before combining
                if (m_ctx.meshDirty && m_ctx.selectedObject) {
                    updateMeshFromEditable();
                }

                // Merge selected objects into one
                std::vector<ModelVertex> combinedVerts;
                std::vector<uint32_t> combinedIndices;

                // Also combine half-edge data to preserve quad topology
                std::vector<SceneObject::StoredHEVertex> combinedHEVerts;
                std::vector<SceneObject::StoredHalfEdge> combinedHE;
                std::vector<SceneObject::StoredHEFace> combinedHEFaces;
                bool allHaveHEData = true;

                for (auto& obj : m_ctx.sceneObjects) {
                    if (m_ctx.selectedObjects.count(obj.get()) == 0) continue;
                    if (!obj->hasMeshData()) continue;

                    const auto& verts = obj->getVertices();
                    const auto& indices = obj->getIndices();
                    const auto& transform = obj->getTransform();
                    glm::mat4 modelMatrix = transform.getMatrix();
                    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));

                    uint32_t indexOffset = static_cast<uint32_t>(combinedVerts.size());

                    for (const auto& v : verts) {
                        ModelVertex newVert = v;
                        glm::vec4 worldPos = modelMatrix * glm::vec4(v.position, 1.0f);
                        newVert.position = glm::vec3(worldPos);
                        newVert.normal = glm::normalize(normalMatrix * v.normal);
                        combinedVerts.push_back(newVert);
                    }

                    for (uint32_t idx : indices) {
                        combinedIndices.push_back(idx + indexOffset);
                    }

                    // Combine half-edge data if available
                    if (obj->hasEditableMeshData()) {
                        uint32_t heVertOffset = static_cast<uint32_t>(combinedHEVerts.size());
                        uint32_t heOffset = static_cast<uint32_t>(combinedHE.size());
                        uint32_t heFaceOffset = static_cast<uint32_t>(combinedHEFaces.size());

                        for (const auto& v : obj->getHEVertices()) {
                            SceneObject::StoredHEVertex newV = v;
                            glm::vec4 worldPos = modelMatrix * glm::vec4(v.position, 1.0f);
                            newV.position = glm::vec3(worldPos);
                            newV.normal = glm::normalize(normalMatrix * v.normal);
                            if (newV.halfEdgeIndex != UINT32_MAX) newV.halfEdgeIndex += heOffset;
                            combinedHEVerts.push_back(newV);
                        }

                        for (const auto& he : obj->getHEHalfEdges()) {
                            SceneObject::StoredHalfEdge newHE = he;
                            if (newHE.vertexIndex != UINT32_MAX) newHE.vertexIndex += heVertOffset;
                            if (newHE.faceIndex != UINT32_MAX) newHE.faceIndex += heFaceOffset;
                            if (newHE.nextIndex != UINT32_MAX) newHE.nextIndex += heOffset;
                            if (newHE.prevIndex != UINT32_MAX) newHE.prevIndex += heOffset;
                            if (newHE.twinIndex != UINT32_MAX) newHE.twinIndex += heOffset;
                            combinedHE.push_back(newHE);
                        }

                        for (const auto& f : obj->getHEFaces()) {
                            SceneObject::StoredHEFace newF = f;
                            if (newF.halfEdgeIndex != UINT32_MAX) newF.halfEdgeIndex += heOffset;
                            combinedHEFaces.push_back(newF);
                        }
                    } else {
                        allHaveHEData = false;
                    }
                }

                if (!combinedVerts.empty()) {
                    auto combinedObj = std::make_unique<SceneObject>("Combined");
                    uint32_t handle = m_ctx.modelRenderer.createModel(combinedVerts, combinedIndices, nullptr, 0, 0);
                    combinedObj->setBufferHandle(handle);
                    combinedObj->setIndexCount(static_cast<uint32_t>(combinedIndices.size()));
                    combinedObj->setVertexCount(static_cast<uint32_t>(combinedVerts.size()));
                    combinedObj->setMeshData(combinedVerts, combinedIndices);

                    // Store combined half-edge data if all sources had it
                    if (allHaveHEData && !combinedHEVerts.empty()) {
                        combinedObj->setEditableMeshData(combinedHEVerts, combinedHE, combinedHEFaces);
                    }

                    // Queue selected objects for deletion
                    for (SceneObject* obj : m_ctx.selectedObjects) {
                        m_ctx.pendingDeletions.push_back(obj);
                    }

                    // Clear selection
                    m_ctx.selectedObject = nullptr;
                    m_ctx.selectedObjects.clear();
                    m_ctx.editableMesh.clear();
                    m_ctx.meshDirty = false;

                    m_ctx.sceneObjects.push_back(std::move(combinedObj));

                    std::cout << "[Combine Selected] Created combined mesh with " << combinedVerts.size()
                              << " vertices, " << combinedIndices.size() / 3 << " triangles" << std::endl;
                }
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Merge selected objects into one combined mesh.\nCtrl+Click or Shift+Click to multi-select in list.");
            }
            ImGui::SameLine();
        }

        // Combine all objects button
        if (m_ctx.sceneObjects.size() >= 2) {
            if (ImGui::Button("Combine All")) {
                // Sync current edits before combining
                if (m_ctx.meshDirty && m_ctx.selectedObject) {
                    updateMeshFromEditable();
                }

                // Merge all objects into one
                std::vector<ModelVertex> combinedVerts;
                std::vector<uint32_t> combinedIndices;

                // Also combine half-edge data to preserve quad topology
                std::vector<SceneObject::StoredHEVertex> combinedHEVerts;
                std::vector<SceneObject::StoredHalfEdge> combinedHE;
                std::vector<SceneObject::StoredHEFace> combinedHEFaces;
                bool allHaveHEData = true;

                for (auto& obj : m_ctx.sceneObjects) {
                    if (!obj->hasMeshData()) continue;

                    const auto& verts = obj->getVertices();
                    const auto& indices = obj->getIndices();
                    const auto& transform = obj->getTransform();
                    glm::mat4 modelMatrix = transform.getMatrix();
                    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));

                    uint32_t indexOffset = static_cast<uint32_t>(combinedVerts.size());

                    // Add vertices with transform applied
                    for (const auto& v : verts) {
                        ModelVertex newVert = v;
                        glm::vec4 worldPos = modelMatrix * glm::vec4(v.position, 1.0f);
                        newVert.position = glm::vec3(worldPos);
                        newVert.normal = glm::normalize(normalMatrix * v.normal);
                        // UVs preserved as-is
                        combinedVerts.push_back(newVert);
                    }

                    // Add indices with offset
                    for (uint32_t idx : indices) {
                        combinedIndices.push_back(idx + indexOffset);
                    }

                    // Combine half-edge data if available
                    if (obj->hasEditableMeshData()) {
                        uint32_t heVertOffset = static_cast<uint32_t>(combinedHEVerts.size());
                        uint32_t heOffset = static_cast<uint32_t>(combinedHE.size());
                        uint32_t heFaceOffset = static_cast<uint32_t>(combinedHEFaces.size());

                        for (const auto& v : obj->getHEVertices()) {
                            SceneObject::StoredHEVertex newV = v;
                            glm::vec4 worldPos = modelMatrix * glm::vec4(v.position, 1.0f);
                            newV.position = glm::vec3(worldPos);
                            newV.normal = glm::normalize(normalMatrix * v.normal);
                            if (newV.halfEdgeIndex != UINT32_MAX) newV.halfEdgeIndex += heOffset;
                            combinedHEVerts.push_back(newV);
                        }

                        for (const auto& he : obj->getHEHalfEdges()) {
                            SceneObject::StoredHalfEdge newHE = he;
                            if (newHE.vertexIndex != UINT32_MAX) newHE.vertexIndex += heVertOffset;
                            if (newHE.faceIndex != UINT32_MAX) newHE.faceIndex += heFaceOffset;
                            if (newHE.nextIndex != UINT32_MAX) newHE.nextIndex += heOffset;
                            if (newHE.prevIndex != UINT32_MAX) newHE.prevIndex += heOffset;
                            if (newHE.twinIndex != UINT32_MAX) newHE.twinIndex += heOffset;
                            combinedHE.push_back(newHE);
                        }

                        for (const auto& f : obj->getHEFaces()) {
                            SceneObject::StoredHEFace newF = f;
                            if (newF.halfEdgeIndex != UINT32_MAX) newF.halfEdgeIndex += heOffset;
                            combinedHEFaces.push_back(newF);
                        }
                    } else {
                        allHaveHEData = false;
                    }
                }

                if (!combinedVerts.empty()) {
                    // Create new combined object
                    auto combinedObj = std::make_unique<SceneObject>("Combined");
                    uint32_t handle = m_ctx.modelRenderer.createModel(combinedVerts, combinedIndices, nullptr, 0, 0);
                    combinedObj->setBufferHandle(handle);
                    combinedObj->setIndexCount(static_cast<uint32_t>(combinedIndices.size()));
                    combinedObj->setVertexCount(static_cast<uint32_t>(combinedVerts.size()));
                    combinedObj->setMeshData(combinedVerts, combinedIndices);

                    // Store combined half-edge data if all sources had it
                    if (allHaveHEData && !combinedHEVerts.empty()) {
                        combinedObj->setEditableMeshData(combinedHEVerts, combinedHE, combinedHEFaces);
                    }

                    // Queue all existing objects for deletion
                    for (auto& obj : m_ctx.sceneObjects) {
                        m_ctx.pendingDeletions.push_back(obj.get());
                    }

                    // Clear selection
                    m_ctx.selectedObject = nullptr;
                    m_ctx.selectedObjects.clear();
                    m_ctx.editableMesh.clear();
                    m_ctx.meshDirty = false;

                    // Add combined object
                    m_ctx.sceneObjects.push_back(std::move(combinedObj));

                    std::cout << "[Combine] Created combined mesh with " << combinedVerts.size()
                              << " vertices, " << combinedIndices.size() / 3 << " triangles" << std::endl;
                }
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Merge all objects into one combined mesh.\nTransforms are baked in, UVs preserved.");
            }
        }

        ImGui::Spacing();

        // Transform controls for selected object
        if (m_ctx.selectedObject) {
            ImGui::TextColored(ImVec4(1, 1, 0, 1), "Transform");
            ImGui::Separator();

            auto& transform = m_ctx.selectedObject->getTransform();
            glm::vec3 pos = transform.getPosition();
            glm::vec3 rot = glm::degrees(glm::eulerAngles(transform.getRotation()));
            glm::vec3 scale = transform.getScale();

            // Position - directly editable input fields
            ImGui::Text("Position");
            ImGui::PushItemWidth(-1);
            if (ImGui::InputFloat3("##pos", &pos.x, "%.3f", ImGuiInputTextFlags_EnterReturnsTrue)) {
                transform.setPosition(pos);
            }
            ImGui::PopItemWidth();

            // Rotation - directly editable input fields
            ImGui::Text("Rotation");
            ImGui::PushItemWidth(-1);
            if (ImGui::InputFloat3("##rot", &rot.x, "%.1f", ImGuiInputTextFlags_EnterReturnsTrue)) {
                transform.setRotation(rot);
            }
            ImGui::PopItemWidth();

            // Scale - directly editable input fields
            ImGui::Text("Scale");
            ImGui::PushItemWidth(-1);
            if (ImGui::InputFloat3("##scale", &scale.x, "%.3f", ImGuiInputTextFlags_EnterReturnsTrue)) {
                transform.setScale(scale);
            }
            ImGui::PopItemWidth();

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.7f, 0.9f, 1.0f, 1), "Snap Settings");
            ImGui::Separator();

            ImGui::Checkbox("Enable Snap", &m_ctx.snapEnabled);

            if (m_ctx.snapEnabled) {
                ImGui::PushItemWidth(80);
                ImGui::InputFloat("Move", &m_ctx.moveSnapIncrement, 0.0f, 0.0f, "%.2f");
                if (m_ctx.moveSnapIncrement < 0.01f) m_ctx.moveSnapIncrement = 0.01f;

                ImGui::InputFloat("Rotate", &m_ctx.rotateSnapIncrement, 0.0f, 0.0f, "%.0f");
                if (m_ctx.rotateSnapIncrement < 1.0f) m_ctx.rotateSnapIncrement = 1.0f;
                ImGui::PopItemWidth();

                // Quick preset buttons for rotation
                ImGui::SameLine();
                if (ImGui::SmallButton("15")) m_ctx.rotateSnapIncrement = 15.0f;
                ImGui::SameLine();
                if (ImGui::SmallButton("45")) m_ctx.rotateSnapIncrement = 45.0f;
                ImGui::SameLine();
                if (ImGui::SmallButton("90")) m_ctx.rotateSnapIncrement = 90.0f;
            }
        }
    }
    ImGui::End();
    }

    // Tools window
    ImGui::SetNextWindowPos(ImVec2(0, 380), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(250, 400), ImGuiCond_FirstUseEver);

    if (m_ctx.showToolsWindow) {
    if (ImGui::Begin("Tools", &m_ctx.showToolsWindow)) {
        // Selection mode section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.0f, 0.15f, 0.15f, 0.5f));
        ImGui::BeginChild("SelectionSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(0.3f, 0.9f, 0.9f, 1), "Selection Mode");
        ImGui::Separator();

        if (ImGui::RadioButton("Vertex (A)", m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex)) {
            m_ctx.modelingSelectionMode = ModelingSelectionMode::Vertex;
            m_ctx.editableMesh.clearSelection();
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Edge (S)", m_ctx.modelingSelectionMode == ModelingSelectionMode::Edge)) {
            m_ctx.modelingSelectionMode = ModelingSelectionMode::Edge;
            m_ctx.editableMesh.clearSelection();
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Face (D)", m_ctx.modelingSelectionMode == ModelingSelectionMode::Face)) {
            m_ctx.modelingSelectionMode = ModelingSelectionMode::Face;
            m_ctx.editableMesh.clearSelection();
        }

        // Selection tool
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 1.0f, 1.0f), "Selection Tool:");
        if (ImGui::RadioButton("Normal", m_ctx.selectionTool == SelectionTool::Normal)) {
            m_ctx.selectionTool = SelectionTool::Normal;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Click to select, drag for rectangle select");
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Paint (C)", m_ctx.selectionTool == SelectionTool::Paint)) {
            m_ctx.selectionTool = SelectionTool::Paint;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Paint to select elements under cursor");
        }

        if (m_ctx.selectionTool == SelectionTool::Paint) {
            ImGui::SliderFloat("Brush Radius", &m_ctx.paintSelectRadius, 5.0f, 100.0f, "%.0f px");
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Transform / Gizmo section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.12f, 0.0f, 0.5f));
        ImGui::BeginChild("TransformSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(1.0f, 0.85f, 0.3f, 1), "Transform");
        ImGui::Separator();

        // Gizmo mode toggle
        bool selectActive = (m_ctx.gizmoMode == GizmoMode::None);
        if (ImGui::Checkbox("Select (Q)", &selectActive)) {
            m_ctx.gizmoMode = GizmoMode::None;
        }
        ImGui::SameLine();
        bool moveActive = (m_ctx.gizmoMode == GizmoMode::Move);
        if (ImGui::Checkbox("Move (W)", &moveActive)) {
            m_ctx.gizmoMode = GizmoMode::Move;
        }
        ImGui::SameLine();
        bool rotateActive = (m_ctx.gizmoMode == GizmoMode::Rotate);
        if (ImGui::Checkbox("Rotate (E)", &rotateActive)) {
            m_ctx.gizmoMode = GizmoMode::Rotate;
        }
        ImGui::SameLine();
        bool scaleActive = (m_ctx.gizmoMode == GizmoMode::Scale);
        if (ImGui::Checkbox("Scale (R)", &scaleActive)) {
            m_ctx.gizmoMode = GizmoMode::Scale;
        }

        if (m_ctx.gizmoMode != GizmoMode::None) {
            ImGui::SliderFloat("Gizmo Size", &m_ctx.gizmoSize, 0.5f, 3.0f, "%.1f");
            ImGui::SliderFloat3("Gizmo Offset", &m_ctx.gizmoOffset.x, -2.0f, 2.0f, "%.2f");
            if (m_ctx.gizmoMode == GizmoMode::Move) {
                ImGui::Checkbox("Local Space (Face Normal)", &m_ctx.gizmoLocalSpace);
            }
            // Reset custom gizmo pivot (shown when pivot is overridden, e.g. after snap)
            if (m_useCustomGizmoPivot) {
                if (ImGui::Button("Reset Gizmo")) {
                    m_useCustomGizmoPivot = false;
                }
                if (ImGui::IsItemHovered()) {
                    ImGui::SetTooltip("Reset gizmo to object center");
                }
            }
        }

        // Numeric translation input
        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
        bool hasVertSelection = !selectedVerts.empty();

        if (hasVertSelection) {
            ImGui::Spacing();
            ImGui::Text("Move Selection:");

            static glm::vec3 translateAmount(0.0f);

            ImGui::PushItemWidth(60);
            bool changed = false;

            ImGui::TextColored(ImVec4(1, 0.3f, 0.3f, 1), "X:");
            ImGui::SameLine();
            if (ImGui::DragFloat("##tx", &translateAmount.x, 0.01f, -100.0f, 100.0f, "%.3f")) {
                changed = true;
            }
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 1, 0.3f, 1), "Y:");
            ImGui::SameLine();
            if (ImGui::DragFloat("##ty", &translateAmount.y, 0.01f, -100.0f, 100.0f, "%.3f")) {
                changed = true;
            }
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 0.3f, 1, 1), "Z:");
            ImGui::SameLine();
            if (ImGui::DragFloat("##tz", &translateAmount.z, 0.01f, -100.0f, 100.0f, "%.3f")) {
                changed = true;
            }

            ImGui::PopItemWidth();

            if (changed && m_ctx.selectedObject) {
                // Apply translation using position-matched vertex movement
                m_ctx.editableMesh.saveState();
                glm::mat4 invModel = glm::inverse(m_ctx.selectedObject->getTransform().getMatrix());
                glm::vec3 localDelta = glm::vec3(invModel * glm::vec4(translateAmount, 0.0f));
                m_ctx.editableMesh.translateSelectedVertices(localDelta);
                m_ctx.meshDirty = true;
                translateAmount = glm::vec3(0.0f);  // Reset after applying
            }

            // Quick translate buttons (use translateSelectedVertices for position-matched movement)
            ImGui::PushItemWidth(40);
            if (ImGui::Button("+X")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(0.1f, 0, 0));
                m_ctx.meshDirty = true;
            }
            ImGui::SameLine();
            if (ImGui::Button("-X")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(-0.1f, 0, 0));
                m_ctx.meshDirty = true;
            }
            ImGui::SameLine();
            if (ImGui::Button("+Y")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(0, 0.1f, 0));
                m_ctx.meshDirty = true;
            }
            ImGui::SameLine();
            if (ImGui::Button("-Y")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(0, -0.1f, 0));
                m_ctx.meshDirty = true;
            }
            ImGui::SameLine();
            if (ImGui::Button("+Z")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(0, 0, 0.1f));
                m_ctx.meshDirty = true;
            }
            ImGui::SameLine();
            if (ImGui::Button("-Z")) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.translateSelectedVertices(glm::vec3(0, 0, -0.1f));
                m_ctx.meshDirty = true;
            }
            ImGui::PopItemWidth();
        } else {
            ImGui::TextDisabled("Select vertices to transform");
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Operations section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.08f, 0.0f, 0.5f));
        ImGui::BeginChild("OperationsSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(1.0f, 0.6f, 0.3f, 1), "Operations");
        ImGui::Separator();

        bool hasSelection = !m_ctx.editableMesh.getSelectedFaces().empty() ||
                           !m_ctx.editableMesh.getSelectedEdges().empty() ||
                           !selectedVerts.empty();

        if (!hasSelection) ImGui::BeginDisabled();

        if (ImGui::Button("Extrude (Shift+E)")) {
            if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.extrudeSelectedFaces(m_ctx.extrudeDistance);
                m_ctx.meshDirty = true;  // Defer GPU update to next frame
            }
        }
        ImGui::SameLine();
        ImGui::SliderFloat("##dist", &m_ctx.extrudeDistance, 0.1f, 2.0f, "%.2f");

        if (ImGui::Button("Delete (X/Del)")) {
            if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.deleteSelectedFaces();
                m_ctx.meshDirty = true;
            }
        }

        if (ImGui::Button("Flip Normals (N)")) {
            if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.flipSelectedNormals();
                m_ctx.meshDirty = true;
            }
        }

        if (ImGui::Button("Inset (I)")) {
            if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.insetSelectedFaces(m_ctx.insetAmount);
                m_ctx.meshDirty = true;
            }
        }
        ImGui::SameLine();
        ImGui::SliderFloat("##inset", &m_ctx.insetAmount, 0.05f, 0.95f, "%.2f");

        if (!hasSelection) ImGui::EndDisabled();

        // Edge-specific operations
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        bool hasEdgeSelection = !selectedEdges.empty();

        if (!hasEdgeSelection) ImGui::BeginDisabled();

        static int edgeLoopCount = 1;
        ImGui::SliderInt("Loop Count", &edgeLoopCount, 1, 10);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Number of edge loops to insert.\n1 = split in half\n2 = split into thirds\netc.");
        }

        if (ImGui::Button("Insert Edge Loop (Ctrl+R)")) {
            if (!selectedEdges.empty()) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.insertEdgeLoop(selectedEdges[0], edgeLoopCount);
                m_ctx.meshDirty = true;
            }
        }

        ImGui::SliderInt("Bridge Segments", &g_bridgeSegments, 1, 10);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Number of face rows in the bridge");
        }

        if (selectedEdges.size() != 2) ImGui::BeginDisabled();
        if (ImGui::Button("Bridge Edges (B)")) {
            if (selectedEdges.size() == 2) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.bridgeEdges(selectedEdges[0], selectedEdges[1], g_bridgeSegments);
                m_ctx.meshDirty = true;
            }
        }
        if (selectedEdges.size() != 2) ImGui::EndDisabled();

        // Edge path extrusion - create box tube along selected edges
        ImGui::Separator();
        ImGui::Text("Edge Path Extrusion:");
        static float edgePathBoxSize = 0.1f;
        static float edgePathTaper = 1.0f;  // 1.0 = no taper, 0.0 = taper to point
        static bool edgePathAutoUV = true;  // Auto-generate cylindrical UVs
        ImGui::SliderFloat("Box Size", &edgePathBoxSize, 0.01f, 1.0f, "%.3f");
        ImGui::SliderFloat("Taper", &edgePathTaper, 0.0f, 1.0f, "%.2f");
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("1.0 = uniform size\n0.0 = taper to point\n0.5 = end is half the start size");
        }
        ImGui::Checkbox("Auto UV", &edgePathAutoUV);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Generate cylindrical UVs:\nU = around tube (0-1)\nV = along path (0-1)");
        }

        if (ImGui::Button("Extrude Box Along Path")) {
            extrudeBoxAlongSelectedEdges(edgePathBoxSize, edgePathTaper, edgePathAutoUV);
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Select connected edges to form a path,\nthen create a box tube along that path");
        }

        // Pipe Network extrusion (tubes pass through at junctions)
        ImGui::Spacing();
        ImGui::Text("Pipe Network:");
        static float pipeBoxSize = 0.1f;  // Tube cross-section size
        ImGui::SliderFloat("Pipe Size##pipe", &pipeBoxSize, 0.01f, 1.0f, "%.3f");
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Tube cross-section size");
        }

        if (ImGui::Button("Extrude Pipe Network")) {
            extrudePipeNetwork(pipeBoxSize, 1.0f, edgePathAutoUV);
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Create pipe network from selected edges.\nTubes pass through each other at junctions.\nUses mesh color from Display Options.");
        }
        ImGui::Separator();

        if (!hasEdgeSelection) ImGui::EndDisabled();

        // Vertex-specific operations
        // (selectedVerts already declared above in Transform section)
        if (selectedVerts.size() < 2) ImGui::BeginDisabled();
        if (ImGui::Button("Merge Vertices (Alt+M)")) {
            if (selectedVerts.size() >= 2) {
                m_ctx.editableMesh.saveState();
                m_ctx.editableMesh.mergeSelectedVertices();
                m_ctx.meshDirty = true;
            }
        }
        if (selectedVerts.size() < 2) ImGui::EndDisabled();

        // Measurement display (when exactly 2 vertices selected)
        if (selectedVerts.size() == 2 && m_ctx.selectedObject) {
            auto it = selectedVerts.begin();
            uint32_t v1 = *it++;
            uint32_t v2 = *it;
            const auto& vert1 = m_ctx.editableMesh.getVertex(v1);
            const auto& vert2 = m_ctx.editableMesh.getVertex(v2);

            // Apply object transform to get world-space positions
            glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
            glm::vec3 worldPos1 = glm::vec3(modelMatrix * glm::vec4(vert1.position, 1.0f));
            glm::vec3 worldPos2 = glm::vec3(modelMatrix * glm::vec4(vert2.position, 1.0f));

            glm::vec3 delta = worldPos2 - worldPos1;
            float distance = glm::length(delta);

            ImGui::Spacing();
            ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "Measure (2 verts)");
            ImGui::Separator();

            // Total distance in multiple units
            float distanceCm = distance * 100.0f;
            float distanceFeet = distance * 3.28084f;
            float distanceInches = distance * 39.3701f;

            ImGui::Text("Total: %.3f m", distance);
            ImGui::Text("       %.1f cm  |  %.2f ft  |  %.1f in", distanceCm, distanceFeet, distanceInches);

            // X/Y/Z deltas
            ImGui::Spacing();
            ImGui::TextDisabled("Deltas:");
            ImGui::Text("  X: %+.3f m (%+.1f cm)", delta.x, delta.x * 100.0f);
            ImGui::Text("  Y: %+.3f m (%+.1f cm)", delta.y, delta.y * 100.0f);
            ImGui::Text("  Z: %+.3f m (%+.1f cm)", delta.z, delta.z * 100.0f);
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Mesh-wide Operations section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.05f, 0.0f, 0.5f));
        ImGui::BeginChild("MeshOpsSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(1, 0.5f, 0, 1), "Mesh Operations");
        ImGui::Separator();

        if (ImGui::Button("Hollow (H)")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.hollow(m_ctx.hollowThickness);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Create interior walls with inward-facing normals.\nUseful for buildings and hollow objects.");
        }
        ImGui::SameLine();
        ImGui::SliderFloat("##hollow", &m_ctx.hollowThickness, 0.01f, 1.0f, "%.3f");

        // Boolean Cut - use another object as a cutter
        ImGui::Spacing();
        ImGui::Text("Boolean Cut:");

        // Find potential cutter objects (any object that isn't selected)
        static int cutterObjectIndex = -1;
        std::vector<std::pair<int, std::string>> cutterOptions;
        for (size_t i = 0; i < m_ctx.sceneObjects.size(); ++i) {
            if (m_ctx.sceneObjects[i].get() != m_ctx.selectedObject) {
                cutterOptions.push_back({static_cast<int>(i), m_ctx.sceneObjects[i]->getName()});
            }
        }

        if (cutterOptions.empty()) {
            ImGui::TextDisabled("Add another object as cutter");
        } else {
            // Combo to select cutter
            std::string currentCutter = (cutterObjectIndex >= 0 && cutterObjectIndex < static_cast<int>(m_ctx.sceneObjects.size()))
                ? m_ctx.sceneObjects[cutterObjectIndex]->getName() : "Select cutter...";

            if (ImGui::BeginCombo("Cutter", currentCutter.c_str())) {
                for (const auto& [idx, name] : cutterOptions) {
                    bool selected = (cutterObjectIndex == idx);
                    if (ImGui::Selectable(name.c_str(), selected)) {
                        cutterObjectIndex = idx;
                    }
                }
                ImGui::EndCombo();
            }

            bool hasCutter = cutterObjectIndex >= 0 && cutterObjectIndex < static_cast<int>(m_ctx.sceneObjects.size())
                && m_ctx.sceneObjects[cutterObjectIndex].get() != m_ctx.selectedObject;

            if (!hasCutter) ImGui::BeginDisabled();
            if (ImGui::Button("Cut Boolean")) {
                if (hasCutter && m_ctx.selectedObject) {
                    m_ctx.editableMesh.saveState();

                    // Get cutter object's world-space bounding box
                    SceneObject* cutter = m_ctx.sceneObjects[cutterObjectIndex].get();
                    const auto& cutterVerts = cutter->getVertices();
                    glm::mat4 cutterMatrix = cutter->getTransform().getMatrix();

                    // Transform to main mesh's local space
                    glm::mat4 mainInverse = glm::inverse(m_ctx.selectedObject->getTransform().getMatrix());
                    glm::mat4 toLocal = mainInverse * cutterMatrix;

                    glm::vec3 cutterMin(FLT_MAX), cutterMax(-FLT_MAX);
                    for (const auto& v : cutterVerts) {
                        glm::vec3 worldPos = glm::vec3(toLocal * glm::vec4(v.position, 1.0f));
                        cutterMin = glm::min(cutterMin, worldPos);
                        cutterMax = glm::max(cutterMax, worldPos);
                    }

                    m_ctx.editableMesh.booleanCut(cutterMin, cutterMax);
                    m_ctx.meshDirty = true;
                }
            }
            if (!hasCutter) ImGui::EndDisabled();

            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Cut a hole through the selected mesh\nusing the cutter object's bounding box.\nBest for axis-aligned doors/windows.");
            }
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // UV Operations section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.1f, 0.05f, 0.15f, 0.5f));
        ImGui::BeginChild("UVProjectionSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(0.8f, 0.5f, 1.0f, 1), "UV Projection");
        ImGui::Separator();

        // Planar projection from camera view (selected faces only)
        bool hasFaceSelection = !m_ctx.editableMesh.getSelectedFaces().empty();
        if (!hasFaceSelection) ImGui::BeginDisabled();
        if (ImGui::Button("Planar (View)")) {
            m_ctx.editableMesh.saveState();
            // Use active camera (works for both perspective and ortho)
            Camera& cam = m_ctx.getActiveCamera();
            glm::vec3 viewDir = cam.getFront();
            glm::vec3 viewUp = cam.getUp();
            m_ctx.editableMesh.projectSelectedFacesFromView(viewDir, viewUp, m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled)) {
            ImGui::SetTooltip("Project selected faces from current camera view");
        }
        if (!hasFaceSelection) ImGui::EndDisabled();

        // Ortho view planar projections
        if (!hasFaceSelection) ImGui::BeginDisabled();
        ImGui::Text("Planar from:");
        if (ImGui::Button("Front")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(0, 0, -1), glm::vec3(0, 1, 0), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        ImGui::SameLine();
        if (ImGui::Button("Back")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(0, 0, 1), glm::vec3(0, 1, 0), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        ImGui::SameLine();
        if (ImGui::Button("Left")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(1, 0, 0), glm::vec3(0, 1, 0), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        ImGui::SameLine();
        if (ImGui::Button("Right")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(-1, 0, 0), glm::vec3(0, 1, 0), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        if (ImGui::Button("Top")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(0, -1, 0), glm::vec3(0, 0, -1), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        ImGui::SameLine();
        if (ImGui::Button("Bottom")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.projectSelectedFacesFromView(glm::vec3(0, 1, 0), glm::vec3(0, 0, 1), m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        if (!hasFaceSelection) ImGui::EndDisabled();

        ImGui::SameLine();
        if (ImGui::Button("Box")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.boxProjectUVs(m_ctx.uvProjectionScale);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Project all UVs based on face normal (6-sided box)");
        }

        ImGui::SameLine();
        if (ImGui::Button("By Normal")) {
            m_ctx.editableMesh.saveState();
            // Use small tolerance (0.001) to group only faces with nearly identical normals
            // For a box, this creates 6 islands (one per face direction)
            m_ctx.editableMesh.planarProjectByNormal(0.001f, m_ctx.uvIslandMargin);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Group faces by identical normals into separate UV islands");
        }

        // Cylindrical projection
        if (ImGui::Button("Cylindrical")) {
            m_ctx.editableMesh.saveState();
            // Axis hint based on combo selection, usePCA enabled by default
            glm::vec3 axisHint = m_ctx.cylinderAxisHint;
            m_ctx.editableMesh.cylindricalProjectUVs(axisHint, m_ctx.cylinderUsePCA);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Cylindrical UV projection (uses selected faces or all if none selected).\nSeam placed at 'back' of cylinder where theta wraps.");
        }
        ImGui::SameLine();
        ImGui::SetNextItemWidth(60);
        const char* axisItems[] = { "Y", "X", "Z" };
        if (ImGui::Combo("##CylAxis", &m_ctx.cylinderAxisIndex, axisItems, 3)) {
            // Update axis hint based on selection
            switch (m_ctx.cylinderAxisIndex) {
                case 0: m_ctx.cylinderAxisHint = glm::vec3(0, 1, 0); break;
                case 1: m_ctx.cylinderAxisHint = glm::vec3(1, 0, 0); break;
                case 2: m_ctx.cylinderAxisHint = glm::vec3(0, 0, 1); break;
            }
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Cylinder axis hint (PCA will refine if enabled)");
        }
        ImGui::SameLine();
        ImGui::Checkbox("PCA", &m_ctx.cylinderUsePCA);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Use PCA to auto-detect cylinder axis from vertex positions");
        }

        // Per-face projection (each face = own island)
        if (ImGui::Button("Per-Face")) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.perFaceProjectUVs(m_ctx.uvIslandMargin);
            m_ctx.meshDirty = true;
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Each face becomes its own UV island, packed in a grid.\nIdeal for manual sewing workflow.");
        }

        ImGui::SameLine();
        {
            // Check if we have selected faces
            auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
            bool hasSelection = !selectedFaces.empty();

            std::string buttonLabel = hasSelection ?
                "Sew Selected (Exp)##sewexp" : "Sew All (Exp)##sewexp";

            if (ImGui::Button(buttonLabel.c_str())) {
                m_ctx.editableMesh.saveState();
                int sewnEdges = m_ctx.editableMesh.sewAllUVs(selectedFaces);
                m_ctx.meshDirty = true;
                std::cout << "Sew All: " << sewnEdges << " edges sewn" << std::endl;
            }
            if (ImGui::IsItemHovered()) {
                if (hasSelection) {
                    ImGui::SetTooltip("EXPERIMENTAL: Applies per-face UVs to SELECTED faces,\nthen sews shared edges. Skips edges that would overlap.");
                } else {
                    ImGui::SetTooltip("EXPERIMENTAL: First applies per-face UVs, then attempts to sew\nall shared edges together. Skips edges that would cause UV overlap.");
                }
            }
        }

        ImGui::SliderFloat("UV Scale", &m_ctx.uvProjectionScale, 0.1f, 10.0f, "%.1f");
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Undo/Redo section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.05f, 0.1f, 0.15f, 0.5f));
        ImGui::BeginChild("HistorySection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(0.5f, 0.8f, 1.0f, 1), "History");
        ImGui::Separator();

        if (ImGui::Button("Undo (Ctrl+Z)")) {
            if (m_ctx.editableMesh.undo()) {
                m_ctx.meshDirty = true;
            }
        }
        ImGui::SameLine();
        if (ImGui::Button("Redo (Ctrl+Shift+Z)")) {
            if (m_ctx.editableMesh.redo()) {
                m_ctx.meshDirty = true;
            }
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Display settings section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.05f, 0.12f, 0.05f, 0.5f));
        ImGui::BeginChild("DisplaySection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(0.6f, 0.9f, 0.6f, 1), "Display");
        ImGui::Separator();

        ImGui::Checkbox("Wireframe", &m_ctx.showModelingWireframe);
        ImGui::Checkbox("Face Normals", &m_ctx.showFaceNormals);
        ImGui::Checkbox("Grid", &m_ctx.showGrid);

        if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex) {
            ImGui::SliderFloat("Vertex Size", &m_ctx.vertexDisplaySize, 0.01f, 0.2f, "%.2f");
        }

        ImGui::Spacing();
        ImGui::Text("Colors");

        ImGui::ColorEdit3("Background", &m_ctx.backgroundColor.x, ImGuiColorEditFlags_NoInputs);
        ImGui::SameLine();
        ImGui::ColorEdit3("Mesh", &m_ctx.defaultMeshColor.x, ImGuiColorEditFlags_NoInputs);
        ImGui::SameLine();
        ImGui::Checkbox("Random", &m_ctx.randomMeshColors);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Each new primitive gets a random color");
        }

        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Texture Painting section
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.15f, 0.05f, 0.1f, 0.5f));
        ImGui::BeginChild("TexturePaintSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.7f, 1), "Texture Painting");
        ImGui::Separator();

        bool hasTexture = m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData();

        // New texture button
        if (ImGui::Button("New Texture")) {
            ImGui::OpenPopup("NewTexturePopup");
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Create a blank texture to paint on");
        }

        // New texture popup
        if (ImGui::BeginPopup("NewTexturePopup")) {
            static int texSize = 512;
            ImGui::Text("Texture Size:");
            ImGui::RadioButton("256", &texSize, 256);
            ImGui::SameLine();
            ImGui::RadioButton("512", &texSize, 512);
            ImGui::SameLine();
            ImGui::RadioButton("1024", &texSize, 1024);
            ImGui::SameLine();
            ImGui::RadioButton("2048", &texSize, 2048);

            if (ImGui::Button("Create")) {
                if (m_ctx.selectedObject) {
                    // Create blank white texture
                    std::vector<unsigned char> texData(texSize * texSize * 4, 255);
                    m_ctx.selectedObject->setTextureData(texData, texSize, texSize);

                    // Upload to GPU
                    uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                    m_ctx.modelRenderer.updateTexture(handle, texData.data(), texSize, texSize);

                    std::cout << "Created " << texSize << "x" << texSize << " blank texture" << std::endl;
                }
                ImGui::CloseCurrentPopup();
            }
            ImGui::EndPopup();
        }

        // Delete texture button (only if texture exists)
        ImGui::SameLine();
        if (!hasTexture) ImGui::BeginDisabled();
        if (ImGui::Button("Delete Texture")) {
            if (m_ctx.selectedObject) {
                // Turn off paint mode first
                m_ctx.isPainting = false;
                // Destroy GPU texture
                uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                m_ctx.modelRenderer.destroyTexture(handle);
                // Clear CPU texture data
                m_ctx.selectedObject->clearTextureData();
                std::cout << "Deleted texture" << std::endl;
            }
        }
        if (!hasTexture) ImGui::EndDisabled();

        // Display texture size
        if (hasTexture) {
            ImGui::SameLine();
            ImGui::TextDisabled("%dx%d", m_ctx.selectedObject->getTextureWidth(),
                               m_ctx.selectedObject->getTextureHeight());
        }

        // Paint controls (only if texture exists)
        if (!hasTexture) {
            ImGui::BeginDisabled();
            // Force paint mode off if object has no texture
            m_ctx.isPainting = false;
        }

        ImGui::Checkbox("Paint Mode (P)", &m_ctx.isPainting);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Hold Alt + Click to sample colors (eyedropper)");
        }

        // Brush mode selection
        if (ImGui::Checkbox("Use Stamp", &m_ctx.useStamp)) {
            if (m_ctx.useStamp) { m_ctx.useSmear = false; }
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Click to stamp an image onto the texture");
        }
        ImGui::SameLine();
        if (ImGui::Checkbox("Use Smear", &m_ctx.useSmear)) {
            if (m_ctx.useSmear) { m_ctx.useStamp = false; }
        }
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Drag to smear/smudge colors like finger painting");
        }
        if (m_ctx.useStamp) {
            // Stamp controls
            if (ImGui::Button("Load Stamp...")) {
                nfdchar_t* outPath = nullptr;
                nfdfilteritem_t filters[1] = {{"Image", "png,jpg,jpeg,bmp,tga"}};
                if (NFD_OpenDialog(&outPath, filters, 1, nullptr) == NFD_OKAY) {
                    int w, h, channels;
                    unsigned char* data = stbi_load(outPath, &w, &h, &channels, 4);
                    if (data) {
                        m_ctx.stampData.assign(data, data + w * h * 4);
                        m_ctx.stampWidth = w;
                        m_ctx.stampHeight = h;
                        // Create preview texture
                        if (m_ctx.updateStampPreviewCallback) {
                            m_ctx.updateStampPreviewCallback(data, w, h);
                        }
                        stbi_image_free(data);
                        std::cout << "Loaded stamp: " << w << "x" << h << std::endl;
                    }
                    NFD_FreePath(outPath);
                }
            }
            if (!m_ctx.stampData.empty()) {
                ImGui::SameLine();
                ImGui::TextDisabled("%dx%d", m_ctx.stampWidth, m_ctx.stampHeight);
            }
            ImGui::SliderFloat("Stamp Scale", &m_ctx.stampScale, 0.1f, 3.0f, "%.2f");
            ImGui::SliderFloat("Stamp Scale H", &m_ctx.stampScaleH, 0.1f, 3.0f, "%.2f");
            ImGui::SliderFloat("Stamp Scale V", &m_ctx.stampScaleV, 0.1f, 3.0f, "%.2f");
            ImGui::SliderFloat("Stamp Rotation", &m_ctx.stampRotation, -180.0f, 180.0f, "%.1f deg");
            ImGui::SliderFloat("Opacity", &m_ctx.stampOpacity, 0.0f, 1.0f, "%.2f");

            // Flip buttons
            if (ImGui::Button("Flip H")) {
                m_ctx.stampFlipH = !m_ctx.stampFlipH;
            }
            ImGui::SameLine();
            if (ImGui::Button("Flip V")) {
                m_ctx.stampFlipV = !m_ctx.stampFlipV;
            }
            ImGui::SameLine();
            ImGui::TextDisabled("%s%s", m_ctx.stampFlipH ? "H " : "", m_ctx.stampFlipV ? "V" : "");

            // Show stamp preview thumbnail
            if (m_ctx.stampPreviewDescriptor != VK_NULL_HANDLE && !m_ctx.stampData.empty()) {
                ImGui::Separator();
                ImGui::Text("Preview:");
                // Calculate preview size maintaining aspect ratio
                float maxPreviewSize = 100.0f;
                float aspect = static_cast<float>(m_ctx.stampWidth) / m_ctx.stampHeight;
                float previewW = aspect >= 1.0f ? maxPreviewSize : maxPreviewSize * aspect;
                float previewH = aspect >= 1.0f ? maxPreviewSize / aspect : maxPreviewSize;
                // Apply flip to preview UV coordinates (match actual stamp behavior)
                ImVec2 uv0(m_ctx.stampFlipH ? 1.0f : 0.0f, m_ctx.stampFlipV ? 0.0f : 1.0f);
                ImVec2 uv1(m_ctx.stampFlipH ? 0.0f : 1.0f, m_ctx.stampFlipV ? 1.0f : 0.0f);
                ImGui::Image((ImTextureID)m_ctx.stampPreviewDescriptor, ImVec2(previewW, previewH), uv0, uv1);
            }
        } else if (m_ctx.useSmear) {
            // Smear controls
            ImGui::SliderFloat("Radius", &m_ctx.paintRadius, 0.005f, 0.2f, "%.3f");
            ImGui::SliderFloat("Strength", &m_ctx.smearStrength, 0.1f, 1.0f, "%.2f");
            ImGui::SliderFloat("Pickup", &m_ctx.smearPickup, 0.0f, 1.0f, "%.2f");
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("How much new color to pick up while smearing (0=pure carry, 1=pure sample)");
            }
            ImGui::TextDisabled("Drag to smear colors");
        } else {
            // Regular brush controls
            ImGui::ColorEdit3("Color", &m_ctx.paintColor.x);
            ImGui::SliderFloat("Radius", &m_ctx.paintRadius, 0.005f, 0.2f, "%.3f");
            ImGui::SliderFloat("Strength", &m_ctx.paintStrength, 0.1f, 1.0f, "%.2f");
            ImGui::Checkbox("Square Brush (Pixel Art)", &m_ctx.squareBrush);
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Square brush with no falloff for pixel art style.\nUnchecked = circular brush with soft edges.");
            }
            ImGui::TextDisabled("Shift+Click: draw line");
        }

        if (!hasTexture) ImGui::EndDisabled();
        ImGui::EndChild();
        ImGui::PopStyleColor();

        ImGui::Spacing();

        // Vertex Color Painting section (no UVs needed)
        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4(0.05f, 0.12f, 0.05f, 0.5f));
        ImGui::BeginChild("VertexColorSection", ImVec2(0, 0), ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_Borders);
        ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1), "Vertex Color Painting");
        ImGui::Separator();
        ImGui::TextDisabled("Paint directly on vertices (no UVs needed)");

        ImGui::Checkbox("Vertex Paint Mode (V)", &m_vertexPaintMode);
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Paint colors directly onto mesh vertices.\nNo UV mapping required.\nResolution depends on vertex density.");
        }

        if (!m_vertexPaintMode) ImGui::BeginDisabled();

        ImGui::ColorEdit3("Paint Color##vtx", &m_vertexPaintColor.x);
        ImGui::SliderFloat("Radius##vtx", &m_vertexPaintRadius, 0.01f, 1.0f, "%.3f");
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("Brush radius in local mesh units");
        }
        ImGui::SliderFloat("Strength##vtx", &m_vertexPaintStrength, 0.1f, 1.0f, "%.2f");

        // Fill all vertices with current color
        if (ImGui::Button("Fill All Vertices")) {
            if (m_ctx.selectedObject && m_ctx.editableMesh.isValid()) {
                m_ctx.editableMesh.saveState();
                glm::vec4 color(m_vertexPaintColor, 1.0f);
                for (uint32_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                    m_ctx.editableMesh.getVertex(i).color = color;
                }
                m_ctx.meshDirty = true;
            }
        }
        ImGui::SameLine();
        if (ImGui::Button("Fill Selected")) {
            if (m_ctx.selectedObject && m_ctx.editableMesh.isValid()) {
                m_ctx.editableMesh.saveState();
                glm::vec4 color(m_vertexPaintColor, 1.0f);
                // Get vertices affected by current selection
                auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
                auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();

                std::set<uint32_t> vertsToFill;
                for (uint32_t v : selectedVerts) vertsToFill.insert(v);
                for (uint32_t f : selectedFaces) {
                    auto faceVerts = m_ctx.editableMesh.getFaceVertices(f);
                    for (uint32_t v : faceVerts) vertsToFill.insert(v);
                }

                for (uint32_t v : vertsToFill) {
                    m_ctx.editableMesh.getVertex(v).color = color;
                }
                m_ctx.meshDirty = true;
            }
        }

        if (!m_vertexPaintMode) ImGui::EndDisabled();

        // Handle vertex painting input
        if (m_vertexPaintMode && m_ctx.selectedObject && m_ctx.editableMesh.isValid()) {
            bool imguiCapture = ImGui::GetIO().WantCaptureMouse;
            if (Input::isMouseButtonDown(0) && !imguiCapture) {
                glm::vec3 rayOrigin, rayDir;
                m_ctx.getMouseRay(rayOrigin, rayDir);

                // Transform ray to local space
                glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
                glm::mat4 invModel = glm::inverse(modelMatrix);
                glm::vec3 localRayOrigin = glm::vec3(invModel * glm::vec4(rayOrigin, 1.0f));
                glm::vec3 localRayDir = glm::normalize(glm::vec3(invModel * glm::vec4(rayDir, 0.0f)));

                // Raycast to find hit point
                auto hit = m_ctx.editableMesh.raycastFace(localRayOrigin, localRayDir);

                if (hit.hit) {
                    // Save state only on mouse press (not during drag)
                    if (!m_vertexPaintingActive) {
                        m_ctx.editableMesh.saveState();
                        m_vertexPaintingActive = true;
                    }

                    glm::vec3 hitPos = hit.position;
                    glm::vec4 paintCol(m_vertexPaintColor, 1.0f);

                    // Find all vertices within radius and paint them
                    for (uint32_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                        HEVertex& v = m_ctx.editableMesh.getVertex(i);
                        float dist = glm::length(v.position - hitPos);

                        if (dist < m_vertexPaintRadius) {
                            // Calculate falloff (1 at center, 0 at edge)
                            float falloff = 1.0f - (dist / m_vertexPaintRadius);
                            falloff = falloff * falloff;  // Quadratic falloff for smoother edges
                            float blend = falloff * m_vertexPaintStrength;

                            // Blend color
                            v.color = glm::mix(v.color, paintCol, blend);
                        }
                    }

                    m_ctx.meshDirty = true;
                }
            } else {
                // Mouse released, reset painting state for next stroke
                m_vertexPaintingActive = false;
            }
        }
        ImGui::EndChild();
        ImGui::PopStyleColor();
    }
    ImGui::End();
    }

    // Camera window
    ImGui::SetNextWindowPos(ImVec2(static_cast<float>(m_ctx.window.getWidth()) - 220.0f, 20), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(220, 280), ImGuiCond_FirstUseEver);

    if (m_ctx.showCameraWindow) {
    if (ImGui::Begin("Camera", &m_ctx.showCameraWindow)) {
        bool isPerspective = m_ctx.camera.getProjectionMode() == ProjectionMode::Perspective;

        // View presets - ortho buttons affect right viewport (camera2), persp affects left (camera)
        if (ImGui::CollapsingHeader("View Presets", ImGuiTreeNodeFlags_DefaultOpen)) {
            glm::vec3 viewCenter = m_ctx.selectedObject ? m_ctx.selectedObject->getTransform().getPosition() : glm::vec3(0);

            ImGui::TextDisabled("Left: Perspective | Right: Ortho");

            float btnWidth = 45.0f;
            // Row 1: Top, Front, Right
            if (ImGui::Button("Top", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Top;
                m_ctx.camera2.setViewPreset(ViewPreset::Top, viewCenter);
            }
            ImGui::SameLine();
            if (ImGui::Button("Front", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Front;
                m_ctx.camera2.setViewPreset(ViewPreset::Front, viewCenter);
            }
            ImGui::SameLine();
            if (ImGui::Button("Right", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Right;
                m_ctx.camera2.setViewPreset(ViewPreset::Right, viewCenter);
            }
            ImGui::SameLine();
            if (ImGui::Button("Persp", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = false;
                m_ctx.camera.setProjectionMode(ProjectionMode::Perspective);
                m_ctx.camera.setPosition(viewCenter + glm::vec3(3, 2, 5));
                m_ctx.camera.setYaw(-120.0f);
                m_ctx.camera.setPitch(-15.0f);
            }

            // Row 2: Bottom, Back, Left
            if (ImGui::Button("Botm", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Bottom;
                m_ctx.camera2.setViewPreset(ViewPreset::Bottom, viewCenter);
            }
            ImGui::SameLine();
            if (ImGui::Button("Back", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Back;
                m_ctx.camera2.setViewPreset(ViewPreset::Back, viewCenter);
            }
            ImGui::SameLine();
            if (ImGui::Button("Left", ImVec2(btnWidth, 0))) {
                m_ctx.splitView = true;
                m_ctx.splitOrthoPreset = ViewPreset::Left;
                m_ctx.camera2.setViewPreset(ViewPreset::Left, viewCenter);
            }

            ImGui::Separator();
        }

        // Split view controls
        if (ImGui::Checkbox("Split View", &m_ctx.splitView)) {
            if (m_ctx.splitView) {
                glm::vec3 viewCenter = m_ctx.selectedObject ? m_ctx.selectedObject->getTransform().getPosition() : glm::vec3(0);
                m_ctx.camera2.setViewPreset(m_ctx.splitOrthoPreset, viewCenter);
                // Ensure left camera stays perspective
                m_ctx.camera.setProjectionMode(ProjectionMode::Perspective);
            }
        }

        if (m_ctx.splitView) {
            ImGui::SameLine();
            ImGui::TextDisabled(m_ctx.activeViewportLeft ? "(Left active)" : "(Right active)");

            const char* presetNames[] = { "Top", "Bottom", "Front", "Back", "Right", "Left" };
            int presetIndex = static_cast<int>(m_ctx.splitOrthoPreset) - 1;
            if (presetIndex < 0) presetIndex = 0;
            if (ImGui::Combo("Right View", &presetIndex, presetNames, 6)) {
                m_ctx.splitOrthoPreset = static_cast<ViewPreset>(presetIndex + 1);
                glm::vec3 viewCenter = m_ctx.selectedObject ? m_ctx.selectedObject->getTransform().getPosition() : glm::vec3(0);
                m_ctx.camera2.setViewPreset(m_ctx.splitOrthoPreset, viewCenter);
            }
        }

        ImGui::Separator();
        ImGui::SliderFloat("Speed", &m_ctx.cameraSpeed, 0.01f, 0.2f, "%.3f");
        if (isPerspective) {
            ImGui::TextDisabled("RMB + WASD fly | Numpad: 1=Front 3=Right 7=Top");
        } else {
            ImGui::TextDisabled("WASD pan, Wheel zoom | Numpad presets");
        }

        // Reference Images section
        ImGui::Separator();
        if (ImGui::CollapsingHeader("Reference Images")) {
            const char* viewNames[] = {"Top", "Bottom", "Front", "Back", "Right", "Left"};

            for (int i = 0; i < 6; i++) {
                auto& ref = m_ctx.referenceImages[i];
                ImGui::PushID(i);

                // View name and load button
                ImGui::Text("%s:", viewNames[i]);
                ImGui::SameLine(70);

                if (ref.loaded) {
                    ImGui::Checkbox("##vis", &ref.visible);
                    ImGui::SameLine();
                    ImGui::Text("%s", ref.name.c_str());
                    ImGui::SameLine();
                    if (ImGui::SmallButton("X")) {
                        if (m_ctx.clearReferenceImageCallback) {
                            m_ctx.clearReferenceImageCallback(i);
                        }
                    }
                    if (ImGui::IsItemHovered()) {
                        ImGui::SetTooltip("Remove reference image");
                    }

                    // Controls for loaded image
                    ImGui::SliderFloat("Opacity", &ref.opacity, 0.0f, 1.0f, "%.2f");
                    ImGui::DragFloat2("Offset", &ref.offset.x, 0.1f);
                    ImGui::DragFloat2("Size", &ref.size.x, 0.1f, 0.1f, 50.0f);
                } else {
                    if (ImGui::Button("Load...")) {
                        loadReferenceImage(i);
                    }
                }

                ImGui::PopID();
                if (i < 5) ImGui::Separator();
            }
        }
    }
    ImGui::End();
    }

    // UV Window
    if (m_ctx.showUVWindow) {
        renderModelingUVWindow();
    }

    // Image Reference Window (for color sampling and stamps)
    if (m_ctx.showImageRefWindow) {
        renderImageRefWindow();
    }

    // Draw split view divider
    if (m_ctx.splitView) {
        ImDrawList* drawList = ImGui::GetForegroundDrawList();
        float screenWidth = static_cast<float>(m_ctx.window.getWidth());
        float screenHeight = static_cast<float>(m_ctx.window.getHeight());
        float centerX = screenWidth / 2.0f;

        drawList->AddLine(ImVec2(centerX, 0), ImVec2(centerX, screenHeight),
                          IM_COL32(100, 100, 100, 255), 2.0f);

        const char* presetNames[] = { "Custom", "Top", "Bottom", "Front", "Back", "Right", "Left" };
        int presetIdx = static_cast<int>(m_ctx.splitOrthoPreset);
        const char* rightLabel = (presetIdx >= 0 && presetIdx < 7) ? presetNames[presetIdx] : "Unknown";

        drawList->AddText(ImVec2(10, 25), IM_COL32(200, 200, 200, 200), "Perspective");
        if (!m_ctx.activeViewportLeft) {
            drawList->AddText(ImVec2(10, 40), IM_COL32(150, 150, 150, 150), "(inactive)");
        }

        drawList->AddText(ImVec2(centerX + 10, 25), IM_COL32(200, 200, 200, 200), rightLabel);
        if (m_ctx.activeViewportLeft) {
            drawList->AddText(ImVec2(centerX + 10, 40), IM_COL32(150, 150, 150, 150), "(inactive)");
        }
    }
}

void ModelingMode::renderModelingUVWindow() {
    // Use Appearing so window shows up properly after being re-enabled from menu
    ImGui::SetNextWindowSize(ImVec2(420, 520), ImGuiCond_Appearing);

    ImGuiWindowFlags windowFlags = 0;
    if (m_ctx.uvDraggingSelection || m_ctx.uvScaling || m_ctx.uvRotating || m_ctx.uvChildHovered) {
        windowFlags |= ImGuiWindowFlags_NoMove;
    }

    if (ImGui::Begin("UV Editor", &m_ctx.showUVWindow, windowFlags)) {
        if (!m_ctx.editableMesh.isValid()) {
            ImGui::Text("No mesh loaded. Load or create a model first.");
            ImGui::End();
            return;
        }

        // Selection mode toggle: 0=Island, 1=Face, 2=Edge, 3=Vertex
        ImGui::Text("Select:");
        ImGui::SameLine();
        if (ImGui::RadioButton("Island", m_ctx.uvSelectionMode == 0)) {
            m_ctx.uvSelectionMode = 0;
            m_ctx.uvEdgeSelectionMode = false;
            clearUVEdgeSelection();
            m_ctx.uvSelectedVertices.clear();
            std::cout << "[UV] Mode changed to: Island" << std::endl;
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Face", m_ctx.uvSelectionMode == 1)) {
            m_ctx.uvSelectionMode = 1;
            m_ctx.uvEdgeSelectionMode = false;
            clearUVEdgeSelection();
            m_ctx.uvSelectedVertices.clear();
            std::cout << "[UV] Mode changed to: Face" << std::endl;
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Edge", m_ctx.uvSelectionMode == 2)) {
            m_ctx.uvSelectionMode = 2;
            m_ctx.uvEdgeSelectionMode = true;
            m_ctx.uvSelectedFaces.clear();
            m_ctx.uvSelectedVertices.clear();
            std::cout << "[UV] Mode changed to: Edge" << std::endl;
        }
        ImGui::SameLine();
        if (ImGui::RadioButton("Vertex", m_ctx.uvSelectionMode == 3)) {
            m_ctx.uvSelectionMode = 3;
            m_ctx.uvEdgeSelectionMode = false;
            m_ctx.uvSelectedFaces.clear();
            clearUVEdgeSelection();
            std::cout << "[UV] Mode changed to: Vertex" << std::endl;
        }

        // Sew/Unsew buttons (edge mode only, mode 2)
        if (m_ctx.uvSelectionMode == 2 && m_ctx.uvSelectedEdge.first != UINT32_MAX) {
            ImGui::SameLine();
            ImGui::Spacing();
            ImGui::SameLine();

            bool canSew = !m_ctx.uvTwinEdges.empty();
            if (!canSew) ImGui::BeginDisabled();
            if (ImGui::Button("Sew")) {
                std::cout << "[UV] Sew button clicked (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                sewSelectedEdge();
            }
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled)) {
                ImGui::SetTooltip("Snap twin edge to selected edge (W)");
            }
            if (!canSew) ImGui::EndDisabled();

            ImGui::SameLine();
            if (!canSew) ImGui::BeginDisabled();
            if (ImGui::Button("Move+Sew")) {
                std::cout << "[UV] Move+Sew button clicked (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                moveAndSewSelectedEdge();
            }
            if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled)) {
                ImGui::SetTooltip("Move & rotate twin island to align, then sew (Shift+W)");
            }
            if (!canSew) ImGui::EndDisabled();

            ImGui::SameLine();
            if (ImGui::Button("Unsew")) {
                std::cout << "[UV] Unsew button clicked (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                unsewSelectedEdge();
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Separate sewn edge (U)");
            }
        }

        // Sew Vertices button (vertex mode only, mode 3)
        if (m_ctx.uvSelectionMode == 3 && m_ctx.uvSelectedVertices.size() >= 2) {
            ImGui::SameLine();
            ImGui::Spacing();
            ImGui::SameLine();

            if (ImGui::Button("Sew Verts")) {
                // Calculate midpoint of all selected vertices
                glm::vec2 midpoint(0.0f);
                for (uint32_t vertIdx : m_ctx.uvSelectedVertices) {
                    midpoint += m_ctx.editableMesh.getVertex(vertIdx).uv;
                }
                midpoint /= static_cast<float>(m_ctx.uvSelectedVertices.size());

                // Move all selected vertices to midpoint
                m_ctx.editableMesh.saveState();
                for (uint32_t vertIdx : m_ctx.uvSelectedVertices) {
                    m_ctx.editableMesh.getVertex(vertIdx).uv = midpoint;
                }
                m_ctx.meshDirty = true;

                std::cout << "[UV] Sewn " << m_ctx.uvSelectedVertices.size()
                          << " vertices to midpoint (" << midpoint.x << ", " << midpoint.y << ")" << std::endl;
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Move selected vertices to their midpoint");
            }
        }

        ImGui::SameLine();
        ImGui::ColorEdit3("##Wireframe", &m_ctx.uvWireframeColor.x, ImGuiColorEditFlags_NoInputs);
        ImGui::SameLine();
        ImGui::SliderFloat("Zoom", &m_ctx.uvZoom, 0.25f, 8.0f, "%.2fx");
        ImGui::SameLine();
        if (ImGui::Button("Reset##UVZoom")) {
            m_ctx.uvZoom = 1.0f;
            m_ctx.uvPan = glm::vec2(0.0f);
            std::cout << "[UV] Reset zoom and pan" << std::endl;
        }
        ImGui::Separator();

        ImVec2 available = ImGui::GetContentRegionAvail();
        float viewWidth = available.x;
        float viewHeight = available.y - 30;  // Leave room for status text
        if (viewWidth < 64) viewWidth = 64;
        if (viewHeight < 64) viewHeight = 64;

        ImGui::BeginChild("UVViewModeling", ImVec2(viewWidth, viewHeight), true,
            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

        ImVec2 canvasPos = ImGui::GetCursorScreenPos();
        ImVec2 mousePos = ImGui::GetIO().MousePos;
        bool isHovered = ImGui::IsWindowHovered();

        m_ctx.uvChildHovered = isHovered;

        // Use the smaller dimension as the base UV space size to maintain aspect ratio
        float uvBaseSize = std::min(viewWidth, viewHeight);
        float texSize = uvBaseSize * m_ctx.uvZoom;
        float offsetX = canvasPos.x + (viewWidth - texSize) * 0.5f + m_ctx.uvPan.x * texSize;
        float offsetY = canvasPos.y + (viewHeight - texSize) * 0.5f + m_ctx.uvPan.y * texSize;

        auto screenToUV = [&](const ImVec2& screen) -> glm::vec2 {
            float u = (screen.x - offsetX) / texSize;
            float v = 1.0f - (screen.y - offsetY) / texSize;
            return glm::vec2(u, v);
        };

        // Handle zoom/pan
        if (isHovered) {
            float wheel = ImGui::GetIO().MouseWheel;
            if (wheel != 0) {
                float oldZoom = m_ctx.uvZoom;
                float zoomDelta = wheel * 0.2f * m_ctx.uvZoom;
                m_ctx.uvZoom = std::clamp(m_ctx.uvZoom + zoomDelta, 0.25f, 8.0f);
                std::cout << "[UV] Zoom: " << oldZoom << " -> " << m_ctx.uvZoom << std::endl;
            }
            if (ImGui::IsMouseClicked(ImGuiMouseButton_Middle)) {
                m_ctx.uvPanning = true;
                m_ctx.uvPanStart = glm::vec2(mousePos.x, mousePos.y);
                std::cout << "[UV] Started panning" << std::endl;
            }

            // Hotkeys synchronized with 3D viewport (Q, W, A, S, D)
            // Q - Select mode (no gizmo)
            if (Input::isKeyPressed(Input::KEY_Q)) {
                m_ctx.gizmoMode = GizmoMode::None;
            }
            // W - Move mode
            if (Input::isKeyPressed(Input::KEY_W)) {
                m_ctx.gizmoMode = GizmoMode::Move;
            }
            // A - Vertex mode (uvSelectionMode 3, modelingSelectionMode Vertex)
            if (Input::isKeyPressed(Input::KEY_A) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
                m_ctx.uvSelectionMode = 3;
                m_ctx.uvEdgeSelectionMode = false;
                m_ctx.modelingSelectionMode = ModelingSelectionMode::Vertex;
                m_ctx.editableMesh.clearSelection();
                m_ctx.uvSelectedFaces.clear();
                clearUVEdgeSelection();
            }
            // S - Edge mode (uvSelectionMode 2, modelingSelectionMode Edge)
            if (Input::isKeyPressed(Input::KEY_S) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
                m_ctx.uvSelectionMode = 2;
                m_ctx.uvEdgeSelectionMode = true;
                m_ctx.modelingSelectionMode = ModelingSelectionMode::Edge;
                m_ctx.editableMesh.clearSelection();
                m_ctx.uvSelectedFaces.clear();
                m_ctx.uvSelectedVertices.clear();
            }
            // D - Face mode (uvSelectionMode 1, modelingSelectionMode Face)
            if (Input::isKeyPressed(Input::KEY_D)) {
                m_ctx.uvSelectionMode = 1;
                m_ctx.uvEdgeSelectionMode = false;
                m_ctx.modelingSelectionMode = ModelingSelectionMode::Face;
                m_ctx.editableMesh.clearSelection();
                clearUVEdgeSelection();
                m_ctx.uvSelectedVertices.clear();
            }
        }

        if (m_ctx.uvPanning) {
            if (ImGui::IsMouseDown(ImGuiMouseButton_Middle)) {
                glm::vec2 newPos(mousePos.x, mousePos.y);
                glm::vec2 delta = newPos - m_ctx.uvPanStart;
                m_ctx.uvPan += delta / texSize;
                m_ctx.uvPanStart = newPos;
            } else {
                m_ctx.uvPanning = false;
                std::cout << "[UV] Stopped panning. Pan offset: (" << m_ctx.uvPan.x << ", " << m_ctx.uvPan.y << ")" << std::endl;
            }
        }

        // Handle UV painting when paint mode is active (same toggle as 3D painting)
        // Skip painting when Alt is held (Alt+click is for color sampling)
        static bool uvPaintingLastFrame = false;
        if (m_ctx.isPainting && m_ctx.selectedObject && isHovered && !m_ctx.uvPanning && !ImGui::GetIO().KeyAlt) {
            if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                glm::vec2 paintUV = screenToUV(mousePos);

                // Save texture state at start of stroke
                if (!uvPaintingLastFrame) {
                    m_ctx.selectedObject->saveTextureState();
                }
                uvPaintingLastFrame = true;

                // Check if UV is within valid range (0-1)
                if (paintUV.x >= 0.0f && paintUV.x <= 1.0f && paintUV.y >= 0.0f && paintUV.y <= 1.0f) {
                    m_ctx.selectedObject->paintAt(paintUV, m_ctx.paintColor, m_ctx.paintRadius, m_ctx.paintStrength, m_ctx.squareBrush);
                    m_ctx.selectedObject->markTextureModified();

                    // Upload modified texture to GPU for live feedback
                    uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                    auto& texData = m_ctx.selectedObject->getTextureData();
                    int w = m_ctx.selectedObject->getTextureWidth();
                    int h = m_ctx.selectedObject->getTextureHeight();
                    m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
                    m_ctx.selectedObject->clearTextureModified();
                }
            } else {
                uvPaintingLastFrame = false;
            }
        } else {
            uvPaintingLastFrame = false;
        }

        // Color sampling in UV editor: Alt + Click
        if (m_ctx.isPainting && m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData() &&
            isHovered && !m_ctx.uvPanning && ImGui::IsMouseClicked(ImGuiMouseButton_Left) && ImGui::GetIO().KeyAlt) {
            glm::vec2 sampleUV = screenToUV(mousePos);

            // Check if UV is within valid range (0-1)
            if (sampleUV.x >= 0.0f && sampleUV.x <= 1.0f && sampleUV.y >= 0.0f && sampleUV.y <= 1.0f) {
                int texW = m_ctx.selectedObject->getTextureWidth();
                int texH = m_ctx.selectedObject->getTextureHeight();
                auto& texData = m_ctx.selectedObject->getTextureData();

                int px = static_cast<int>(sampleUV.x * texW);
                int py = static_cast<int>(sampleUV.y * texH);
                px = std::clamp(px, 0, texW - 1);
                py = std::clamp(py, 0, texH - 1);

                size_t pixelIdx = (py * texW + px) * 4;
                if (pixelIdx + 2 < texData.size()) {
                    m_ctx.paintColor.r = texData[pixelIdx] / 255.0f;
                    m_ctx.paintColor.g = texData[pixelIdx + 1] / 255.0f;
                    m_ctx.paintColor.b = texData[pixelIdx + 2] / 255.0f;

                    std::cout << "[UV] Sampled color at UV (" << sampleUV.x << ", " << sampleUV.y << "): RGB("
                              << static_cast<int>(m_ctx.paintColor.r * 255) << ", "
                              << static_cast<int>(m_ctx.paintColor.g * 255) << ", "
                              << static_cast<int>(m_ctx.paintColor.b * 255) << ")" << std::endl;
                }
            }
        }

        // Handle selection
        bool shiftHeld = ImGui::GetIO().KeyShift;

        // Skip selection handling if we're painting
        if (m_ctx.isPainting && m_ctx.selectedObject && isHovered && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
            // Don't process selection clicks while painting
        } else if (isHovered && ImGui::IsMouseClicked(ImGuiMouseButton_Left) && !m_ctx.uvPanning) {
            glm::vec2 clickUV = screenToUV(mousePos);

            if (m_ctx.uvSelectionMode == 3) {
                // Vertex selection mode
                float threshold = 0.015f / m_ctx.uvZoom;
                int clickedVert = findUVVertexAtPoint(clickUV, threshold);
                std::cout << "[UV] Click at UV (" << clickUV.x << ", " << clickUV.y << ")" << std::endl;

                if (clickedVert >= 0) {
                    uint32_t vertIdx = static_cast<uint32_t>(clickedVert);
                    glm::vec2 vertUV = m_ctx.editableMesh.getVertex(vertIdx).uv;
                    bool isSeam = isSeamVertex(m_ctx.editableMesh, vertIdx);
                    if (m_ctx.uvSelectedVertices.count(vertIdx) > 0) {
                        // Start dragging selected vertices
                        m_ctx.uvDraggingVertex = true;
                        m_ctx.uvDragStart = clickUV;
                        m_ctx.editableMesh.saveState();
                        storeOriginalUVsForVertices();
                        std::cout << "[UV] Start dragging " << m_ctx.uvSelectedVertices.size() << " vertices" << std::endl;
                    } else {
                        if (!shiftHeld) {
                            m_ctx.uvSelectedVertices.clear();
                        }
                        m_ctx.uvSelectedVertices.insert(vertIdx);
                        if (isSeam) {
                            std::cout << "[UV] Selected SEAM vertex " << vertIdx << " at UV (" << vertUV.x << ", " << vertUV.y << ")" << std::endl;
                        } else {
                            std::cout << "[UV] Selected vertex " << vertIdx << " at UV (" << vertUV.x << ", " << vertUV.y << ")" << std::endl;
                        }
                    }
                } else {
                    if (!shiftHeld) {
                        m_ctx.uvSelectedVertices.clear();
                        std::cout << "[UV] Cleared vertex selection" << std::endl;
                    }
                }
            } else if (m_ctx.uvSelectionMode == 2) {
                // Edge selection mode
                float threshold = 0.02f / m_ctx.uvZoom;
                auto [faceIdx, edgeIdx] = findUVEdgeAtPoint(clickUV, threshold);

                if (faceIdx != UINT32_MAX) {
                    m_ctx.uvSelectedEdge = {faceIdx, edgeIdx};
                    findTwinUVEdges(faceIdx, edgeIdx);
                    std::cout << "[UV] Selected edge on face " << faceIdx << ", edge " << edgeIdx << std::endl;
                } else {
                    clearUVEdgeSelection();
                    std::cout << "[UV] Cleared edge selection" << std::endl;
                }
            } else if (m_ctx.uvSelectionMode == 1) {
                // Face selection mode (individual faces only)
                int clickedFace = findUVFaceAtPoint(clickUV);

                if (clickedFace >= 0) {
                    uint32_t faceIdx = static_cast<uint32_t>(clickedFace);
                    if (m_ctx.uvSelectedFaces.count(faceIdx) > 0) {
                        m_ctx.uvDraggingSelection = true;
                        m_ctx.uvDragStart = clickUV;
                        m_ctx.editableMesh.saveState();
                        storeOriginalUVs();
                        std::cout << "[UV] Start dragging " << m_ctx.uvSelectedFaces.size() << " faces" << std::endl;
                    } else {
                        if (!shiftHeld) {
                            m_ctx.uvSelectedFaces.clear();
                        }
                        m_ctx.uvSelectedFaces.insert(faceIdx);  // Select just this face
                        std::cout << "[UV] Selected face " << clickedFace << std::endl;
                    }
                } else {
                    if (!shiftHeld) {
                        m_ctx.uvSelectedFaces.clear();
                        std::cout << "[UV] Cleared face selection" << std::endl;
                    }
                }
            } else {
                // Island selection mode (mode 0)
                int clickedFace = findUVFaceAtPoint(clickUV);

                if (clickedFace >= 0) {
                    if (m_ctx.uvSelectedFaces.count(static_cast<uint32_t>(clickedFace)) > 0) {
                        m_ctx.uvDraggingSelection = true;
                        m_ctx.uvDragStart = clickUV;
                        m_ctx.editableMesh.saveState();
                        storeOriginalUVs();
                        std::cout << "[UV] Start dragging " << m_ctx.uvSelectedFaces.size() << " faces" << std::endl;
                    } else {
                        if (!shiftHeld) {
                            m_ctx.uvSelectedFaces.clear();
                        }
                        selectUVIsland(static_cast<uint32_t>(clickedFace));
                        std::cout << "[UV] Selected island starting at face " << clickedFace << ", total " << m_ctx.uvSelectedFaces.size() << " faces" << std::endl;
                    }
                } else {
                    if (!shiftHeld) {
                        m_ctx.uvSelectedFaces.clear();
                        std::cout << "[UV] Cleared island selection" << std::endl;
                    }
                }
            }
        }

        // Handle vertex dragging
        if (m_ctx.uvDraggingVertex) {
            if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                glm::vec2 currentUV = screenToUV(mousePos);
                glm::vec2 delta = currentUV - m_ctx.uvDragStart;
                moveSelectedUVVertices(delta);
            } else {
                m_ctx.uvDraggingVertex = false;
                m_ctx.meshDirty = true;
                // Print final positions
                std::cout << "[UV] Finished dragging vertices. Final positions:" << std::endl;
                for (uint32_t vIdx : m_ctx.uvSelectedVertices) {
                    glm::vec2 uv = m_ctx.editableMesh.getVertex(vIdx).uv;
                    bool isSeam = isSeamVertex(m_ctx.editableMesh, vIdx);
                    if (isSeam) {
                        std::cout << "  Moved SEAM vertex " << vIdx << ": (" << uv.x << ", " << uv.y << ")" << std::endl;
                    } else {
                        std::cout << "  Moved vertex " << vIdx << ": (" << uv.x << ", " << uv.y << ")" << std::endl;
                    }
                }
            }
        }

        // Handle face dragging
        if (m_ctx.uvDraggingSelection) {
            if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                glm::vec2 currentUV = screenToUV(mousePos);
                glm::vec2 delta = currentUV - m_ctx.uvDragStart;
                moveSelectedUVs(delta);
            } else {
                m_ctx.uvDraggingSelection = false;
                m_ctx.meshDirty = true;
                glm::vec2 finalUV = screenToUV(mousePos);
                glm::vec2 totalDelta = finalUV - m_ctx.uvDragStart;
                std::cout << "[UV] Finished dragging faces. Delta: (" << totalDelta.x << ", " << totalDelta.y << ")" << std::endl;
            }
        }

        // Handle scaling (S key)
        if (isHovered && !m_ctx.uvSelectedFaces.empty() && !m_ctx.uvDraggingSelection && !m_ctx.uvRotating) {
            if (ImGui::IsKeyPressed(ImGuiKey_S) && !m_ctx.uvScaling) {
                m_ctx.uvScaling = true;
                glm::vec2 min, max;
                getUVSelectionBounds(min, max);
                m_ctx.uvScaleCenter = (min + max) * 0.5f;
                m_ctx.uvScaleStart = screenToUV(mousePos);
                m_ctx.editableMesh.saveState();
                storeOriginalUVs();
                std::cout << "[UV] Started scaling. Center: (" << m_ctx.uvScaleCenter.x << ", " << m_ctx.uvScaleCenter.y << ")" << std::endl;
            }
        }

        if (m_ctx.uvScaling) {
            glm::vec2 currentUV = screenToUV(mousePos);
            float startDist = glm::length(m_ctx.uvScaleStart - m_ctx.uvScaleCenter);
            float currentDist = glm::length(currentUV - m_ctx.uvScaleCenter);
            float scale = (startDist > 0.001f) ? (currentDist / startDist) : 1.0f;
            scaleSelectedUVs(m_ctx.uvScaleCenter, scale);

            if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) || ImGui::IsKeyPressed(ImGuiKey_Enter)) {
                m_ctx.uvScaling = false;
                m_ctx.meshDirty = true;
                std::cout << "[UV] Confirmed scale. Final scale factor: " << scale << std::endl;
            }
            if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
                for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
                    m_ctx.editableMesh.getVertex(vertIdx).uv = origUV;
                }
                m_ctx.uvScaling = false;
                m_ctx.editableMesh.undo();
                std::cout << "[UV] Cancelled scaling" << std::endl;
            }
        }

        // Handle rotation (R key)
        if (isHovered && !m_ctx.uvSelectedFaces.empty() && !m_ctx.uvDraggingSelection && !m_ctx.uvScaling) {
            if (ImGui::IsKeyPressed(ImGuiKey_R) && !m_ctx.uvRotating) {
                m_ctx.uvRotating = true;
                glm::vec2 min, max;
                getUVSelectionBounds(min, max);
                m_ctx.uvScaleCenter = (min + max) * 0.5f;
                glm::vec2 startUV = screenToUV(mousePos);
                glm::vec2 toMouse = startUV - m_ctx.uvScaleCenter;
                m_ctx.uvRotateStartAngle = std::atan2(toMouse.y, toMouse.x);
                m_ctx.editableMesh.saveState();
                storeOriginalUVs();
                std::cout << "[UV] Started rotating. Center: (" << m_ctx.uvScaleCenter.x << ", " << m_ctx.uvScaleCenter.y << ")" << std::endl;
            }
        }

        if (m_ctx.uvRotating) {
            glm::vec2 currentUV = screenToUV(mousePos);
            glm::vec2 toMouse = currentUV - m_ctx.uvScaleCenter;
            float currentAngle = std::atan2(toMouse.y, toMouse.x);
            float angleDelta = glm::degrees(currentAngle - m_ctx.uvRotateStartAngle);
            rotateSelectedUVs(m_ctx.uvScaleCenter, angleDelta);

            if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) || ImGui::IsKeyPressed(ImGuiKey_Enter)) {
                m_ctx.uvRotating = false;
                m_ctx.meshDirty = true;
                std::cout << "[UV] Confirmed rotation. Final angle: " << angleDelta << " degrees" << std::endl;
            }
            if (ImGui::IsKeyPressed(ImGuiKey_Escape)) {
                for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
                    m_ctx.editableMesh.getVertex(vertIdx).uv = origUV;
                }
                m_ctx.uvRotating = false;
                m_ctx.editableMesh.undo();
                std::cout << "[UV] Cancelled rotation" << std::endl;
            }
        }

        // Handle sewing keys (edge mode = 2)
        if (isHovered && m_ctx.uvSelectionMode == 2 && m_ctx.uvSelectedEdge.first != UINT32_MAX) {
            bool shiftHeldForSew = ImGui::GetIO().KeyShift;

            if (ImGui::IsKeyPressed(ImGuiKey_W) && !m_ctx.uvTwinEdges.empty()) {
                if (shiftHeldForSew) {
                    std::cout << "[UV] Move+Sew on edge (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                    moveAndSewSelectedEdge();
                } else {
                    std::cout << "[UV] Sew on edge (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                    sewSelectedEdge();
                }
            }
            if (ImGui::IsKeyPressed(ImGuiKey_U)) {
                std::cout << "[UV] Unsew on edge (face " << m_ctx.uvSelectedEdge.first << ", edge " << m_ctx.uvSelectedEdge.second << ")" << std::endl;
                unsewSelectedEdge();
            }
        }

        ImDrawList* drawList = ImGui::GetWindowDrawList();
        drawList->PushClipRect(canvasPos, ImVec2(canvasPos.x + viewWidth, canvasPos.y + viewHeight), true);

        // Background
        drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + viewWidth, canvasPos.y + viewHeight),
            IM_COL32(40, 40, 40, 255));

        ImVec2 texMin(offsetX, offsetY);
        ImVec2 texMax(offsetX + texSize, offsetY + texSize);

        // Checkerboard
        int checkerCount = 8;
        float checkerSize = texSize / checkerCount;
        for (int cy = 0; cy < checkerCount; cy++) {
            for (int cx = 0; cx < checkerCount; cx++) {
                bool isLight = ((cx + cy) % 2 == 0);
                ImU32 color = isLight ? IM_COL32(80, 80, 80, 255) : IM_COL32(60, 60, 60, 255);
                ImVec2 cMin(texMin.x + cx * checkerSize, texMin.y + cy * checkerSize);
                ImVec2 cMax(texMin.x + (cx + 1) * checkerSize, texMin.y + (cy + 1) * checkerSize);
                drawList->AddRectFilled(cMin, cMax, color);
            }
        }

        // Draw texture if available (flip Y to match UV convention)
        if (m_ctx.selectedObject) {
            ModelGPUData* gpuData = m_ctx.modelRenderer.getModelData(m_ctx.selectedObject->getBufferHandle());
            if (gpuData && gpuData->descriptorSet) {
                // Flip texture vertically: uv0=(0,1), uv1=(1,0)
                drawList->AddImage((ImTextureID)gpuData->descriptorSet, texMin, texMax,
                                   ImVec2(0, 1), ImVec2(1, 0));
            }
        }

        // Use black wireframe for selected faces so lines show through selection overlay
        bool hasSelection = !m_ctx.uvSelectedFaces.empty();
        ImU32 wireColor = IM_COL32(
            static_cast<int>(m_ctx.uvWireframeColor.x * 255),
            static_cast<int>(m_ctx.uvWireframeColor.y * 255),
            static_cast<int>(m_ctx.uvWireframeColor.z * 255),
            255
        );
        ImU32 selectFillColor = IM_COL32(51, 102, 255, 100);
        ImU32 selectEdgeColor = IM_COL32(0, 0, 0, 255);  // Always black for selected edges

        // Draw UV wireframe
        for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
            auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
            if (faceVerts.size() < 3) continue;

            bool isSelected = m_ctx.uvSelectedFaces.count(faceIdx) > 0;

            std::vector<ImVec2> screenPts;
            for (uint32_t vertIdx : faceVerts) {
                glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
                ImVec2 pt(offsetX + uv.x * texSize, offsetY + (1.0f - uv.y) * texSize);
                screenPts.push_back(pt);
            }

            if (isSelected && screenPts.size() >= 3) {
                for (size_t i = 1; i + 1 < screenPts.size(); ++i) {
                    drawList->AddTriangleFilled(screenPts[0], screenPts[i], screenPts[i + 1], selectFillColor);
                }
            }

            ImU32 edgeColor = isSelected ? selectEdgeColor : wireColor;
            float thickness = isSelected ? 2.0f : 1.0f;

            for (size_t i = 0; i < screenPts.size(); ++i) {
                size_t next = (i + 1) % screenPts.size();
                drawList->AddLine(screenPts[i], screenPts[next], edgeColor, thickness);
            }
        }

        // Draw selected edge and twins
        if (m_ctx.uvEdgeSelectionMode && m_ctx.uvSelectedEdge.first != UINT32_MAX) {
            ImU32 selectedEdgeCol = IM_COL32(255, 200, 50, 255);
            ImU32 twinEdgeCol = IM_COL32(50, 255, 150, 255);

            auto [selUV0, selUV1] = getEdgeUVs(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);
            ImVec2 selPt0(offsetX + selUV0.x * texSize, offsetY + (1.0f - selUV0.y) * texSize);
            ImVec2 selPt1(offsetX + selUV1.x * texSize, offsetY + (1.0f - selUV1.y) * texSize);
            drawList->AddLine(selPt0, selPt1, selectedEdgeCol, 3.0f);
            drawList->AddCircleFilled(selPt0, 4.0f, selectedEdgeCol);
            drawList->AddCircleFilled(selPt1, 4.0f, selectedEdgeCol);

            for (const auto& [twinFaceIdx, twinEdgeIdx] : m_ctx.uvTwinEdges) {
                auto [twinUV0, twinUV1] = getEdgeUVs(twinFaceIdx, twinEdgeIdx);
                ImVec2 twinPt0(offsetX + twinUV0.x * texSize, offsetY + (1.0f - twinUV0.y) * texSize);
                ImVec2 twinPt1(offsetX + twinUV1.x * texSize, offsetY + (1.0f - twinUV1.y) * texSize);
                drawList->AddLine(twinPt0, twinPt1, twinEdgeCol, 3.0f);
                drawList->AddCircleFilled(twinPt0, 4.0f, twinEdgeCol);
                drawList->AddCircleFilled(twinPt1, 4.0f, twinEdgeCol);
            }
        }

        // Draw UV vertices (only in vertex selection mode = 3)
        if (m_ctx.uvSelectionMode == 3) {
            ImU32 vertColor = IM_COL32(100, 100, 100, 200);
            ImU32 selectedVertColor = IM_COL32(255, 200, 50, 255);
            ImU32 sharedVertColor = IM_COL32(50, 200, 255, 255);  // Cyan for shared vertices
            float vertRadius = 4.0f;

            // Find shared vertices (same 3D position as selected, different UV)
            std::set<uint32_t> sharedVerts;
            if (!m_ctx.uvSelectedVertices.empty()) {
                for (uint32_t selVertIdx : m_ctx.uvSelectedVertices) {
                    glm::vec3 selPos = m_ctx.editableMesh.getVertex(selVertIdx).position;
                    // Find other vertices at same 3D position
                    for (uint32_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                        if (i == selVertIdx) continue;
                        if (m_ctx.uvSelectedVertices.count(i) > 0) continue;
                        glm::vec3 pos = m_ctx.editableMesh.getVertex(i).position;
                        if (glm::length(pos - selPos) < 0.0001f) {
                            sharedVerts.insert(i);
                        }
                    }
                }
            }

            // Draw all vertices as small dots
            std::set<uint32_t> drawnVerts;
            for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
                auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
                for (uint32_t vertIdx : faceVerts) {
                    if (drawnVerts.count(vertIdx) > 0) continue;
                    drawnVerts.insert(vertIdx);

                    glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
                    ImVec2 pt(offsetX + uv.x * texSize, offsetY + (1.0f - uv.y) * texSize);

                    bool isSelected = m_ctx.uvSelectedVertices.count(vertIdx) > 0;
                    bool isShared = sharedVerts.count(vertIdx) > 0;
                    if (isSelected) {
                        drawList->AddCircleFilled(pt, vertRadius + 2.0f, selectedVertColor);
                    } else if (isShared) {
                        drawList->AddCircleFilled(pt, vertRadius + 1.0f, sharedVertColor);
                        drawList->AddCircle(pt, vertRadius + 3.0f, sharedVertColor, 0, 1.5f);
                    } else {
                        drawList->AddCircleFilled(pt, vertRadius, vertColor);
                    }
                }
            }
        }

        // Selection bounding box
        if (!m_ctx.uvSelectedFaces.empty()) {
            glm::vec2 selMin, selMax;
            getUVSelectionBounds(selMin, selMax);
            ImVec2 boxMin(offsetX + selMin.x * texSize, offsetY + (1.0f - selMax.y) * texSize);
            ImVec2 boxMax(offsetX + selMax.x * texSize, offsetY + (1.0f - selMin.y) * texSize);
            drawList->AddRect(boxMin, boxMax, IM_COL32(255, 200, 50, 255), 0.0f, 0, 2.0f);

            if (m_ctx.uvScaling || m_ctx.uvRotating) {
                ImVec2 centerScreen(offsetX + m_ctx.uvScaleCenter.x * texSize,
                                    offsetY + (1.0f - m_ctx.uvScaleCenter.y) * texSize);
                ImU32 pivotColor = m_ctx.uvRotating ? IM_COL32(100, 200, 255, 255) : IM_COL32(255, 100, 100, 255);
                drawList->AddCircleFilled(centerScreen, 5.0f, pivotColor);

                if (m_ctx.uvRotating) {
                    glm::vec2 currentUV = screenToUV(mousePos);
                    ImVec2 mouseScreen(offsetX + currentUV.x * texSize, offsetY + (1.0f - currentUV.y) * texSize);
                    drawList->AddLine(centerScreen, mouseScreen, IM_COL32(100, 200, 255, 200), 2.0f);
                }
            }
        }

        // UV space border
        drawList->AddRect(texMin, texMax, IM_COL32(200, 200, 200, 255), 0.0f, 0, 2.0f);

        // Brush preview when paint mode is active
        if (m_ctx.isPainting && isHovered && m_ctx.selectedObject) {
            glm::vec2 brushUV = screenToUV(mousePos);
            float brushScreenX = offsetX + brushUV.x * texSize;
            float brushScreenY = offsetY + (1.0f - brushUV.y) * texSize;
            float brushScreenRadius = m_ctx.paintRadius * texSize;

            ImU32 brushColor = IM_COL32(
                static_cast<int>(m_ctx.paintColor.r * 255),
                static_cast<int>(m_ctx.paintColor.g * 255),
                static_cast<int>(m_ctx.paintColor.b * 255),
                100
            );
            ImU32 brushOutline = IM_COL32(255, 255, 255, 200);

            if (m_ctx.squareBrush) {
                ImVec2 brushMin(brushScreenX - brushScreenRadius, brushScreenY - brushScreenRadius);
                ImVec2 brushMax(brushScreenX + brushScreenRadius, brushScreenY + brushScreenRadius);
                drawList->AddRectFilled(brushMin, brushMax, brushColor);
                drawList->AddRect(brushMin, brushMax, brushOutline, 0.0f, 0, 1.5f);
            } else {
                drawList->AddCircleFilled(ImVec2(brushScreenX, brushScreenY), brushScreenRadius, brushColor, 32);
                drawList->AddCircle(ImVec2(brushScreenX, brushScreenY), brushScreenRadius, brushOutline, 32, 1.5f);
            }
        }

        drawList->PopClipRect();
        ImGui::EndChild();

        // Status
        ImGui::Text("Zoom: %.1fx | Faces: %zu", m_ctx.uvZoom, m_ctx.editableMesh.getFaceCount());
        if (m_ctx.uvEdgeSelectionMode) {
            if (m_ctx.uvSelectedEdge.first != UINT32_MAX) {
                ImGui::SameLine();
                ImGui::TextColored(ImVec4(1.0f, 0.8f, 0.2f, 1.0f), "| Edge selected");
                if (!m_ctx.uvTwinEdges.empty()) {
                    ImGui::SameLine();
                    ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.6f, 1.0f), "| %zu twin(s)", m_ctx.uvTwinEdges.size());
                }
            }
        } else if (!m_ctx.uvSelectedFaces.empty()) {
            ImGui::SameLine();
            ImGui::TextColored(ImVec4(0.3f, 0.6f, 1.0f, 1.0f), "| UV Selected: %zu", m_ctx.uvSelectedFaces.size());
        }
        if (m_ctx.uvScaling) {
            ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.2f, 1.0f), "SCALING - Click to confirm, Esc to cancel");
        } else if (m_ctx.uvRotating) {
            ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "ROTATING - Click to confirm, Esc to cancel");
        } else if (m_ctx.uvDraggingSelection) {
            ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.2f, 1.0f), "MOVING...");
        } else if (m_ctx.isPainting) {
            ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.6f, 1.0f), "LMB: paint on texture | MMB: pan");
        } else if (m_ctx.uvEdgeSelectionMode) {
            ImGui::TextDisabled("W: sew | Shift+W: move+sew | U: unsew | MMB: pan");
        } else {
            ImGui::TextDisabled("Click: select | Drag: move | S: scale | R: rotate | MMB: pan");
        }
    }
    ImGui::End();
}

void ModelingMode::renderImageRefWindow() {
    ImGui::SetNextWindowSize(ImVec2(400, 450), ImGuiCond_FirstUseEver);

    if (ImGui::Begin("Image References", &m_ctx.showImageRefWindow)) {
        // Load image button
        if (ImGui::Button("Load Image...")) {
            nfdchar_t* outPath = nullptr;
            nfdfilteritem_t filters[1] = {{"Image", "png,jpg,jpeg,bmp,tga"}};
            if (NFD_OpenDialog(&outPath, filters, 1, nullptr) == NFD_OKAY) {
                int w, h, channels;
                unsigned char* data = stbi_load(outPath, &w, &h, &channels, 4);
                if (data) {
                    // Reserve space to prevent reallocation invalidating existing textures
                    if (m_ctx.cloneSourceImages.size() == m_ctx.cloneSourceImages.capacity()) {
                        m_ctx.cloneSourceImages.reserve(m_ctx.cloneSourceImages.capacity() + 10);
                    }

                    // Create and add the new image
                    m_ctx.cloneSourceImages.emplace_back();
                    auto& img = m_ctx.cloneSourceImages.back();
                    img.filepath = outPath;
                    // Extract filename for display name
                    std::string path = outPath;
                    size_t lastSlash = path.find_last_of("/\\");
                    img.name = (lastSlash != std::string::npos) ? path.substr(lastSlash + 1) : path;
                    img.width = w;
                    img.height = h;
                    img.pixelData.assign(data, data + w * h * 4);
                    stbi_image_free(data);

                    // Create Vulkan texture for the new image
                    if (m_ctx.createCloneImageTextureCallback) {
                        m_ctx.createCloneImageTextureCallback(img);
                    }

                    std::cout << "Loaded image " << m_ctx.cloneSourceImages.size()
                              << ": " << w << "x" << h
                              << " descriptor=" << img.descriptorSet << std::endl;
                }
                NFD_FreePath(outPath);
            }
        }

        // Image list
        ImGui::SameLine();
        ImGui::TextDisabled("(%d images)", static_cast<int>(m_ctx.cloneSourceImages.size()));

        if (m_ctx.cloneSourceImages.empty()) {
            ImGui::TextDisabled("No images loaded. Click 'Load Image...' to add.");
        } else {
            // Tabs for each loaded image
            if (ImGui::BeginTabBar("ImageTabs")) {
                for (size_t i = 0; i < m_ctx.cloneSourceImages.size(); ++i) {
                    auto& img = m_ctx.cloneSourceImages[i];

                    // Use index-based unique ID for tab
                    ImGui::PushID(static_cast<int>(i));
                    bool open = true;
                    if (ImGui::BeginTabItem(img.name.c_str(), &open)) {
                        m_ctx.imageRefSelectedIndex = static_cast<int>(i);

                        // Image info
                        ImGui::TextDisabled("%dx%d", img.width, img.height);
                        ImGui::SameLine();
                        ImGui::Text("Zoom: %.0f%%", m_ctx.imageRefZoom * 100.0f);
                        ImGui::SameLine();
                        if (ImGui::Button("Reset View")) {
                            m_ctx.imageRefZoom = 1.0f;
                            m_ctx.imageRefPan = glm::vec2(0.0f);
                        }

                        ImGui::Separator();

                        // Image display area with pan/zoom
                        ImVec2 canvasSize = ImGui::GetContentRegionAvail();
                        canvasSize.y = std::max(canvasSize.y, 200.0f);

                        ImVec2 canvasPos = ImGui::GetCursorScreenPos();
                        ImDrawList* drawList = ImGui::GetWindowDrawList();

                        // Background
                        drawList->AddRectFilled(canvasPos,
                            ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y),
                            IM_COL32(40, 40, 40, 255));

                        // Calculate image display rect with zoom and pan
                        float imgAspect = static_cast<float>(img.width) / img.height;
                        float canvasAspect = canvasSize.x / canvasSize.y;

                        float displayW, displayH;
                        if (imgAspect > canvasAspect) {
                            displayW = canvasSize.x * m_ctx.imageRefZoom;
                            displayH = displayW / imgAspect;
                        } else {
                            displayH = canvasSize.y * m_ctx.imageRefZoom;
                            displayW = displayH * imgAspect;
                        }

                        float imgX = canvasPos.x + (canvasSize.x - displayW) * 0.5f + m_ctx.imageRefPan.x;
                        float imgY = canvasPos.y + (canvasSize.y - displayH) * 0.5f + m_ctx.imageRefPan.y;

                        // Draw the actual image if texture is loaded
                        if (img.descriptorSet) {
                            // Clip to canvas bounds
                            drawList->PushClipRect(canvasPos,
                                ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), true);

                            drawList->AddImage(
                                (ImTextureID)img.descriptorSet,
                                ImVec2(imgX, imgY),
                                ImVec2(imgX + displayW, imgY + displayH)
                            );

                            drawList->PopClipRect();
                        } else {
                            // Fallback: show placeholder text if texture not ready
                            ImVec2 textPos(canvasPos.x + 10, canvasPos.y + canvasSize.y / 2 - 10);
                            drawList->AddText(textPos, IM_COL32(200, 200, 200, 255),
                                ("Loading: " + std::to_string(img.width) + "x" + std::to_string(img.height)).c_str());
                        }

                        // Border
                        drawList->AddRect(canvasPos,
                            ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y),
                            IM_COL32(80, 80, 80, 255));

                        // Invisible button for interaction (unique ID per tab)
                        ImGui::SetCursorScreenPos(canvasPos);
                        ImGui::PushID(static_cast<int>(i));
                        ImGui::InvisibleButton("##imageCanvas", canvasSize);
                        ImGui::PopID();

                        bool isHovered = ImGui::IsItemHovered();

                        // Pan with MMB
                        if (isHovered && ImGui::IsMouseDown(ImGuiMouseButton_Middle)) {
                            ImVec2 delta = ImGui::GetIO().MouseDelta;
                            m_ctx.imageRefPan.x += delta.x;
                            m_ctx.imageRefPan.y += delta.y;
                        }

                        // Zoom with mousewheel
                        if (isHovered) {
                            float wheel = ImGui::GetIO().MouseWheel;
                            if (wheel != 0.0f) {
                                float zoomFactor = 1.0f + wheel * 0.1f;
                                m_ctx.imageRefZoom = std::clamp(m_ctx.imageRefZoom * zoomFactor, 0.1f, 10.0f);
                            }
                        }

                        // Shift+Drag to select rectangle for stamp
                        if (isHovered && ImGui::IsMouseClicked(ImGuiMouseButton_Left) && ImGui::GetIO().KeyShift) {
                            ImVec2 mousePos = ImGui::GetMousePos();
                            float relX = std::clamp((mousePos.x - imgX) / displayW, 0.0f, 1.0f);
                            float relY = std::clamp((mousePos.y - imgY) / displayH, 0.0f, 1.0f);

                            m_stampSelectStart = glm::vec2(relX * img.width, relY * img.height);
                            m_stampSelectEnd = m_stampSelectStart;
                            m_stampSelectImageIdx = static_cast<int>(i);
                            m_stampSelecting = true;
                        }

                        // Update selection while dragging
                        if (m_stampSelecting && m_stampSelectImageIdx == static_cast<int>(i) && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                            ImVec2 mousePos = ImGui::GetMousePos();
                            float relX = std::clamp((mousePos.x - imgX) / displayW, 0.0f, 1.0f);
                            float relY = std::clamp((mousePos.y - imgY) / displayH, 0.0f, 1.0f);
                            m_stampSelectEnd = glm::vec2(relX * img.width, relY * img.height);
                        }

                        // Finish selection and create stamp
                        if (m_stampSelecting && m_stampSelectImageIdx == static_cast<int>(i) && ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
                            m_stampSelecting = false;

                            // Calculate selection bounds
                            int x1 = static_cast<int>(std::min(m_stampSelectStart.x, m_stampSelectEnd.x));
                            int y1 = static_cast<int>(std::min(m_stampSelectStart.y, m_stampSelectEnd.y));
                            int x2 = static_cast<int>(std::max(m_stampSelectStart.x, m_stampSelectEnd.x));
                            int y2 = static_cast<int>(std::max(m_stampSelectStart.y, m_stampSelectEnd.y));

                            int selW = x2 - x1;
                            int selH = y2 - y1;

                            if (selW > 2 && selH > 2 && !img.pixelData.empty()) {
                                // Extract pixels from source image
                                m_ctx.stampData.resize(selW * selH * 4);
                                m_ctx.stampWidth = selW;
                                m_ctx.stampHeight = selH;

                                for (int sy = 0; sy < selH; sy++) {
                                    for (int sx = 0; sx < selW; sx++) {
                                        int srcX = x1 + sx;
                                        int srcY = y1 + sy;

                                        if (srcX >= 0 && srcX < img.width && srcY >= 0 && srcY < img.height) {
                                            size_t srcIdx = (srcY * img.width + srcX) * 4;
                                            size_t dstIdx = (sy * selW + sx) * 4;

                                            if (srcIdx + 3 < img.pixelData.size()) {
                                                m_ctx.stampData[dstIdx] = img.pixelData[srcIdx];
                                                m_ctx.stampData[dstIdx + 1] = img.pixelData[srcIdx + 1];
                                                m_ctx.stampData[dstIdx + 2] = img.pixelData[srcIdx + 2];
                                                m_ctx.stampData[dstIdx + 3] = img.pixelData[srcIdx + 3];
                                            }
                                        }
                                    }
                                }

                                // Defer stamp preview update to next frame
                                m_pendingStampPreviewUpdate = true;

                                // Switch to stamp mode
                                m_ctx.useStamp = true;
                                m_ctx.useSmear = false;

                                std::cout << "Created stamp from selection: " << selW << "x" << selH << std::endl;
                            }
                        }

                        // Draw selection rectangle while selecting
                        if (m_stampSelecting && m_stampSelectImageIdx == static_cast<int>(i)) {
                            float rx1 = imgX + (std::min(m_stampSelectStart.x, m_stampSelectEnd.x) / img.width) * displayW;
                            float ry1 = imgY + (std::min(m_stampSelectStart.y, m_stampSelectEnd.y) / img.height) * displayH;
                            float rx2 = imgX + (std::max(m_stampSelectStart.x, m_stampSelectEnd.x) / img.width) * displayW;
                            float ry2 = imgY + (std::max(m_stampSelectStart.y, m_stampSelectEnd.y) / img.height) * displayH;

                            drawList->AddRect(ImVec2(rx1, ry1), ImVec2(rx2, ry2), IM_COL32(255, 255, 0, 255), 0.0f, 0, 2.0f);
                            drawList->AddRectFilled(ImVec2(rx1, ry1), ImVec2(rx2, ry2), IM_COL32(255, 255, 0, 50));
                        }

                        // Alt+Click to sample color from image reference
                        if (isHovered && ImGui::IsMouseClicked(ImGuiMouseButton_Left) && ImGui::GetIO().KeyAlt) {
                            ImVec2 mousePos = ImGui::GetMousePos();

                            // Convert screen position to image pixel coordinates
                            float relX = (mousePos.x - imgX) / displayW;
                            float relY = (mousePos.y - imgY) / displayH;

                            // Clamp to valid range
                            relX = std::clamp(relX, 0.0f, 1.0f);
                            relY = std::clamp(relY, 0.0f, 1.0f);

                            // Convert to pixel coordinates
                            int px = static_cast<int>(relX * img.width);
                            int py = static_cast<int>(relY * img.height);
                            px = std::clamp(px, 0, img.width - 1);
                            py = std::clamp(py, 0, img.height - 1);

                            // Sample color from image
                            size_t pixelIdx = (py * img.width + px) * 4;
                            if (pixelIdx + 2 < img.pixelData.size()) {
                                m_ctx.paintColor.r = img.pixelData[pixelIdx] / 255.0f;
                                m_ctx.paintColor.g = img.pixelData[pixelIdx + 1] / 255.0f;
                                m_ctx.paintColor.b = img.pixelData[pixelIdx + 2] / 255.0f;

                                std::cout << "Sampled color from " << img.name << " at (" << px << ", " << py << "): "
                                          << "RGB(" << static_cast<int>(m_ctx.paintColor.r * 255) << ", "
                                          << static_cast<int>(m_ctx.paintColor.g * 255) << ", "
                                          << static_cast<int>(m_ctx.paintColor.b * 255) << ")" << std::endl;
                            }
                        }

                        ImGui::EndTabItem();
                    }

                    ImGui::PopID();

                    // Handle tab close - mark for deletion (don't delete during iteration)
                    if (!open) {
                        m_pendingCloneImageDelete = static_cast<int>(i);
                    }
                }
                ImGui::EndTabBar();
            }

            // Note: deletion is deferred to update() to avoid ImGui draw list issues
        }

        ImGui::Separator();

        ImGui::TextDisabled("MMB: Pan | Scroll: Zoom");
        ImGui::TextDisabled("Alt+Click: Clone source | Shift+Drag: Create stamp");
        if (m_ctx.cloneSourceSet && m_ctx.cloneSourceViewIndex >= 0 &&
            m_ctx.cloneSourceViewIndex < static_cast<int>(m_ctx.cloneSourceImages.size())) {
            ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f), "Clone source: %s (%.0f, %.0f)",
                m_ctx.cloneSourceImages[m_ctx.cloneSourceViewIndex].name.c_str(),
                m_ctx.cloneSourcePixel.x, m_ctx.cloneSourcePixel.y);
        } else {
            ImGui::TextDisabled("Alt+Click on image to set clone source");
        }
    }
    ImGui::End();
}

void ModelingMode::processModelingInput(float deltaTime, bool gizmoActive) {
    // Use IsWindowHovered for mouse-over detection
    bool mouseOverImGui = ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow);

    // Tab key ALWAYS toggles between object mode and component mode
    // Handle this BEFORE WantCaptureKeyboard check so Tab never goes to ImGui
    ImGui::GetIO().AddKeyEvent(ImGuiKey_Tab, false);  // Clear Tab from ImGui first
    if (Input::isKeyPressed(Input::KEY_TAB)) {
        m_ctx.objectMode = !m_ctx.objectMode;
        m_modeNotificationTimer = 1.0f;  // Show notification for 1 second
        // Clear selections when switching modes
        if (m_ctx.objectMode) {
            m_ctx.editableMesh.clearSelection();
        }
    }

    if (ImGui::GetIO().WantCaptureKeyboard) return;

    // ESC cancels snap mode
    if (Input::isKeyPressed(Input::KEY_ESCAPE) && m_snapMode) {
        cancelSnapMode();
        return;
    }

    // Select mode (Q key) - no gizmo
    if (Input::isKeyPressed(Input::KEY_Q)) {
        m_ctx.gizmoMode = GizmoMode::None;
    }

    // Move gizmo toggle (W key)
    if (Input::isKeyPressed(Input::KEY_W)) {
        m_ctx.gizmoMode = GizmoMode::Move;
    }

    // Rotate gizmo toggle (E key)
    if (Input::isKeyPressed(Input::KEY_E) && !Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {
        m_ctx.gizmoMode = GizmoMode::Rotate;
    }

    // Scale gizmo toggle (R key) - only when not Ctrl (Ctrl+R is edge loop)
    if (Input::isKeyPressed(Input::KEY_R) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
        m_ctx.gizmoMode = GizmoMode::Scale;
    }

    // Delete key in object mode - delete selected objects
    if (Input::isKeyPressed(Input::KEY_DELETE) && m_ctx.objectMode) {
        if (!m_ctx.selectedObjects.empty()) {
            // Queue selected objects for deletion
            for (SceneObject* obj : m_ctx.selectedObjects) {
                m_ctx.pendingDeletions.push_back(obj);
            }
            // Clear selection
            m_ctx.selectedObject = nullptr;
            m_ctx.selectedObjects.clear();
            m_ctx.editableMesh.clear();
            m_ctx.meshDirty = false;
            std::cout << "[Delete] Queued " << m_ctx.pendingDeletions.size() << " object(s) for deletion" << std::endl;
        } else if (m_ctx.selectedObject) {
            // Delete single selected object
            m_ctx.pendingDeletions.push_back(m_ctx.selectedObject);
            m_ctx.selectedObject = nullptr;
            m_ctx.editableMesh.clear();
            m_ctx.meshDirty = false;
            std::cout << "[Delete] Queued 1 object for deletion" << std::endl;
        }
    }

    // Paint mode toggle (P key)
    if (Input::isKeyPressed(Input::KEY_P)) {
        if (m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData()) {
            m_ctx.isPainting = !m_ctx.isPainting;
        }
    }

    // Vertex paint mode toggle (V key)
    bool ctrlHeldV = Input::isKeyDown(Input::KEY_LEFT_CONTROL) || Input::isKeyDown(Input::KEY_RIGHT_CONTROL);
    if (Input::isKeyPressed(Input::KEY_V) && !ctrlHeldV) {
        m_vertexPaintMode = !m_vertexPaintMode;
        if (m_vertexPaintMode) {
            // Turn off texture paint mode when enabling vertex paint
            m_ctx.isPainting = false;
        }
    }

    // Eyedropper: Alt + Click to sample color from model or reference image (works in paint mode)
    bool altHeld = Input::isKeyDown(Input::KEY_LEFT_ALT) || Input::isKeyDown(Input::KEY_RIGHT_ALT);
    m_ctx.useEyedropper = altHeld && m_ctx.isPainting;  // Eyedropper active when Alt held in paint mode

    if (m_ctx.useEyedropper && Input::isMouseButtonPressed(Input::MOUSE_LEFT) && !mouseOverImGui && !gizmoActive) {
        bool sampled = false;

        // First, try to sample from reference image in ortho view
        Camera& activeCamera = m_ctx.getActiveCamera();
        if (activeCamera.getProjectionMode() == ProjectionMode::Orthographic) {
            ViewPreset preset = activeCamera.getViewPreset();
            if (preset != ViewPreset::Custom) {
                int viewIndex = static_cast<int>(preset) - 1;
                if (viewIndex >= 0 && viewIndex < 6) {
                    auto& ref = m_ctx.referenceImages[viewIndex];
                    if (ref.visible && ref.loaded && !ref.pixelData.empty()) {
                        // Get viewport dimensions
                        float screenWidth = static_cast<float>(m_ctx.window.getWidth());
                        float screenHeight = static_cast<float>(m_ctx.window.getHeight());
                        float vpX = 0, vpY = 0, vpW = screenWidth, vpH = screenHeight;
                        if (m_ctx.splitView) {
                            if (m_ctx.activeViewportLeft) {
                                vpW = screenWidth / 2.0f;
                            } else {
                                vpX = screenWidth / 2.0f;
                                vpW = screenWidth / 2.0f;
                            }
                        }

                        // Calculate reference image screen bounds (same logic as drawReferenceImages)
                        float orthoSize = activeCamera.getOrthoSize();
                        float aspect = vpW / vpH;
                        glm::mat4 view = activeCamera.getViewMatrix();
                        glm::mat4 proj = glm::ortho(-orthoSize * aspect, orthoSize * aspect, -orthoSize, orthoSize, -1000.0f, 1000.0f);
                        glm::mat4 viewProj = proj * view;

                        glm::vec3 right, up, depthOffset;
                        float gridEdge = 10.0f;
                        switch (preset) {
                            case ViewPreset::Top:    right = glm::vec3(1,0,0); up = glm::vec3(0,0,-1); depthOffset = glm::vec3(0,-0.1f,0); break;
                            case ViewPreset::Bottom: right = glm::vec3(1,0,0); up = glm::vec3(0,0,1);  depthOffset = glm::vec3(0,0.1f,0); break;
                            case ViewPreset::Front:  right = glm::vec3(1,0,0); up = glm::vec3(0,1,0);  depthOffset = glm::vec3(0,0,-gridEdge); break;
                            case ViewPreset::Back:   right = glm::vec3(-1,0,0); up = glm::vec3(0,1,0); depthOffset = glm::vec3(0,0,gridEdge); break;
                            case ViewPreset::Right:  right = glm::vec3(0,0,-1); up = glm::vec3(0,1,0); depthOffset = glm::vec3(-gridEdge,0,0); break;
                            case ViewPreset::Left:   right = glm::vec3(0,0,1); up = glm::vec3(0,1,0);  depthOffset = glm::vec3(gridEdge,0,0); break;
                            default: break;
                        }

                        glm::vec3 center = depthOffset + right * ref.offset.x + up * ref.offset.y;
                        glm::vec3 corners[4] = {
                            center - right * (ref.size.x * 0.5f) - up * (ref.size.y * 0.5f),
                            center + right * (ref.size.x * 0.5f) - up * (ref.size.y * 0.5f),
                            center + right * (ref.size.x * 0.5f) + up * (ref.size.y * 0.5f),
                            center - right * (ref.size.x * 0.5f) + up * (ref.size.y * 0.5f)
                        };

                        // Project corners to screen
                        ImVec2 screenCorners[4];
                        for (int i = 0; i < 4; i++) {
                            glm::vec4 clip = viewProj * glm::vec4(corners[i], 1.0f);
                            glm::vec2 ndc = glm::vec2(clip.x, clip.y) / clip.w;
                            screenCorners[i].x = vpX + (ndc.x * 0.5f + 0.5f) * vpW;
                            screenCorners[i].y = vpY + (1.0f - (ndc.y * 0.5f + 0.5f)) * vpH;
                        }

                        // Check if mouse is inside the reference image quad
                        ImVec2 imMousePos = ImGui::GetMousePos();
                        float mx = imMousePos.x;
                        float my = imMousePos.y;

                        // Calculate UV within reference image (0-1 range)
                        float minX = std::min({screenCorners[0].x, screenCorners[1].x, screenCorners[2].x, screenCorners[3].x});
                        float maxX = std::max({screenCorners[0].x, screenCorners[1].x, screenCorners[2].x, screenCorners[3].x});
                        float minY = std::min({screenCorners[0].y, screenCorners[1].y, screenCorners[2].y, screenCorners[3].y});
                        float maxY = std::max({screenCorners[0].y, screenCorners[1].y, screenCorners[2].y, screenCorners[3].y});

                        if (mx >= minX && mx <= maxX && my >= minY && my <= maxY) {
                            // Calculate normalized position within image
                            float u = (static_cast<float>(mx) - minX) / (maxX - minX);
                            float v = (static_cast<float>(my) - minY) / (maxY - minY);

                            // Convert to pixel coordinates
                            int px = static_cast<int>(u * ref.imageWidth);
                            int py = static_cast<int>(v * ref.imageHeight);
                            px = std::clamp(px, 0, ref.imageWidth - 1);
                            py = std::clamp(py, 0, ref.imageHeight - 1);

                            // Sample color from reference image
                            size_t idx = (py * ref.imageWidth + px) * 4;
                            if (idx + 2 < ref.pixelData.size()) {
                                m_ctx.paintColor = glm::vec3(
                                    ref.pixelData[idx] / 255.0f,
                                    ref.pixelData[idx + 1] / 255.0f,
                                    ref.pixelData[idx + 2] / 255.0f
                                );
                                sampled = true;
                                std::cout << "Sampled from reference: RGB("
                                          << static_cast<int>(ref.pixelData[idx]) << ", "
                                          << static_cast<int>(ref.pixelData[idx + 1]) << ", "
                                          << static_cast<int>(ref.pixelData[idx + 2]) << ")" << std::endl;
                            }
                        }
                    }
                }
            }
        }

        // If not sampled from reference, try model texture
        if (!sampled && m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData()) {
            glm::vec3 rayOrigin, rayDir;
            m_ctx.getMouseRay(rayOrigin, rayDir);

            auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
            if (hit.hit) {
                auto& texData = m_ctx.selectedObject->getTextureData();
                int texW = m_ctx.selectedObject->getTextureWidth();
                int texH = m_ctx.selectedObject->getTextureHeight();

                float uvX = hit.uv.x - std::floor(hit.uv.x);
                float uvY = hit.uv.y - std::floor(hit.uv.y);
                int px = static_cast<int>(uvX * texW);
                int py = static_cast<int>(uvY * texH);
                px = std::clamp(px, 0, texW - 1);
                py = std::clamp(py, 0, texH - 1);

                size_t idx = (py * texW + px) * 4;
                if (idx + 2 < texData.size()) {
                    m_ctx.paintColor = glm::vec3(
                        texData[idx] / 255.0f,
                        texData[idx + 1] / 255.0f,
                        texData[idx + 2] / 255.0f
                    );
                    sampled = true;
                    std::cout << "Sampled from model: RGB("
                              << static_cast<int>(texData[idx]) << ", "
                              << static_cast<int>(texData[idx + 1]) << ", "
                              << static_cast<int>(texData[idx + 2]) << ")" << std::endl;
                }
            }
        }
    }

    // Color sampling from model texture: Alt + Click on model
    if (altHeld && m_ctx.isPainting && m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData() &&
        Input::isMouseButtonPressed(Input::MOUSE_LEFT) && !mouseOverImGui && !gizmoActive) {
        glm::vec3 rayOrigin, rayDir;
        m_ctx.getMouseRay(rayOrigin, rayDir);

        auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
        if (hit.hit) {
            // Sample color from model texture at hit UV
            int texW = m_ctx.selectedObject->getTextureWidth();
            int texH = m_ctx.selectedObject->getTextureHeight();
            auto& texData = m_ctx.selectedObject->getTextureData();

            float uvX = hit.uv.x - std::floor(hit.uv.x);
            float uvY = hit.uv.y - std::floor(hit.uv.y);
            int px = static_cast<int>(uvX * texW);
            int py = static_cast<int>(uvY * texH);
            px = std::clamp(px, 0, texW - 1);
            py = std::clamp(py, 0, texH - 1);

            size_t pixelIdx = (py * texW + px) * 4;
            if (pixelIdx + 2 < texData.size()) {
                m_ctx.paintColor.r = texData[pixelIdx] / 255.0f;
                m_ctx.paintColor.g = texData[pixelIdx + 1] / 255.0f;
                m_ctx.paintColor.b = texData[pixelIdx + 2] / 255.0f;

                std::cout << "Sampled color from model at UV (" << uvX << ", " << uvY << "): RGB("
                          << static_cast<int>(m_ctx.paintColor.r * 255) << ", "
                          << static_cast<int>(m_ctx.paintColor.g * 255) << ", "
                          << static_cast<int>(m_ctx.paintColor.b * 255) << ")" << std::endl;
            }
        }
    }

    // Handle painting when in paint mode
    bool paintedThisFrame = false;
    static bool wasPaintingLastFrame = false;
    if (m_ctx.isPainting && m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData()) {
        // Stamp mode: single click to stamp
        if (m_ctx.useStamp && !m_ctx.stampData.empty()) {
            // Handle click to stamp
            if (Input::isMouseButtonPressed(Input::MOUSE_LEFT) && !mouseOverImGui && !gizmoActive) {
                glm::vec3 rayOrigin, rayDir;
                m_ctx.getMouseRay(rayOrigin, rayDir);

                auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
                if (hit.hit) {
                    // Clear any preview first (restore original texture)
                    m_ctx.selectedObject->clearStampPreview();
                    // Save state before stamping (for undo)
                    m_ctx.selectedObject->saveTextureState();
                    // Stamp at UV coordinate (permanent)
                    m_ctx.selectedObject->stampAt(hit.uv, m_ctx.stampData.data(),
                                                   m_ctx.stampWidth, m_ctx.stampHeight,
                                                   m_ctx.stampScale * m_ctx.stampScaleH, m_ctx.stampScale * m_ctx.stampScaleV,
                                                   m_ctx.stampRotation, m_ctx.stampOpacity, m_ctx.stampFlipH, m_ctx.stampFlipV);
                    m_ctx.selectedObject->markTextureModified();
                    paintedThisFrame = true;
                }
            }
        }
        // Smear mode: drag to smear colors
        else if (m_ctx.useSmear && !altHeld && Input::isMouseButtonDown(Input::MOUSE_LEFT) && !mouseOverImGui && !gizmoActive) {
            glm::vec3 rayOrigin, rayDir;
            m_ctx.getMouseRay(rayOrigin, rayDir);

            auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
            if (hit.hit) {
                // Save texture state at start of stroke
                if (!m_ctx.isSmearing) {
                    m_ctx.selectedObject->saveTextureState();
                    // Sample initial color at starting point
                    size_t texW = m_ctx.selectedObject->getTextureWidth();
                    size_t texH = m_ctx.selectedObject->getTextureHeight();
                    auto& texData = m_ctx.selectedObject->getTextureData();
                    float uvX = hit.uv.x - std::floor(hit.uv.x);
                    float uvY = hit.uv.y - std::floor(hit.uv.y);
                    int px = static_cast<int>(uvX * texW);
                    int py = static_cast<int>(uvY * texH);
                    px = std::clamp(px, 0, static_cast<int>(texW - 1));
                    py = std::clamp(py, 0, static_cast<int>(texH - 1));
                    size_t idx = (py * texW + px) * 4;
                    if (idx + 2 < texData.size()) {
                        m_ctx.smearCarriedColor = glm::vec3(
                            texData[idx] / 255.0f,
                            texData[idx + 1] / 255.0f,
                            texData[idx + 2] / 255.0f
                        );
                    }
                    m_ctx.isSmearing = true;
                }

                // Smear and update carried color
                m_ctx.smearCarriedColor = m_ctx.selectedObject->smearAt(
                    hit.uv, m_ctx.smearCarriedColor, m_ctx.paintRadius, m_ctx.smearStrength, m_ctx.smearPickup);
                m_ctx.selectedObject->markTextureModified();
                paintedThisFrame = true;
            }
        }
        // Brush mode: continuous painting while dragging
        // Skip painting when Alt is held (Alt+click is for color sampling)
        else if (!m_ctx.useSmear && !altHeld && Input::isMouseButtonDown(Input::MOUSE_LEFT) && !mouseOverImGui && !gizmoActive) {
            // Get mouse ray
            glm::vec3 rayOrigin, rayDir;
            m_ctx.getMouseRay(rayOrigin, rayDir);

            // Raycast against selected object
            auto hit = m_ctx.selectedObject->raycast(rayOrigin, rayDir);
            if (hit.hit) {
                // Save texture state at start of stroke (first paint of this mouse press)
                if (!wasPaintingLastFrame) {
                    m_ctx.selectedObject->saveTextureState();
                }
                wasPaintingLastFrame = true;

                bool shiftHeld = Input::isKeyDown(Input::KEY_LEFT_SHIFT) || Input::isKeyDown(Input::KEY_RIGHT_SHIFT);

                // Line tool: Shift+Click draws line from last position
                if (shiftHeld && m_ctx.hasLastPaintPosition && Input::isMouseButtonPressed(Input::MOUSE_LEFT)) {
                    // Draw line from last paint position to current position
                    glm::vec2 startUV = m_ctx.lastPaintUV;
                    glm::vec2 endUV = hit.uv;

                    // Calculate distance in UV space and determine number of steps
                    float distance = glm::length(endUV - startUV);
                    int texSize = std::max(m_ctx.selectedObject->getTextureWidth(), m_ctx.selectedObject->getTextureHeight());
                    float stepSize = m_ctx.paintRadius * 0.5f;  // Paint every half-radius for smooth coverage
                    int steps = static_cast<int>(distance / stepSize) + 1;
                    if (steps < 2) steps = 2;

                    // Interpolate and paint along the line
                    for (int i = 0; i <= steps; i++) {
                        float t = static_cast<float>(i) / static_cast<float>(steps);
                        glm::vec2 uv = glm::mix(startUV, endUV, t);
                        m_ctx.selectedObject->paintAt(uv, m_ctx.paintColor, m_ctx.paintRadius, m_ctx.paintStrength, m_ctx.squareBrush);
                    }
                } else {
                    // Normal paint at UV coordinate
                    m_ctx.selectedObject->paintAt(hit.uv, m_ctx.paintColor, m_ctx.paintRadius, m_ctx.paintStrength, m_ctx.squareBrush);
                }

                // Store this position for line tool
                m_ctx.lastPaintUV = hit.uv;
                m_ctx.hasLastPaintPosition = true;

                m_ctx.selectedObject->markTextureModified();
                paintedThisFrame = true;  // Only block other input if we actually painted
            }
        } else {
            wasPaintingLastFrame = false;
            m_ctx.isSmearing = false;  // Reset smear state when not dragging
            m_ctx.clonePaintingActive = false;  // Reset clone tracking
        }

        // Upload modified texture to GPU (every frame while painting for live feedback)
        if (m_ctx.selectedObject->isTextureModified()) {
            uint32_t handle = m_ctx.selectedObject->getBufferHandle();
            auto& texData = m_ctx.selectedObject->getTextureData();
            int w = m_ctx.selectedObject->getTextureWidth();
            int h = m_ctx.selectedObject->getTextureHeight();
            m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
            m_ctx.selectedObject->clearTextureModified();
        }

        // Only block selection input if we actually painted on the model
        // This allows camera tumble when clicking on empty space
        if (paintedThisFrame) {
            return;
        }
    }

    // Mode switching (synchronized with UV editor)
    if (Input::isKeyPressed(Input::KEY_A) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
        m_ctx.modelingSelectionMode = ModelingSelectionMode::Vertex;
        m_ctx.uvSelectionMode = 3;  // Sync UV editor to vertex mode
        m_ctx.uvEdgeSelectionMode = false;
        m_ctx.editableMesh.clearSelection();
        m_ctx.uvSelectedFaces.clear();
        clearUVEdgeSelection();
    }
    if (Input::isKeyPressed(Input::KEY_S) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
        m_ctx.modelingSelectionMode = ModelingSelectionMode::Edge;
        m_ctx.uvSelectionMode = 2;  // Sync UV editor to edge mode
        m_ctx.uvEdgeSelectionMode = true;
        m_ctx.editableMesh.clearSelection();
        m_ctx.uvSelectedFaces.clear();
        m_ctx.uvSelectedVertices.clear();
    }
    if (Input::isKeyPressed(Input::KEY_D)) {
        m_ctx.modelingSelectionMode = ModelingSelectionMode::Face;
        m_ctx.uvSelectionMode = 1;  // Sync UV editor to face mode
        m_ctx.uvEdgeSelectionMode = false;
        m_ctx.editableMesh.clearSelection();
        clearUVEdgeSelection();
        m_ctx.uvSelectedVertices.clear();
    }

    // Selection tool shortcuts
    // C key (ASCII 67) for paint select
    if (Input::isKeyPressed(67) && !Input::isKeyDown(Input::KEY_LEFT_CONTROL)) {
        m_ctx.selectionTool = SelectionTool::Paint;
    }

    bool ctrlDown = Input::isKeyDown(Input::KEY_LEFT_CONTROL) || Input::isKeyDown(Input::KEY_RIGHT_CONTROL);
    bool shiftDown = Input::isKeyDown(Input::KEY_LEFT_SHIFT) || Input::isKeyDown(Input::KEY_RIGHT_SHIFT);

    // Undo (Ctrl+Z)
    if (Input::isKeyPressed(Input::KEY_Z) && ctrlDown && !shiftDown) {
        // In paint mode, try texture undo first
        if (m_ctx.isPainting && m_ctx.selectedObject && m_ctx.selectedObject->canUndoTexture()) {
            if (m_ctx.selectedObject->undoTexture()) {
                // Upload restored texture to GPU
                uint32_t handle = m_ctx.selectedObject->getBufferHandle();
                auto& texData = m_ctx.selectedObject->getTextureData();
                int w = m_ctx.selectedObject->getTextureWidth();
                int h = m_ctx.selectedObject->getTextureHeight();
                m_ctx.modelRenderer.updateTexture(handle, texData.data(), w, h);
                m_ctx.selectedObject->clearTextureModified();
            }
        } else if (m_ctx.editableMesh.undo()) {
            m_ctx.meshDirty = true;
        }
    }

    // Redo (Ctrl+Shift+Z)
    if (Input::isKeyPressed(Input::KEY_Z) && ctrlDown && shiftDown) {
        if (m_ctx.editableMesh.redo()) {
            m_ctx.meshDirty = true;
        }
    }

    // Save (Ctrl+S)
    if (Input::isKeyPressed(Input::KEY_S) && ctrlDown) {
        saveEditableMeshAsLime();
    }

    // Delete selected faces
    if (Input::isKeyPressed(Input::KEY_X) || Input::isKeyPressed(Input::KEY_DELETE)) {
        if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.deleteSelectedFaces();
            m_ctx.meshDirty = true;
        }
    }

    // Extrude faces (Shift+E)
    if (Input::isKeyPressed(Input::KEY_E) && Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {
        if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.extrudeSelectedFaces(m_ctx.extrudeDistance);
            m_ctx.meshDirty = true;
        }
    }

    // Merge vertices (Alt+M)
    if (Input::isKeyPressed(Input::KEY_M) && Input::isKeyDown(Input::KEY_LEFT_ALT)) {
        if (m_ctx.editableMesh.getSelectedVertices().size() >= 2) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.mergeSelectedVertices();
            m_ctx.meshDirty = true;
        }
    }

    // Insert edge loop (Ctrl+R)
    if (Input::isKeyPressed(Input::KEY_R) && ctrlDown) {
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        if (!selectedEdges.empty()) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.insertEdgeLoop(selectedEdges[0]);
            m_ctx.meshDirty = true;
        }
    }

    // Bridge edges (B)
    if (Input::isKeyPressed(Input::KEY_B) && !ctrlDown && !Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        if (selectedEdges.size() == 2) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.bridgeEdges(selectedEdges[0], selectedEdges[1], g_bridgeSegments);
            m_ctx.meshDirty = true;
        }
    }

    // Flip normals (N)
    if (Input::isKeyPressed(Input::KEY_N) && !ctrlDown && !Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {
        if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.flipSelectedNormals();
            m_ctx.meshDirty = true;
        }
    }

    // Inset faces (I)
    if (Input::isKeyPressed(Input::KEY_I) && !ctrlDown && !Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {
        if (!m_ctx.editableMesh.getSelectedFaces().empty()) {
            m_ctx.editableMesh.saveState();
            m_ctx.editableMesh.insetSelectedFaces(m_ctx.insetAmount);
            m_ctx.meshDirty = true;
        }
    }

    // Hollow mesh (H)
    if (Input::isKeyPressed(72) && !ctrlDown && !Input::isKeyDown(Input::KEY_LEFT_SHIFT)) {  // 72 = 'H'
        m_ctx.editableMesh.saveState();
        m_ctx.editableMesh.hollow(m_ctx.hollowThickness);
        m_ctx.meshDirty = true;
    }

    // Snap vertex mode - click to select vertices in order
    if (m_snapVertexMode && !mouseOverImGui && Input::isMouseButtonPressed(Input::MOUSE_LEFT)) {
        glm::vec3 rayOrigin, rayDir;
        m_ctx.getMouseRay(rayOrigin, rayDir);

        // Find closest vertex across all objects
        SceneObject* hitObject = nullptr;
        uint32_t hitVertexIdx = UINT32_MAX;
        glm::vec3 hitVertexWorldPos;
        float closestDist = std::numeric_limits<float>::max();
        const float vertexThreshold = 0.15f;  // Click radius for vertex selection

        for (auto& objPtr : m_ctx.sceneObjects) {
            SceneObject* obj = objPtr.get();
            if (!obj || !obj->hasEditableMeshData() || !obj->isVisible()) continue;

            glm::mat4 modelMatrix = obj->getTransform().getMatrix();
            const auto& heVerts = obj->getHEVertices();

            for (size_t vi = 0; vi < heVerts.size(); ++vi) {
                glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(heVerts[vi].position, 1.0f));

                // Project vertex to get distance from ray
                glm::vec3 toVert = worldPos - rayOrigin;
                float alongRay = glm::dot(toVert, rayDir);
                if (alongRay < 0) continue;  // Behind camera

                glm::vec3 closestOnRay = rayOrigin + rayDir * alongRay;
                float dist = glm::length(worldPos - closestOnRay);

                if (dist < vertexThreshold && alongRay < closestDist) {
                    closestDist = alongRay;
                    hitObject = obj;
                    hitVertexIdx = static_cast<uint32_t>(vi);
                    hitVertexWorldPos = worldPos;
                }
            }
        }

        if (hitObject && hitVertexIdx != UINT32_MAX) {
            // Determine if this is source or target based on current state
            bool isSourceSelection = (m_snapSrcObj == nullptr) ||
                                    (m_snapSrcObj == hitObject && m_snapDstObj == nullptr);

            // If we already have source verts and click on a different object, it's target
            if (m_snapSrcObj && hitObject != m_snapSrcObj) {
                isSourceSelection = false;
            }

            if (isSourceSelection) {
                // Adding to source
                if (m_snapSrcObj == nullptr) {
                    m_snapSrcObj = hitObject;
                }
                if (hitObject == m_snapSrcObj) {
                    // Check if vertex already selected
                    bool alreadySelected = false;
                    for (size_t i = 0; i < m_snapSrcVertIndices.size(); ++i) {
                        if (m_snapSrcVertIndices[i] == hitVertexIdx) {
                            alreadySelected = true;
                            break;
                        }
                    }
                    if (!alreadySelected) {
                        m_snapSrcVerts.push_back(hitVertexWorldPos);
                        m_snapSrcVertIndices.push_back(hitVertexIdx);
                        std::cout << "[Snap] Source vertex " << m_snapSrcVerts.size() << " selected" << std::endl;
                    }
                }
            } else {
                // Adding to target
                if (m_snapDstObj == nullptr) {
                    m_snapDstObj = hitObject;
                }
                if (hitObject == m_snapDstObj) {
                    // Check if vertex already selected
                    bool alreadySelected = false;
                    for (size_t i = 0; i < m_snapDstVertIndices.size(); ++i) {
                        if (m_snapDstVertIndices[i] == hitVertexIdx) {
                            alreadySelected = true;
                            break;
                        }
                    }
                    if (!alreadySelected) {
                        m_snapDstVerts.push_back(hitVertexWorldPos);
                        m_snapDstVertIndices.push_back(hitVertexIdx);
                        std::cout << "[Snap] Target vertex " << m_snapDstVerts.size() << " selected" << std::endl;
                    }
                }
            }
        }
    }

    // ESC cancels snap vertex mode
    if (m_snapVertexMode && Input::isKeyPressed(Input::KEY_ESCAPE)) {
        cancelSnapVertexMode();
    }

    // Snap mode face selection
    if (m_snapMode && !mouseOverImGui && Input::isMouseButtonPressed(Input::MOUSE_LEFT)) {
        glm::vec3 rayOrigin, rayDir;
        m_ctx.getMouseRay(rayOrigin, rayDir);

        // Raycast against all objects to find clicked face
        SceneObject* hitObject = nullptr;
        int hitFace = -1;
        float closestDist = std::numeric_limits<float>::max();

        for (auto& objPtr : m_ctx.sceneObjects) {
            SceneObject* obj = objPtr.get();
            if (!obj || !obj->hasEditableMeshData()) continue;

            glm::mat4 modelMatrix = obj->getTransform().getMatrix();
            glm::mat4 invModel = glm::inverse(modelMatrix);
            glm::vec3 localRayOrigin = glm::vec3(invModel * glm::vec4(rayOrigin, 1.0f));
            glm::vec3 localRayDir = glm::normalize(glm::vec3(invModel * glm::vec4(rayDir, 0.0f)));

            // Raycast against faces using half-edge data
            const auto& heVerts = obj->getHEVertices();
            const auto& heEdges = obj->getHEHalfEdges();
            const auto& heFaces = obj->getHEFaces();

            for (size_t faceIdx = 0; faceIdx < heFaces.size(); ++faceIdx) {
                // Collect face vertices
                std::vector<uint32_t> faceVertIndices;
                uint32_t startHE = heFaces[faceIdx].halfEdgeIndex;
                uint32_t currHE = startHE;
                do {
                    faceVertIndices.push_back(heEdges[currHE].vertexIndex);
                    currHE = heEdges[currHE].nextIndex;
                } while (currHE != startHE && faceVertIndices.size() < 10);

                if (faceVertIndices.size() < 3) continue;

                // Triangulate and test each triangle (fan triangulation)
                for (size_t i = 1; i + 1 < faceVertIndices.size(); ++i) {
                    glm::vec3 v0 = heVerts[faceVertIndices[0]].position;
                    glm::vec3 v1 = heVerts[faceVertIndices[i]].position;
                    glm::vec3 v2 = heVerts[faceVertIndices[i + 1]].position;

                    // Moller-Trumbore intersection
                    glm::vec3 edge1 = v1 - v0;
                    glm::vec3 edge2 = v2 - v0;
                    glm::vec3 h = glm::cross(localRayDir, edge2);
                    float a = glm::dot(edge1, h);

                    if (std::abs(a) < 0.0001f) continue;

                    float f = 1.0f / a;
                    glm::vec3 s = localRayOrigin - v0;
                    float u = f * glm::dot(s, h);

                    if (u < 0.0f || u > 1.0f) continue;

                    glm::vec3 q = glm::cross(s, edge1);
                    float v = f * glm::dot(localRayDir, q);

                    if (v < 0.0f || u + v > 1.0f) continue;

                    float t = f * glm::dot(edge2, q);
                    if (t > 0.0001f && t < closestDist) {
                        closestDist = t;
                        hitObject = obj;
                        hitFace = static_cast<int>(faceIdx);
                    }
                }
            }
        }

        if (hitObject && hitFace >= 0) {
            if (m_snapSourceFace == -1) {
                // First face selection - store as source
                m_snapSourceObject = hitObject;
                m_snapSourceFace = hitFace;
                m_snapSourceCenter = getFaceCenter(hitObject, hitFace);
                m_snapSourceNormal = getFaceNormal(hitObject, hitFace);
                std::cout << "[Snap] Selected source face " << hitFace << " on " << hitObject->getName() << std::endl;
            } else {
                // Second face selection - execute snap based on mode
                if (hitObject == m_snapSourceObject) {
                    std::cout << "[Snap] Cannot snap to same object" << std::endl;
                } else {
                    if (m_snapMergeMode) {
                        // Snap, weld vertices, and merge
                        snapAndMergeObjects(m_snapSourceObject, m_snapSourceFace, hitObject, hitFace);
                    } else {
                        // Just snap (keep separate)
                        glm::vec3 snapPoint = getFaceCenter(hitObject, hitFace);
                        snapObjectToFace(m_snapSourceObject, m_snapSourceFace, hitObject, hitFace);

                        // Select the snapped object and set up rotation gizmo at snap point
                        m_ctx.selectedObject = m_snapSourceObject;
                        m_ctx.objectMode = true;
                        m_ctx.gizmoMode = GizmoMode::Rotate;
                        m_useCustomGizmoPivot = true;
                        m_customGizmoPivot = snapPoint;
                        buildEditableMeshFromObject();
                    }
                    cancelSnapMode();
                }
            }
        }
        return;  // Don't process other input when in snap mode
    }

    // Object mode viewport selection
    // Works when: Q mode (no gizmo), OR when gizmo active but clicking off the gizmo (to quickly switch objects)
    bool canSelectInViewport = m_ctx.objectMode && !mouseOverImGui && !m_ctx.gizmoDragging &&
                               Input::isMouseButtonPressed(Input::MOUSE_LEFT) &&
                               (m_ctx.gizmoMode == GizmoMode::None || m_ctx.gizmoHoveredAxis == GizmoAxis::None);

    if (canSelectInViewport) {
        glm::vec3 rayOrigin, rayDir;
        m_ctx.getMouseRay(rayOrigin, rayDir);

        // Raycast against all scene objects (SceneObject::raycast expects world space)
        SceneObject* hitObject = nullptr;
        float closestDist = FLT_MAX;

        for (auto& obj : m_ctx.sceneObjects) {
            if (!obj->isVisible() || !obj->hasMeshData()) continue;

            auto hit = obj->raycast(rayOrigin, rayDir);
            if (hit.hit && hit.distance < closestDist) {
                closestDist = hit.distance;
                hitObject = obj.get();
            }
        }

        bool shiftHeld = Input::isKeyDown(Input::KEY_LEFT_SHIFT) || Input::isKeyDown(Input::KEY_RIGHT_SHIFT);
        bool ctrlHeld = Input::isKeyDown(Input::KEY_LEFT_CONTROL) || Input::isKeyDown(Input::KEY_RIGHT_CONTROL);

        if (hitObject) {
            // Only change selection if clicking a DIFFERENT object, or using modifier keys
            bool isDifferentObject = (hitObject != m_ctx.selectedObject);

            if (ctrlHeld) {
                // Ctrl+Click: Toggle selection
                if (m_ctx.selectedObjects.count(hitObject) > 0) {
                    m_ctx.selectedObjects.erase(hitObject);
                } else {
                    m_ctx.selectedObjects.insert(hitObject);
                }
                // Update primary selection
                m_ctx.selectedObject = hitObject;
                buildEditableMeshFromObject();
            } else if (shiftHeld) {
                // Shift+Click: Add to selection
                m_ctx.selectedObjects.insert(hitObject);
                m_ctx.selectedObject = hitObject;
                buildEditableMeshFromObject();
            } else if (isDifferentObject) {
                // Normal click on different object: Select it (gizmo stays active)
                m_ctx.selectedObjects.clear();
                m_ctx.selectedObjects.insert(hitObject);
                m_ctx.selectedObject = hitObject;
                buildEditableMeshFromObject();
            }
            // If clicking same object without modifiers and gizmo is active, do nothing (let gizmo handle it)
        } else if (m_ctx.gizmoMode == GizmoMode::None) {
            // Only clear selection when in Q mode (no gizmo) and clicking on empty space
            // When gizmo is active, clicking empty space does nothing (preserves selection)
            m_ctx.selectedObjects.clear();
            m_ctx.selectedObject = nullptr;
            m_ctx.editableMesh.clear();
            m_ctx.meshDirty = false;
        }
    }

    // Mouse selection (skip if gizmo is active or in object mode)
    if (!mouseOverImGui && !gizmoActive && !m_ctx.objectMode && m_ctx.selectedObject && m_ctx.editableMesh.isValid()) {
        glm::vec3 rayOrigin, rayDir;
        m_ctx.getMouseRay(rayOrigin, rayDir);

        glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
        glm::mat4 invModel = glm::inverse(modelMatrix);
        glm::vec3 localRayOrigin = glm::vec3(invModel * glm::vec4(rayOrigin, 1.0f));
        glm::vec3 localRayDir = glm::normalize(glm::vec3(invModel * glm::vec4(rayDir, 0.0f)));

        float threshold = (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex) ?
                          m_ctx.vertexDisplaySize * 2.0f : 0.05f;

        auto hit = m_ctx.editableMesh.raycast(localRayOrigin, localRayDir, m_ctx.modelingSelectionMode, threshold);

        // Disable hover highlighting when in paint mode
        if (m_ctx.isPainting) {
            m_ctx.hoveredVertex = -1;
            m_ctx.hoveredEdge = -1;
            m_ctx.hoveredFace = -1;
        } else {
            m_ctx.hoveredVertex = (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex && hit.hit) ?
                                  static_cast<int>(hit.vertexIndex) : -1;
            m_ctx.hoveredEdge = (m_ctx.modelingSelectionMode == ModelingSelectionMode::Edge && hit.hit) ?
                                static_cast<int>(hit.edgeIndex) : -1;
            m_ctx.hoveredFace = (m_ctx.modelingSelectionMode == ModelingSelectionMode::Face && hit.hit) ?
                                static_cast<int>(hit.faceIndex) : -1;
        }

        // Skip selection when in paint mode (painting uses LMB, Ctrl+Click sets clone source)
        bool shiftHeld = Input::isKeyDown(Input::KEY_LEFT_SHIFT) || Input::isKeyDown(Input::KEY_RIGHT_SHIFT);
        bool ctrlHeld = Input::isKeyDown(Input::KEY_LEFT_CONTROL) || Input::isKeyDown(Input::KEY_RIGHT_CONTROL);

        // Normal selection mode - click for point select, drag for rectangle select
        if (m_ctx.selectionTool == SelectionTool::Normal && !m_ctx.isPainting) {
            if (Input::isMouseButtonPressed(Input::MOUSE_LEFT)) {
                // Start tracking for potential rectangle selection
                m_ctx.isRectSelecting = true;
                m_ctx.rectSelectStart = Input::getMousePosition();
                m_ctx.rectSelectEnd = m_ctx.rectSelectStart;
            }
            if (m_ctx.isRectSelecting && Input::isMouseButtonDown(Input::MOUSE_LEFT)) {
                // Update rectangle end point while dragging
                m_ctx.rectSelectEnd = Input::getMousePosition();
            }
            if (m_ctx.isRectSelecting && !Input::isMouseButtonDown(Input::MOUSE_LEFT)) {
                // Mouse released - decide between point select and rect select
                m_ctx.isRectSelecting = false;

                // Calculate drag distance
                float dragDist = glm::length(m_ctx.rectSelectEnd - m_ctx.rectSelectStart);
                const float dragThreshold = 5.0f;  // Pixels - below this is a click

                if (dragDist >= dragThreshold) {
                    // Rectangle selection
                    if (!shiftHeld) {
                        m_ctx.editableMesh.clearSelection();
                    }

                    // Get viewport info for projection (handle split view)
                    float fullWidth = static_cast<float>(m_ctx.window.getWidth());
                    float fullHeight = static_cast<float>(m_ctx.window.getHeight());

                    float vpX = 0.0f;
                    float vpWidth = fullWidth;
                    float vpHeight = fullHeight;

                    bool useRightViewport = false;
                    if (m_ctx.splitView) {
                        vpWidth = fullWidth / 2.0f;
                        if (m_ctx.rectSelectStart.x >= fullWidth / 2.0f) {
                            vpX = fullWidth / 2.0f;
                            useRightViewport = true;
                        }
                    }

                    Camera& cam = (m_ctx.splitView && useRightViewport) ? m_ctx.camera2 : m_ctx.camera;
                    glm::mat4 view = cam.getViewMatrix();
                    glm::mat4 proj = cam.getProjectionMatrix(vpWidth / vpHeight);
                    glm::mat4 mvp = proj * view * m_ctx.selectedObject->getTransform().getMatrix();

                    float minX = std::min(m_ctx.rectSelectStart.x, m_ctx.rectSelectEnd.x);
                    float maxX = std::max(m_ctx.rectSelectStart.x, m_ctx.rectSelectEnd.x);
                    float minY = std::min(m_ctx.rectSelectStart.y, m_ctx.rectSelectEnd.y);
                    float maxY = std::max(m_ctx.rectSelectStart.y, m_ctx.rectSelectEnd.y);

                    if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex) {
                        for (size_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                            glm::vec3 pos = m_ctx.editableMesh.getVertex(i).position;
                            glm::vec4 clip = mvp * glm::vec4(pos, 1.0f);
                            if (clip.w > 0.0f) {
                                glm::vec3 ndc = glm::vec3(clip) / clip.w;
                                float screenX = vpX + (ndc.x * 0.5f + 0.5f) * vpWidth;
                                float screenY = (1.0f - (ndc.y * 0.5f + 0.5f)) * vpHeight;
                                if (screenX >= minX && screenX <= maxX && screenY >= minY && screenY <= maxY) {
                                    m_ctx.editableMesh.selectVertex(i, true);
                                }
                            }
                        }
                    } else if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Face) {
                        for (size_t i = 0; i < m_ctx.editableMesh.getFaceCount(); ++i) {
                            glm::vec3 center = m_ctx.editableMesh.getFaceCenter(i);
                            glm::vec4 clip = mvp * glm::vec4(center, 1.0f);
                            if (clip.w > 0.0f) {
                                glm::vec3 ndc = glm::vec3(clip) / clip.w;
                                float screenX = vpX + (ndc.x * 0.5f + 0.5f) * vpWidth;
                                float screenY = (1.0f - (ndc.y * 0.5f + 0.5f)) * vpHeight;
                                if (screenX >= minX && screenX <= maxX && screenY >= minY && screenY <= maxY) {
                                    m_ctx.editableMesh.selectFace(i, true);
                                }
                            }
                        }
                    } else if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Edge) {
                        for (size_t i = 0; i < m_ctx.editableMesh.getHalfEdgeCount(); ++i) {
                            auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(i);
                            glm::vec3 midpoint = (m_ctx.editableMesh.getVertex(v0).position +
                                                  m_ctx.editableMesh.getVertex(v1).position) * 0.5f;
                            glm::vec4 clip = mvp * glm::vec4(midpoint, 1.0f);
                            if (clip.w > 0.0f) {
                                glm::vec3 ndc = glm::vec3(clip) / clip.w;
                                float screenX = vpX + (ndc.x * 0.5f + 0.5f) * vpWidth;
                                float screenY = (1.0f - (ndc.y * 0.5f + 0.5f)) * vpHeight;
                                if (screenX >= minX && screenX <= maxX && screenY >= minY && screenY <= maxY) {
                                    m_ctx.editableMesh.selectEdge(i, true);
                                }
                            }
                        }
                    }
                } else {
                    // Point selection (click)
                    double currentTime = glfwGetTime();
                    bool isDoubleClick = (currentTime - m_ctx.lastClickTime) < 0.3;
                    m_ctx.lastClickTime = currentTime;

                    if (hit.hit) {
                        switch (m_ctx.modelingSelectionMode) {
                            case ModelingSelectionMode::Vertex:
                                if (ctrlHeld) {
                                    m_ctx.editableMesh.toggleVertexSelection(hit.vertexIndex);
                                } else {
                                    m_ctx.editableMesh.selectVertex(hit.vertexIndex, shiftHeld);
                                }
                                break;

                            case ModelingSelectionMode::Edge: {
                                bool altHeld = Input::isKeyDown(Input::KEY_LEFT_ALT) || Input::isKeyDown(Input::KEY_RIGHT_ALT);
                                if (altHeld) {
                                    // Walk faces in the direction established by the clicked edge
                                    m_ctx.editableMesh.clearSelection();
                                    std::set<uint32_t> facesToSelect;

                                    auto walkFaceLoop = [&](uint32_t startHe) {
                                        uint32_t currentHe = startHe;
                                        uint32_t iterations = 0;
                                        const uint32_t maxIter = 1000;

                                        while (iterations++ < maxIter) {
                                            const auto& he = m_ctx.editableMesh.getHalfEdge(currentHe);
                                            if (he.faceIndex == UINT32_MAX) break;
                                            if (facesToSelect.count(he.faceIndex) > 0) break;

                                            const auto& face = m_ctx.editableMesh.getFace(he.faceIndex);
                                            facesToSelect.insert(he.faceIndex);

                                            if (face.vertexCount != 4) break;

                                            uint32_t next1 = he.nextIndex;
                                            uint32_t next2 = m_ctx.editableMesh.getHalfEdge(next1).nextIndex;
                                            uint32_t twinHe = m_ctx.editableMesh.getHalfEdge(next2).twinIndex;
                                            if (twinHe == UINT32_MAX) break;

                                            currentHe = twinHe;
                                        }
                                    };

                                    walkFaceLoop(hit.edgeIndex);
                                    uint32_t twinHe = m_ctx.editableMesh.getHalfEdge(hit.edgeIndex).twinIndex;
                                    if (twinHe != UINT32_MAX) {
                                        walkFaceLoop(twinHe);
                                    }

                                    for (uint32_t faceIdx : facesToSelect) {
                                        m_ctx.editableMesh.selectFace(faceIdx, true);
                                    }

                                    m_ctx.modelingSelectionMode = ModelingSelectionMode::Face;
                                } else if (isDoubleClick) {
                                    m_ctx.editableMesh.selectEdgeRing(hit.edgeIndex);
                                } else if (ctrlHeld) {
                                    m_ctx.editableMesh.toggleEdgeSelection(hit.edgeIndex);
                                } else {
                                    m_ctx.editableMesh.selectEdge(hit.edgeIndex, shiftHeld);
                                }
                                break;
                            }

                            case ModelingSelectionMode::Face: {
                                bool altHeld = Input::isKeyDown(Input::KEY_LEFT_ALT) || Input::isKeyDown(Input::KEY_RIGHT_ALT);
                                if (altHeld) {
                                    MeshRayHit edgeHit = m_ctx.editableMesh.raycastEdge(rayOrigin, rayDir, 0.1f);
                                    if (edgeHit.hit) {
                                        if (!shiftHeld) {
                                            m_ctx.editableMesh.clearSelection();
                                        }

                                        std::set<uint32_t> facesToSelect;

                                        auto walkFaceLoop = [&](uint32_t startHe) {
                                            uint32_t currentHe = startHe;
                                            uint32_t iterations = 0;
                                            const uint32_t maxIter = 1000;

                                            while (iterations++ < maxIter) {
                                                const auto& he = m_ctx.editableMesh.getHalfEdge(currentHe);
                                                if (he.faceIndex == UINT32_MAX) break;
                                                if (facesToSelect.count(he.faceIndex) > 0) break;

                                                const auto& face = m_ctx.editableMesh.getFace(he.faceIndex);
                                                facesToSelect.insert(he.faceIndex);

                                                if (face.vertexCount != 4) break;

                                                uint32_t next1 = he.nextIndex;
                                                uint32_t next2 = m_ctx.editableMesh.getHalfEdge(next1).nextIndex;
                                                uint32_t twinHe = m_ctx.editableMesh.getHalfEdge(next2).twinIndex;
                                                if (twinHe == UINT32_MAX) break;

                                                currentHe = twinHe;
                                            }
                                        };

                                        walkFaceLoop(edgeHit.edgeIndex);
                                        uint32_t twinHe = m_ctx.editableMesh.getHalfEdge(edgeHit.edgeIndex).twinIndex;
                                        if (twinHe != UINT32_MAX) {
                                            walkFaceLoop(twinHe);
                                        }

                                        for (uint32_t faceIdx : facesToSelect) {
                                            m_ctx.editableMesh.selectFace(faceIdx, true);
                                        }
                                    }
                                } else if (ctrlHeld) {
                                    m_ctx.editableMesh.toggleFaceSelection(hit.faceIndex);
                                } else {
                                    m_ctx.editableMesh.selectFace(hit.faceIndex, shiftHeld);
                                }
                                break;
                            }
                        }
                    } else {
                        // Click missed geometry - clear selection
                        if (m_ctx.gizmoMode == GizmoMode::None) {
                            m_ctx.editableMesh.clearSelection();
                        }
                    }
                }
            }
        }

        // Paint select handling - continuous selection while dragging
        if (m_ctx.selectionTool == SelectionTool::Paint && !m_ctx.isPainting) {
            if (Input::isMouseButtonDown(Input::MOUSE_LEFT)) {
                if (Input::isMouseButtonPressed(Input::MOUSE_LEFT) && !shiftHeld) {
                    m_ctx.editableMesh.clearSelection();
                }
                if (hit.hit) {
                    switch (m_ctx.modelingSelectionMode) {
                        case ModelingSelectionMode::Vertex:
                            m_ctx.editableMesh.selectVertex(hit.vertexIndex, true);
                            break;
                        case ModelingSelectionMode::Edge:
                            m_ctx.editableMesh.selectEdge(hit.edgeIndex, true);
                            break;
                        case ModelingSelectionMode::Face:
                            m_ctx.editableMesh.selectFace(hit.faceIndex, true);
                            break;
                    }
                }
            }
        }
    }

    // RMB always starts tumble (useful in paint mode or when model fills screen)
    if (!mouseOverImGui && Input::isMouseButtonPressed(Input::MOUSE_RIGHT)) {
        startCameraTumble();
    }
}

void ModelingMode::startCameraTumble() {
    Camera& cam = m_ctx.getActiveCamera();
    m_ctx.isTumbling = true;

    // Calculate current orbit angles from camera position relative to target
    glm::vec3 offset = cam.getPosition() - m_ctx.orbitTarget;
    float dist = glm::length(offset);
    if (dist > 0.001f) {
        offset = glm::normalize(offset);
        m_ctx.orbitPitch = glm::degrees(asin(glm::clamp(offset.y, -1.0f, 1.0f)));
        m_ctx.orbitYaw = glm::degrees(atan2(offset.z, offset.x));
    }
}

void ModelingMode::renderModelingOverlay(VkCommandBuffer cmd, const glm::mat4& viewProj) {
    if (!m_ctx.selectedObject || !m_ctx.editableMesh.isValid()) return;
    if (!m_ctx.selectedObject->isVisible()) return;

    glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();

    // Render selected faces (only in face mode to avoid showing stale selections)
    if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Face) {
        auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
        if (!selectedFaces.empty()) {
            std::vector<uint32_t> triangleIndices;
            for (uint32_t faceIdx : selectedFaces) {
                auto origTris = m_ctx.faceToTriangles.find(faceIdx);
                if (origTris != m_ctx.faceToTriangles.end()) {
                    for (uint32_t triIdx : origTris->second) {
                        triangleIndices.push_back(triIdx);
                    }
                }
            }
            if (!triangleIndices.empty()) {
                m_ctx.modelRenderer.renderSelection(cmd, viewProj, m_ctx.selectedObject->getBufferHandle(),
                                                     modelMatrix, triangleIndices, m_ctx.modelingSelectionColor);
            }
        }
    }

    // Render hovered face
    if (m_ctx.hoveredFace >= 0 && m_ctx.modelingSelectionMode == ModelingSelectionMode::Face) {
        std::vector<uint32_t> triangleIndices;
        auto origTris = m_ctx.faceToTriangles.find(static_cast<uint32_t>(m_ctx.hoveredFace));
        if (origTris != m_ctx.faceToTriangles.end()) {
            for (uint32_t triIdx : origTris->second) {
                triangleIndices.push_back(triIdx);
            }
        }
        if (!triangleIndices.empty()) {
            m_ctx.modelRenderer.renderSelection(cmd, viewProj, m_ctx.selectedObject->getBufferHandle(),
                                                 modelMatrix, triangleIndices, m_ctx.modelingHoverColor);
        }
    }
}

void ModelingMode::renderWireframeOverlay3D(VkCommandBuffer cmd, const glm::mat4& viewProj) {
    if (!m_ctx.selectedObject || !m_ctx.editableMesh.isValid()) return;
    if (!m_ctx.selectedObject->isVisible()) return;

    glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();

    // Collect all edges from quad/polygon faces
    // Use position-based keys for uniqueness (not vertex indices)
    // because cube has duplicate vertices per face for normals
    auto posKey = [](const glm::vec3& p) -> uint64_t {
        int32_t x = static_cast<int32_t>(p.x * 10000.0f);
        int32_t y = static_cast<int32_t>(p.y * 10000.0f);
        int32_t z = static_cast<int32_t>(p.z * 10000.0f);
        return (static_cast<uint64_t>(x & 0xFFFFF) << 40) |
               (static_cast<uint64_t>(y & 0xFFFFF) << 20) |
               static_cast<uint64_t>(z & 0xFFFFF);
    };
    auto edgePosKey = [&](const glm::vec3& p0, const glm::vec3& p1) -> std::pair<uint64_t, uint64_t> {
        uint64_t k0 = posKey(p0);
        uint64_t k1 = posKey(p1);
        return k0 < k1 ? std::make_pair(k0, k1) : std::make_pair(k1, k0);
    };

    std::set<std::pair<uint64_t, uint64_t>> drawnEdges;
    std::vector<glm::vec3> wireLines;
    std::vector<glm::vec3> selectedLines;



    // Get selected edges (using position-based keys)
    std::set<std::pair<uint64_t, uint64_t>> selectedEdgeKeys;
    auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
    for (uint32_t he : selectedEdges) {
        auto [vi0, vi1] = m_ctx.editableMesh.getEdgeVertices(he);
        const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
        const auto& v1 = m_ctx.editableMesh.getVertex(vi1);
        selectedEdgeKeys.insert(edgePosKey(v0.position, v1.position));
    }

    uint32_t vertexCount = m_ctx.editableMesh.getVertexCount();

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto verts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        if (verts.size() < 3) continue;  // Skip degenerate faces

        for (size_t i = 0; i < verts.size(); ++i) {
            uint32_t vi0 = verts[i];
            uint32_t vi1 = verts[(i + 1) % verts.size()];

            // Skip invalid vertex indices
            if (vi0 >= vertexCount || vi1 >= vertexCount) continue;

            const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
            const auto& v1 = m_ctx.editableMesh.getVertex(vi1);

            // Use position-based key for uniqueness (handles duplicate vertices)
            auto edgeKey = edgePosKey(v0.position, v1.position);
            if (drawnEdges.count(edgeKey) > 0) continue;
            drawnEdges.insert(edgeKey);

            // Transform to world space (depth bias in pipeline handles Z-fighting)
            glm::vec3 worldV0 = glm::vec3(modelMatrix * glm::vec4(v0.position, 1.0f));
            glm::vec3 worldV1 = glm::vec3(modelMatrix * glm::vec4(v1.position, 1.0f));

            bool isSelected = selectedEdgeKeys.count(edgeKey) > 0;
            if (isSelected) {
                selectedLines.push_back(worldV0);
                selectedLines.push_back(worldV1);
            } else {
                wireLines.push_back(worldV0);
                wireLines.push_back(worldV1);
            }
        }
    }

    // Render normal edges in black
    if (!wireLines.empty()) {
        m_ctx.modelRenderer.renderLines(cmd, viewProj, wireLines, glm::vec3(0.0f, 0.0f, 0.0f));
    }

    // Render selected edges in blue
    if (!selectedLines.empty()) {
        m_ctx.modelRenderer.renderLines(cmd, viewProj, selectedLines, glm::vec3(0.2f, 0.4f, 1.0f));
    }

    // Render vertices when in vertex mode
    // NOTE: We must render all vertices in a single call to avoid buffer overwrite issues
    // So we render: normal first (cyan), then selected on top (orange), then hovered on top (yellow)
    if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex) {
        auto selectedVertSet = m_ctx.editableMesh.getSelectedVertices();
        std::set<uint32_t> selectedSet(selectedVertSet.begin(), selectedVertSet.end());

        // Track positions we've already added to avoid duplicates
        std::set<uint64_t> addedPositions;
        auto posKey = [](const glm::vec3& p) -> uint64_t {
            int32_t x = static_cast<int32_t>(p.x * 10000.0f);
            int32_t y = static_cast<int32_t>(p.y * 10000.0f);
            int32_t z = static_cast<int32_t>(p.z * 10000.0f);
            return (static_cast<uint64_t>(x & 0xFFFFF) << 40) |
                   (static_cast<uint64_t>(y & 0xFFFFF) << 20) |
                   static_cast<uint64_t>(z & 0xFFFFF);
        };

        // Collect ALL vertices first, then render each category separately
        // Store vertex info: position and category (0=normal, 1=selected, 2=hovered)
        std::vector<std::pair<glm::vec3, int>> allVerts;

        for (uint32_t vi = 0; vi < m_ctx.editableMesh.getVertexCount(); ++vi) {
            const auto& v = m_ctx.editableMesh.getVertex(vi);

            uint64_t key = posKey(v.position);
            if (addedPositions.count(key) > 0) continue;
            addedPositions.insert(key);

            glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(v.position, 1.0f));

            int category = 0; // normal
            if (static_cast<int>(vi) == m_ctx.hoveredVertex) {
                category = 2; // hovered
            } else if (selectedSet.count(vi) > 0) {
                category = 1; // selected
            }
            allVerts.push_back({worldPos, category});
        }

        // Render each category - order matters for visibility (normal first, then selected, then hovered)
        std::vector<glm::vec3> categoryVerts;

        // Normal vertices (cyan)
        categoryVerts.clear();
        for (const auto& [pos, cat] : allVerts) {
            if (cat == 0) categoryVerts.push_back(pos);
        }
        if (!categoryVerts.empty()) {
            m_ctx.modelRenderer.renderPoints(cmd, viewProj, categoryVerts, glm::vec3(0.0f, 0.8f, 1.0f), 8.0f);
        }

        // Selected vertices (orange) - rendered after normal so they appear on top
        categoryVerts.clear();
        for (const auto& [pos, cat] : allVerts) {
            if (cat == 1) categoryVerts.push_back(pos);
        }
        if (!categoryVerts.empty()) {
            m_ctx.modelRenderer.renderPoints(cmd, viewProj, categoryVerts, glm::vec3(1.0f, 0.6f, 0.0f), 10.0f);
        }

        // Hovered vertex (yellow) - rendered last so it appears on top
        categoryVerts.clear();
        for (const auto& [pos, cat] : allVerts) {
            if (cat == 2) categoryVerts.push_back(pos);
        }
        if (!categoryVerts.empty()) {
            m_ctx.modelRenderer.renderPoints(cmd, viewProj, categoryVerts, glm::vec3(1.0f, 1.0f, 0.0f), 12.0f);
        }
    }

    // =========================================================================
    // UV Selection Highlighting in 3D View
    // =========================================================================
    // Show what's selected in the UV editor on the actual 3D model

    // Magenta color for UV selection
    glm::vec3 uvHighlightColor(1.0f, 0.0f, 1.0f);

    // Highlight UV-selected faces (render their edges)
    if (!m_ctx.uvSelectedFaces.empty()) {
        std::vector<glm::vec3> uvFaceLines;
        for (uint32_t faceIdx : m_ctx.uvSelectedFaces) {
            if (faceIdx >= m_ctx.editableMesh.getFaceCount()) continue;
            auto verts = m_ctx.editableMesh.getFaceVertices(faceIdx);
            for (size_t i = 0; i < verts.size(); ++i) {
                uint32_t vi0 = verts[i];
                uint32_t vi1 = verts[(i + 1) % verts.size()];
                if (vi0 >= m_ctx.editableMesh.getVertexCount() || vi1 >= m_ctx.editableMesh.getVertexCount()) continue;
                const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
                const auto& v1 = m_ctx.editableMesh.getVertex(vi1);
                glm::vec3 worldV0 = glm::vec3(modelMatrix * glm::vec4(v0.position, 1.0f));
                glm::vec3 worldV1 = glm::vec3(modelMatrix * glm::vec4(v1.position, 1.0f));
                uvFaceLines.push_back(worldV0);
                uvFaceLines.push_back(worldV1);
            }
        }
        if (!uvFaceLines.empty()) {
            m_ctx.modelRenderer.renderLines(cmd, viewProj, uvFaceLines, uvHighlightColor);
        }
    }

    // Highlight UV-selected vertices
    if (!m_ctx.uvSelectedVertices.empty()) {
        std::vector<glm::vec3> uvVertPoints;
        for (uint32_t vi : m_ctx.uvSelectedVertices) {
            if (vi >= m_ctx.editableMesh.getVertexCount()) continue;
            const auto& v = m_ctx.editableMesh.getVertex(vi);
            glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(v.position, 1.0f));
            uvVertPoints.push_back(worldPos);
        }
        if (!uvVertPoints.empty()) {
            m_ctx.modelRenderer.renderPoints(cmd, viewProj, uvVertPoints, uvHighlightColor, 12.0f);
        }
    }

    // Highlight UV-selected edge
    if (m_ctx.uvSelectedEdge.first != UINT32_MAX) {
        uint32_t faceIdx = m_ctx.uvSelectedEdge.first;
        uint32_t edgeIdx = m_ctx.uvSelectedEdge.second;
        if (faceIdx < m_ctx.editableMesh.getFaceCount()) {
            auto verts = m_ctx.editableMesh.getFaceVertices(faceIdx);
            if (edgeIdx < verts.size()) {
                uint32_t vi0 = verts[edgeIdx];
                uint32_t vi1 = verts[(edgeIdx + 1) % verts.size()];
                if (vi0 < m_ctx.editableMesh.getVertexCount() && vi1 < m_ctx.editableMesh.getVertexCount()) {
                    const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
                    const auto& v1 = m_ctx.editableMesh.getVertex(vi1);
                    glm::vec3 worldV0 = glm::vec3(modelMatrix * glm::vec4(v0.position, 1.0f));
                    glm::vec3 worldV1 = glm::vec3(modelMatrix * glm::vec4(v1.position, 1.0f));
                    std::vector<glm::vec3> uvEdgeLine = {worldV0, worldV1};
                    m_ctx.modelRenderer.renderLines(cmd, viewProj, uvEdgeLine, uvHighlightColor);
                }
            }
        }
    }
}

void ModelingMode::renderGrid3D(VkCommandBuffer cmd, const glm::mat4& viewProj) {
    std::vector<glm::vec3> gridLines;
    const float gridSize = 10.0f;
    const int gridLines_count = 21;
    const float spacing = gridSize * 2.0f / (gridLines_count - 1);

    for (int i = 0; i < gridLines_count; ++i) {
        float z = -gridSize + i * spacing;
        gridLines.push_back(glm::vec3(-gridSize, 0, z));
        gridLines.push_back(glm::vec3(gridSize, 0, z));
    }

    for (int i = 0; i < gridLines_count; ++i) {
        float x = -gridSize + i * spacing;
        gridLines.push_back(glm::vec3(x, 0, -gridSize));
        gridLines.push_back(glm::vec3(x, 0, gridSize));
    }

    m_ctx.modelRenderer.renderLines(cmd, viewProj, gridLines, glm::vec3(0.3f, 0.3f, 0.35f));

    // Axis lines
    std::vector<glm::vec3> axisLines;
    axisLines.push_back(glm::vec3(-gridSize, 0, 0));
    axisLines.push_back(glm::vec3(gridSize, 0, 0));
    m_ctx.modelRenderer.renderLines(cmd, viewProj, axisLines, glm::vec3(0.8f, 0.3f, 0.3f));

    axisLines.clear();
    axisLines.push_back(glm::vec3(0, 0, -gridSize));
    axisLines.push_back(glm::vec3(0, 0, gridSize));
    m_ctx.modelRenderer.renderLines(cmd, viewProj, axisLines, glm::vec3(0.3f, 0.3f, 0.8f));

    axisLines.clear();
    axisLines.push_back(glm::vec3(0, 0, 0));
    axisLines.push_back(glm::vec3(0, 0.5f, 0));
    m_ctx.modelRenderer.renderLines(cmd, viewProj, axisLines, glm::vec3(0.3f, 0.8f, 0.3f));
}

void ModelingMode::buildEditableMeshFromObject() {
    std::cout << "buildEditableMeshFromObject called" << std::endl;
    g_wireframeDebugPrinted = false;  // Reset debug flag so we print again
    if (!m_ctx.selectedObject || !m_ctx.selectedObject->hasMeshData()) return;

    // Check if we have stored EditableMesh data (preserves quad topology)
    if (m_ctx.selectedObject->hasEditableMeshData()) {
        const auto& storedVerts = m_ctx.selectedObject->getHEVertices();
        const auto& storedHE = m_ctx.selectedObject->getHEHalfEdges();
        const auto& storedFaces = m_ctx.selectedObject->getHEFaces();

        // Convert from SceneObject storage format to EditableMesh format
        std::vector<HEVertex> heVerts;
        heVerts.reserve(storedVerts.size());
        for (const auto& v : storedVerts) {
            heVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
        }

        std::vector<HalfEdge> heHalfEdges;
        heHalfEdges.reserve(storedHE.size());
        for (const auto& he : storedHE) {
            heHalfEdges.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
        }

        std::vector<HEFace> heFaces;
        heFaces.reserve(storedFaces.size());
        for (const auto& f : storedFaces) {
            heFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
        }

        m_ctx.editableMesh.setFromData(heVerts, heHalfEdges, heFaces);

        // Build faceToTriangles mapping
        m_ctx.faceToTriangles.clear();
        uint32_t triIndex = 0;
        for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
            uint32_t vertCount = m_ctx.editableMesh.getFace(faceIdx).vertexCount;
            uint32_t triCount = (vertCount >= 3) ? (vertCount - 2) : 0;
            for (uint32_t i = 0; i < triCount; ++i) {
                m_ctx.faceToTriangles[faceIdx].push_back(triIndex++);
            }
        }

        m_ctx.meshDirty = false;
        return;
    }

    // Fall back to building from triangles and attempting to merge back to quads
    const auto& vertices = m_ctx.selectedObject->getVertices();
    const auto& indices = m_ctx.selectedObject->getIndices();

    m_ctx.editableMesh.buildFromTriangles(vertices, indices);
    size_t triCount = m_ctx.editableMesh.getFaceCount();
    m_ctx.editableMesh.mergeTrianglesToQuads();  // Uses 0.85 threshold for faceted geometry

    // Build faceToTriangles mapping
    m_ctx.faceToTriangles.clear();
    uint32_t triIndex = 0;
    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        uint32_t vertCount = m_ctx.editableMesh.getFace(faceIdx).vertexCount;
        uint32_t numTris = (vertCount >= 3) ? (vertCount - 2) : 0;
        for (uint32_t i = 0; i < numTris && triIndex < triCount; ++i) {
            m_ctx.faceToTriangles[faceIdx].push_back(triIndex++);
        }
    }

    m_ctx.meshDirty = false;
}

void ModelingMode::updateMeshFromEditable() {
    if (!m_ctx.selectedObject || !m_ctx.editableMesh.isValid()) return;

    std::vector<ModelVertex> vertices;
    std::vector<uint32_t> indices;
    m_ctx.editableMesh.triangulate(vertices, indices);

    uint32_t oldHandle = m_ctx.selectedObject->getBufferHandle();
    m_ctx.modelRenderer.destroyModel(oldHandle);

    uint32_t newHandle = m_ctx.modelRenderer.createModel(vertices, indices, nullptr, 0, 0);
    m_ctx.selectedObject->setBufferHandle(newHandle);
    m_ctx.selectedObject->setIndexCount(static_cast<uint32_t>(indices.size()));
    m_ctx.selectedObject->setVertexCount(static_cast<uint32_t>(vertices.size()));
    m_ctx.selectedObject->setMeshData(vertices, indices);

    // Also save EditableMesh half-edge data (preserves quad topology for duplicate)
    const auto& heVerts = m_ctx.editableMesh.getVerticesData();
    const auto& heHalfEdges = m_ctx.editableMesh.getHalfEdges();
    const auto& heFaces = m_ctx.editableMesh.getFacesData();

    std::vector<SceneObject::StoredHEVertex> storedVerts;
    storedVerts.reserve(heVerts.size());
    for (const auto& v : heVerts) {
        storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
    }

    std::vector<SceneObject::StoredHalfEdge> storedHE;
    storedHE.reserve(heHalfEdges.size());
    for (const auto& he : heHalfEdges) {
        storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
    }

    std::vector<SceneObject::StoredHEFace> storedFaces;
    storedFaces.reserve(heFaces.size());
    for (const auto& f : heFaces) {
        storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
    }

    m_ctx.selectedObject->setEditableMeshData(storedVerts, storedHE, storedFaces);

    m_ctx.faceToTriangles.clear();
    uint32_t triIndex = 0;
    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        uint32_t vertCount = m_ctx.editableMesh.getFace(faceIdx).vertexCount;
        uint32_t triCount = (vertCount >= 3) ? (vertCount - 2) : 0;
        for (uint32_t i = 0; i < triCount; ++i) {
            m_ctx.faceToTriangles[faceIdx].push_back(triIndex++);
        }
    }

    m_ctx.meshDirty = false;
}

void ModelingMode::saveEditableMeshAsGLB() {
    if (!m_ctx.selectedObject || !m_ctx.selectedObject->hasMeshData()) {
        std::cerr << "No mesh to save" << std::endl;
        return;
    }

    // Use the stored triangulated data from SceneObject directly
    // This is the same data used for GPU rendering, so it's known to be correct
    std::vector<ModelVertex> vertices = m_ctx.selectedObject->getVertices();
    std::vector<uint32_t> indices = m_ctx.selectedObject->getIndices();

    // Apply object transform to bake in scale/rotation/position
    if (m_ctx.selectedObject) {
        glm::mat4 transform = m_ctx.selectedObject->getTransform().getMatrix();
        glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(transform)));

        for (auto& v : vertices) {
            // Transform position
            glm::vec4 worldPos = transform * glm::vec4(v.position, 1.0f);
            v.position = glm::vec3(worldPos);

            // Transform normal
            v.normal = glm::normalize(normalMatrix * v.normal);
        }
    }

    std::string defaultName = "model.glb";
    if (m_ctx.selectedObject) {
        defaultName = m_ctx.selectedObject->getName() + "_edited.glb";
    }

    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filters[1] = {{"GLB Model", "glb"}};
    nfdresult_t result = NFD_SaveDialog(&outPath, filters, 1, nullptr, defaultName.c_str());

    if (result == NFD_OKAY) {
        std::string filepath = outPath;
        NFD_FreePath(outPath);

        if (filepath.size() < 4 || filepath.substr(filepath.size() - 4) != ".glb") {
            filepath += ".glb";
        }

        std::string meshName = std::filesystem::path(filepath).stem().string();

        bool saved = false;
        // Get texture data if available
        const unsigned char* texData = nullptr;
        int texW = 0, texH = 0;
        if (m_ctx.selectedObject->hasTextureData()) {
            texData = m_ctx.selectedObject->getTextureData().data();
            texW = m_ctx.selectedObject->getTextureWidth();
            texH = m_ctx.selectedObject->getTextureHeight();
        }

        // Save with half-edge data if available (preserves quad topology on reload)
        if (m_ctx.selectedObject->hasEditableMeshData()) {
            StoredHEData heData;
            heData.vertices = m_ctx.selectedObject->getHEVertices();
            heData.halfEdges = m_ctx.selectedObject->getHEHalfEdges();
            heData.faces = m_ctx.selectedObject->getHEFaces();
            saved = GLBLoader::saveWithHalfEdgeData(filepath, vertices, indices, heData, texData, texW, texH, meshName);
        } else if (texData) {
            saved = GLBLoader::save(filepath, vertices, indices, texData, texW, texH, meshName);
        } else {
            saved = GLBLoader::save(filepath, vertices, indices, meshName);
        }

        if (saved) {
            std::cout << "Saved mesh to: " << filepath << std::endl;
        } else {
            std::cerr << "Failed to save mesh to: " << filepath << std::endl;
        }
    }
}

void ModelingMode::saveEditableMeshAsOBJ() {
    if (!m_ctx.editableMesh.isValid()) {
        std::cerr << "No mesh to save" << std::endl;
        return;
    }

    std::string defaultName = "model.obj";
    if (m_ctx.selectedObject) {
        defaultName = m_ctx.selectedObject->getName() + ".obj";
    }

    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filters[1] = {{"OBJ Model", "obj"}};
    nfdresult_t result = NFD_SaveDialog(&outPath, filters, 1, nullptr, defaultName.c_str());

    if (result == NFD_OKAY) {
        std::string filepath = outPath;
        NFD_FreePath(outPath);

        if (filepath.size() < 4 || filepath.substr(filepath.size() - 4) != ".obj") {
            filepath += ".obj";
        }

        if (m_ctx.editableMesh.saveOBJ(filepath)) {
            std::cout << "Saved OBJ to: " << filepath << std::endl;
        } else {
            std::cerr << "Failed to save OBJ: " << filepath << std::endl;
        }
    }
}

void ModelingMode::loadOBJFile() {
    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filters[1] = {{"OBJ Model", "obj"}};
    nfdresult_t result = NFD_OpenDialog(&outPath, filters, 1, nullptr);

    if (result == NFD_OKAY) {
        std::string filepath = outPath;
        NFD_FreePath(outPath);

        if (m_ctx.editableMesh.loadOBJ(filepath)) {
            // Create a new SceneObject from the loaded mesh
            std::string meshName = std::filesystem::path(filepath).stem().string();
            auto obj = std::make_unique<SceneObject>(meshName);

            // Triangulate for GPU rendering
            std::vector<ModelVertex> vertices;
            std::vector<uint32_t> indices;
            m_ctx.editableMesh.triangulate(vertices, indices);

            uint32_t handle = m_ctx.modelRenderer.createModel(vertices, indices, nullptr, 0, 0);
            obj->setBufferHandle(handle);
            obj->setIndexCount(static_cast<uint32_t>(indices.size()));
            obj->setVertexCount(static_cast<uint32_t>(vertices.size()));
            obj->setMeshData(vertices, indices);

            // Store half-edge data for proper quad preservation
            const auto& heVerts = m_ctx.editableMesh.getVerticesData();
            const auto& heHalfEdges = m_ctx.editableMesh.getHalfEdges();
            const auto& heFaces = m_ctx.editableMesh.getFacesData();

            std::vector<SceneObject::StoredHEVertex> storedVerts;
            storedVerts.reserve(heVerts.size());
            for (const auto& v : heVerts) {
                storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
            }

            std::vector<SceneObject::StoredHalfEdge> storedHE;
            storedHE.reserve(heHalfEdges.size());
            for (const auto& he : heHalfEdges) {
                storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
            }

            std::vector<SceneObject::StoredHEFace> storedFaces;
            storedFaces.reserve(heFaces.size());
            for (const auto& f : heFaces) {
                storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
            }

            obj->setEditableMeshData(storedVerts, storedHE, storedFaces);

            m_ctx.selectedObject = obj.get();
            m_ctx.sceneObjects.push_back(std::move(obj));

            // Update faceToTriangles mapping
            m_ctx.faceToTriangles.clear();
            uint32_t triIndex = 0;
            for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
                uint32_t vertCount = m_ctx.editableMesh.getFace(faceIdx).vertexCount;
                uint32_t triCount = (vertCount >= 3) ? (vertCount - 2) : 0;
                for (uint32_t i = 0; i < triCount; ++i) {
                    m_ctx.faceToTriangles[faceIdx].push_back(triIndex++);
                }
            }

            std::cout << "Loaded OBJ: " << filepath << std::endl;
        } else {
            std::cerr << "Failed to load OBJ: " << filepath << std::endl;
        }
    }
}

void ModelingMode::saveEditableMeshAsLime() {
    if (!m_ctx.editableMesh.isValid()) {
        std::cerr << "No mesh to save" << std::endl;
        return;
    }

    std::string defaultName = "model.lime";
    if (m_ctx.selectedObject) {
        defaultName = m_ctx.selectedObject->getName() + ".lime";
    }

    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filters[1] = {{"LIME Model", "lime"}};
    nfdresult_t result = NFD_SaveDialog(&outPath, filters, 1, nullptr, defaultName.c_str());

    if (result == NFD_OKAY) {
        std::string filepath = outPath;
        NFD_FreePath(outPath);

        if (filepath.size() < 5 || filepath.substr(filepath.size() - 5) != ".lime") {
            filepath += ".lime";
        }

        // Get texture data if available
        const unsigned char* texData = nullptr;
        int texWidth = 0, texHeight = 0;
        if (m_ctx.selectedObject && m_ctx.selectedObject->hasTextureData()) {
            texData = m_ctx.selectedObject->getTextureData().data();
            texWidth = m_ctx.selectedObject->getTextureWidth();
            texHeight = m_ctx.selectedObject->getTextureHeight();
        }

        if (m_ctx.editableMesh.saveLime(filepath, texData, texWidth, texHeight)) {
            std::cout << "Saved LIME to: " << filepath << std::endl;
        } else {
            std::cerr << "Failed to save LIME: " << filepath << std::endl;
        }
    }
}

void ModelingMode::loadLimeFile() {
    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filters[1] = {{"LIME Model", "lime"}};
    nfdresult_t result = NFD_OpenDialog(&outPath, filters, 1, nullptr);

    if (result == NFD_OKAY) {
        std::string filepath = outPath;
        NFD_FreePath(outPath);

        std::vector<unsigned char> textureData;
        int texWidth = 0, texHeight = 0;

        if (m_ctx.editableMesh.loadLime(filepath, textureData, texWidth, texHeight)) {
            // Create a new SceneObject from the loaded mesh
            std::string meshName = std::filesystem::path(filepath).stem().string();
            auto obj = std::make_unique<SceneObject>(meshName);

            // Triangulate for GPU rendering
            std::vector<ModelVertex> vertices;
            std::vector<uint32_t> indices;
            m_ctx.editableMesh.triangulate(vertices, indices);

            // Create GPU model with texture if available
            uint32_t handle;
            if (!textureData.empty() && texWidth > 0 && texHeight > 0) {
                handle = m_ctx.modelRenderer.createModel(vertices, indices, textureData.data(), texWidth, texHeight);
                obj->setTextureData(textureData, texWidth, texHeight);
            } else {
                handle = m_ctx.modelRenderer.createModel(vertices, indices, nullptr, 0, 0);
            }

            obj->setBufferHandle(handle);
            obj->setIndexCount(static_cast<uint32_t>(indices.size()));
            obj->setVertexCount(static_cast<uint32_t>(vertices.size()));
            obj->setMeshData(vertices, indices);

            // Store half-edge data for proper quad preservation
            const auto& heVerts = m_ctx.editableMesh.getVerticesData();
            const auto& heHalfEdges = m_ctx.editableMesh.getHalfEdges();
            const auto& heFaces = m_ctx.editableMesh.getFacesData();

            std::vector<SceneObject::StoredHEVertex> storedVerts;
            storedVerts.reserve(heVerts.size());
            for (const auto& v : heVerts) {
                storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
            }

            std::vector<SceneObject::StoredHalfEdge> storedHE;
            storedHE.reserve(heHalfEdges.size());
            for (const auto& he : heHalfEdges) {
                storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
            }

            std::vector<SceneObject::StoredHEFace> storedFaces;
            storedFaces.reserve(heFaces.size());
            for (const auto& f : heFaces) {
                storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
            }

            obj->setEditableMeshData(storedVerts, storedHE, storedFaces);

            m_ctx.selectedObject = obj.get();
            m_ctx.sceneObjects.push_back(std::move(obj));

            // Update faceToTriangles mapping
            m_ctx.faceToTriangles.clear();
            uint32_t triIndex = 0;
            for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
                uint32_t vertCount = m_ctx.editableMesh.getFace(faceIdx).vertexCount;
                uint32_t triCount = (vertCount >= 3) ? (vertCount - 2) : 0;
                for (uint32_t i = 0; i < triCount; ++i) {
                    m_ctx.faceToTriangles[faceIdx].push_back(triIndex++);
                }
            }

            std::cout << "Loaded LIME: " << filepath;
            if (texWidth > 0 && texHeight > 0) {
                std::cout << " (with " << texWidth << "x" << texHeight << " texture)";
            }
            std::cout << std::endl;
        } else {
            std::cerr << "Failed to load LIME: " << filepath << std::endl;
        }
    }
}

void ModelingMode::drawQuadWireframeOverlay(Camera& camera, float vpX, float vpY, float vpW, float vpH) {
    if (!m_ctx.selectedObject || !m_ctx.editableMesh.isValid()) return;
    if (!m_ctx.selectedObject->isVisible()) return;

    glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));
    glm::mat4 view = camera.getViewMatrix();
    float aspectRatio = vpW / vpH;
    glm::mat4 proj = camera.getProjectionMatrix(aspectRatio);
    glm::mat4 vp = proj * view;

    glm::vec3 cameraPos = camera.getPosition();

    ImDrawList* drawList = ImGui::GetBackgroundDrawList();
    drawList->PushClipRect(ImVec2(vpX, vpY), ImVec2(vpX + vpW, vpY + vpH), true);

    auto worldToScreen = [&](const glm::vec3& localPos) -> ImVec2 {
        glm::vec4 worldPos = modelMatrix * glm::vec4(localPos, 1.0f);
        glm::vec4 clip = vp * worldPos;
        if (clip.w <= 0.0f) return ImVec2(-1000, -1000);
        glm::vec3 ndc = glm::vec3(clip) / clip.w;
        return ImVec2(vpX + (ndc.x + 1.0f) * 0.5f * vpW, vpY + (1.0f - ndc.y) * 0.5f * vpH);
    };

    auto isFaceFrontFacing = [&](uint32_t faceIdx) -> bool {
        glm::vec3 localCenter = m_ctx.editableMesh.getFaceCenter(faceIdx);
        glm::vec3 localNormal = m_ctx.editableMesh.getFaceNormal(faceIdx);
        glm::vec3 worldCenter = glm::vec3(modelMatrix * glm::vec4(localCenter, 1.0f));
        glm::vec3 worldNormal = glm::normalize(normalMatrix * localNormal);
        glm::vec3 viewDir = glm::normalize(cameraPos - worldCenter);
        return glm::dot(worldNormal, viewDir) > 0.0f;
    };

    ImU32 wireColor = IM_COL32(
        static_cast<int>(m_ctx.wireframeColor.r * 255),
        static_cast<int>(m_ctx.wireframeColor.g * 255),
        static_cast<int>(m_ctx.wireframeColor.b * 255),
        static_cast<int>(m_ctx.wireframeColor.a * 255));
    ImU32 selectedEdgeColor = IM_COL32(50, 100, 255, 255);
    float lineThickness = 2.0f;
    float selectedLineThickness = 4.0f;

    std::set<uint64_t> selectedEdgeKeys;
    auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
    for (uint32_t he : selectedEdges) {
        auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(he);
        uint64_t key = (static_cast<uint64_t>(std::min(v0, v1)) << 32) | static_cast<uint64_t>(std::max(v0, v1));
        selectedEdgeKeys.insert(key);
    }

    auto isEdgeSelected = [&](uint32_t vi0, uint32_t vi1) -> bool {
        uint64_t key = (static_cast<uint64_t>(std::min(vi0, vi1)) << 32) | static_cast<uint64_t>(std::max(vi0, vi1));
        return selectedEdgeKeys.count(key) > 0;
    };

    // Check if selected object has x-ray mode
    bool xrayMode = m_ctx.selectedObject && m_ctx.selectedObject->isXRay();

    if (xrayMode) {
        for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
            auto verts = m_ctx.editableMesh.getFaceVertices(faceIdx);
            if (verts.empty()) continue;

            for (size_t i = 0; i < verts.size(); ++i) {
                uint32_t vi0 = verts[i];
                uint32_t vi1 = verts[(i + 1) % verts.size()];
                const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
                const auto& v1 = m_ctx.editableMesh.getVertex(vi1);

                ImVec2 screenV0 = worldToScreen(v0.position);
                ImVec2 screenV1 = worldToScreen(v1.position);

                if (screenV0.x > -500 && screenV1.x > -500) {
                    bool selected = isEdgeSelected(vi0, vi1);
                    drawList->AddLine(screenV0, screenV1, selected ? selectedEdgeColor : wireColor,
                                     selected ? selectedLineThickness : lineThickness);
                }
            }
        }
    } else {
        std::set<uint64_t> drawnEdges;

        for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
            if (!isFaceFrontFacing(faceIdx)) continue;

            auto verts = m_ctx.editableMesh.getFaceVertices(faceIdx);
            if (verts.empty()) continue;

            for (size_t i = 0; i < verts.size(); ++i) {
                uint32_t vi0 = verts[i];
                uint32_t vi1 = verts[(i + 1) % verts.size()];

                uint64_t edgeKey = (static_cast<uint64_t>(std::min(vi0, vi1)) << 32) |
                                   static_cast<uint64_t>(std::max(vi0, vi1));

                if (drawnEdges.count(edgeKey) > 0) continue;
                drawnEdges.insert(edgeKey);

                const auto& v0 = m_ctx.editableMesh.getVertex(vi0);
                const auto& v1 = m_ctx.editableMesh.getVertex(vi1);

                ImVec2 screenV0 = worldToScreen(v0.position);
                ImVec2 screenV1 = worldToScreen(v1.position);

                if (screenV0.x > -500 && screenV1.x > -500) {
                    bool selected = isEdgeSelected(vi0, vi1);
                    drawList->AddLine(screenV0, screenV1, selected ? selectedEdgeColor : wireColor,
                                     selected ? selectedLineThickness : lineThickness);
                }
            }
        }
    }

    // Draw vertices in vertex mode
    if (m_ctx.modelingSelectionMode == ModelingSelectionMode::Vertex) {
        ImU32 vertexColor = IM_COL32(0, 200, 255, 255);
        ImU32 selectedVertexColor = IM_COL32(255, 150, 0, 255);
        ImU32 hoveredVertexColor = IM_COL32(255, 255, 0, 255);
        float vertexRadius = m_ctx.vertexDisplaySize * 100.0f;

        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
        std::set<uint32_t> selectedSet(selectedVerts.begin(), selectedVerts.end());

        for (uint32_t vi = 0; vi < m_ctx.editableMesh.getVertexCount(); ++vi) {
            const auto& v = m_ctx.editableMesh.getVertex(vi);

            auto faces = m_ctx.editableMesh.getVertexFaces(vi);
            bool visible = false;
            for (uint32_t faceIdx : faces) {
                if (isFaceFrontFacing(faceIdx)) {
                    visible = true;
                    break;
                }
            }

            if (!visible && !xrayMode) continue;

            ImVec2 screenPos = worldToScreen(v.position);
            if (screenPos.x < -500) continue;

            ImU32 color = vertexColor;
            float radius = vertexRadius;

            if (selectedSet.count(vi) > 0) {
                color = selectedVertexColor;
                radius = vertexRadius * 1.3f;
            }
            if (static_cast<int>(vi) == m_ctx.hoveredVertex) {
                color = hoveredVertexColor;
                radius = vertexRadius * 1.5f;
            }

            drawList->AddCircleFilled(screenPos, radius, color);
            drawList->AddCircle(screenPos, radius, IM_COL32(0, 0, 0, 200), 0, 1.5f);
        }
    }

    drawList->PopClipRect();
}

void ModelingMode::drawFaceNormalsOverlay(Camera& camera, float vpX, float vpY, float vpW, float vpH) {
    if (!m_ctx.showFaceNormals || !m_ctx.selectedObject || !m_ctx.editableMesh.isValid()) return;
    if (!m_ctx.selectedObject->isVisible()) return;

    glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
    glm::mat4 view = camera.getViewMatrix();
    float aspectRatio = vpW / vpH;
    glm::mat4 proj = camera.getProjectionMatrix(aspectRatio);
    glm::mat4 vp = proj * view;

    ImDrawList* drawList = ImGui::GetBackgroundDrawList();
    drawList->PushClipRect(ImVec2(vpX, vpY), ImVec2(vpX + vpW, vpY + vpH), true);

    auto worldToScreen = [&](const glm::vec3& localPos) -> ImVec2 {
        glm::vec4 worldPos = modelMatrix * glm::vec4(localPos, 1.0f);
        glm::vec4 clip = vp * worldPos;
        if (clip.w <= 0.0f) return ImVec2(-1000, -1000);
        glm::vec3 ndc = glm::vec3(clip) / clip.w;
        return ImVec2(vpX + (ndc.x + 1.0f) * 0.5f * vpW, vpY + (1.0f - ndc.y) * 0.5f * vpH);
    };

    ImU32 normalColor = IM_COL32(0, 255, 128, 255);

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        glm::vec3 center = m_ctx.editableMesh.getFaceCenter(faceIdx);
        glm::vec3 normal = m_ctx.editableMesh.getFaceNormal(faceIdx);
        glm::vec3 endPoint = center + normal * m_ctx.normalDisplayLength;

        ImVec2 screenStart = worldToScreen(center);
        ImVec2 screenEnd = worldToScreen(endPoint);

        if (screenStart.x > -500 && screenEnd.x > -500) {
            drawList->AddLine(screenStart, screenEnd, normalColor, 2.0f);
            drawList->AddCircleFilled(screenEnd, 3.0f, normalColor);
        }
    }

    drawList->PopClipRect();
}

void ModelingMode::drawReferenceImages(Camera& camera, float vpX, float vpY, float vpW, float vpH) {
    // Only draw reference images in ortho views
    if (camera.getProjectionMode() != ProjectionMode::Orthographic) return;

    ViewPreset preset = camera.getViewPreset();
    if (preset == ViewPreset::Custom) return;

    int viewIndex = static_cast<int>(preset) - 1;  // ViewPreset enum offset
    if (viewIndex < 0 || viewIndex >= 6) return;

    auto& ref = m_ctx.referenceImages[viewIndex];
    if (!ref.visible || !ref.loaded || !ref.descriptorSet) return;

    // Calculate view-projection for screen space conversion
    float orthoSize = camera.getOrthoSize();
    float aspect = vpW / vpH;
    glm::mat4 view = camera.getViewMatrix();
    glm::mat4 proj = glm::ortho(-orthoSize * aspect, orthoSize * aspect, -orthoSize, orthoSize, -1000.0f, 1000.0f);
    glm::mat4 viewProj = proj * view;

    // Get the plane axes and depth offset based on view preset
    // Place image at the far edge of the grid (behind the model)
    glm::vec3 right, up, depthOffset;
    float gridEdge = 10.0f;  // Match grid size

    switch (preset) {
        case ViewPreset::Top:
            right = glm::vec3(1, 0, 0);
            up = glm::vec3(0, 0, -1);
            depthOffset = glm::vec3(0, -0.1f, 0);  // Just below ground plane
            break;
        case ViewPreset::Bottom:
            right = glm::vec3(1, 0, 0);
            up = glm::vec3(0, 0, 1);
            depthOffset = glm::vec3(0, 0.1f, 0);  // Just above ground plane
            break;
        case ViewPreset::Front:
            right = glm::vec3(1, 0, 0);
            up = glm::vec3(0, 1, 0);
            depthOffset = glm::vec3(0, 0, -gridEdge);  // At back of grid
            break;
        case ViewPreset::Back:
            right = glm::vec3(-1, 0, 0);
            up = glm::vec3(0, 1, 0);
            depthOffset = glm::vec3(0, 0, gridEdge);  // At front of grid
            break;
        case ViewPreset::Right:
            right = glm::vec3(0, 0, -1);
            up = glm::vec3(0, 1, 0);
            depthOffset = glm::vec3(-gridEdge, 0, 0);  // At left edge
            break;
        case ViewPreset::Left:
            right = glm::vec3(0, 0, 1);
            up = glm::vec3(0, 1, 0);
            depthOffset = glm::vec3(gridEdge, 0, 0);  // At right edge
            break;
        default:
            return;
    }

    // Calculate world corners of the reference image
    glm::vec3 center = depthOffset + right * ref.offset.x + up * ref.offset.y;
    glm::vec3 halfSize = right * (ref.size.x * 0.5f) + up * (ref.size.y * 0.5f);

    glm::vec3 corners[4] = {
        center - right * (ref.size.x * 0.5f) - up * (ref.size.y * 0.5f),
        center + right * (ref.size.x * 0.5f) - up * (ref.size.y * 0.5f),
        center + right * (ref.size.x * 0.5f) + up * (ref.size.y * 0.5f),
        center - right * (ref.size.x * 0.5f) + up * (ref.size.y * 0.5f)
    };

    // Project to screen space
    ImVec2 screenCorners[4];
    for (int i = 0; i < 4; i++) {
        glm::vec4 clip = viewProj * glm::vec4(corners[i], 1.0f);
        glm::vec2 ndc = glm::vec2(clip.x, clip.y) / clip.w;
        screenCorners[i].x = vpX + (ndc.x * 0.5f + 0.5f) * vpW;
        screenCorners[i].y = vpY + (1.0f - (ndc.y * 0.5f + 0.5f)) * vpH;
    }

    // Draw the image using ImGui
    ImDrawList* drawList = ImGui::GetBackgroundDrawList();
    ImU32 tintColor = IM_COL32(255, 255, 255, static_cast<int>(ref.opacity * 255));

    drawList->AddImageQuad(
        (ImTextureID)ref.descriptorSet,
        screenCorners[0], screenCorners[1], screenCorners[2], screenCorners[3],
        ImVec2(0, 1), ImVec2(1, 1), ImVec2(1, 0), ImVec2(0, 0),
        tintColor
    );
}

// UV helper implementations
bool ModelingMode::pointInUVTriangle(const glm::vec2& p, const glm::vec2& a, const glm::vec2& b, const glm::vec2& c) {
    glm::vec2 v0 = c - a, v1 = b - a, v2 = p - a;
    float dot00 = glm::dot(v0, v0);
    float dot01 = glm::dot(v0, v1);
    float dot02 = glm::dot(v0, v2);
    float dot11 = glm::dot(v1, v1);
    float dot12 = glm::dot(v1, v2);
    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return (u >= 0) && (v >= 0) && (u + v <= 1);
}

int ModelingMode::findUVFaceAtPoint(const glm::vec2& uvPoint) {
    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        if (faceVerts.size() < 3) continue;

        std::vector<glm::vec2> uvs;
        for (uint32_t vertIdx : faceVerts) {
            uvs.push_back(m_ctx.editableMesh.getVertex(vertIdx).uv);
        }

        for (size_t i = 1; i + 1 < uvs.size(); ++i) {
            if (pointInUVTriangle(uvPoint, uvs[0], uvs[i], uvs[i + 1])) {
                return static_cast<int>(faceIdx);
            }
        }
    }
    return -1;
}

int ModelingMode::findUVVertexAtPoint(const glm::vec2& uvPoint, float threshold) {
    int closestVert = -1;
    float closestDist = threshold;

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t vertIdx : faceVerts) {
            glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
            float dist = glm::length(uv - uvPoint);
            if (dist < closestDist) {
                closestDist = dist;
                closestVert = static_cast<int>(vertIdx);
            }
        }
    }
    return closestVert;
}

void ModelingMode::storeOriginalUVsForVertices() {
    m_ctx.uvOriginalCoords.clear();
    for (uint32_t vertIdx : m_ctx.uvSelectedVertices) {
        m_ctx.uvOriginalCoords[vertIdx] = m_ctx.editableMesh.getVertex(vertIdx).uv;
    }
}

void ModelingMode::moveSelectedUVVertices(const glm::vec2& delta) {
    for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
        m_ctx.editableMesh.getVertex(vertIdx).uv = origUV + delta;
    }
}

void ModelingMode::selectUVIsland(uint32_t startFace) {
    std::set<uint32_t> visited;
    std::queue<uint32_t> toVisit;
    toVisit.push(startFace);
    visited.insert(startFace);

    auto uvKey = [](const glm::vec2& uv) {
        return std::make_pair(static_cast<int>(uv.x * 10000), static_cast<int>(uv.y * 10000));
    };

    std::map<std::pair<int, int>, std::vector<uint32_t>> uvToFaces;
    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t vertIdx : faceVerts) {
            glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
            uvToFaces[uvKey(uv)].push_back(faceIdx);
        }
    }

    while (!toVisit.empty()) {
        uint32_t faceIdx = toVisit.front();
        toVisit.pop();
        m_ctx.uvSelectedFaces.insert(faceIdx);

        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t vertIdx : faceVerts) {
            glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
            auto& adjacentFaces = uvToFaces[uvKey(uv)];
            for (uint32_t adjFace : adjacentFaces) {
                if (visited.find(adjFace) == visited.end()) {
                    visited.insert(adjFace);
                    toVisit.push(adjFace);
                }
            }
        }
    }
}

std::set<uint32_t> ModelingMode::getUVSelectedVertices() {
    std::set<uint32_t> verts;
    for (uint32_t faceIdx : m_ctx.uvSelectedFaces) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t v : faceVerts) {
            verts.insert(v);
        }
    }
    return verts;
}

void ModelingMode::getUVSelectionBounds(glm::vec2& outMin, glm::vec2& outMax) {
    outMin = glm::vec2(FLT_MAX);
    outMax = glm::vec2(-FLT_MAX);
    auto verts = getUVSelectedVertices();
    for (uint32_t vertIdx : verts) {
        glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
        outMin = glm::min(outMin, uv);
        outMax = glm::max(outMax, uv);
    }
}

void ModelingMode::storeOriginalUVs() {
    m_ctx.uvOriginalCoords.clear();
    auto verts = getUVSelectedVertices();
    for (uint32_t vertIdx : verts) {
        m_ctx.uvOriginalCoords[vertIdx] = m_ctx.editableMesh.getVertex(vertIdx).uv;
    }
}

void ModelingMode::moveSelectedUVs(const glm::vec2& delta) {
    for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
        m_ctx.editableMesh.getVertex(vertIdx).uv = origUV + delta;
    }
}

void ModelingMode::scaleSelectedUVs(const glm::vec2& center, float scale) {
    for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
        glm::vec2 offset = origUV - center;
        m_ctx.editableMesh.getVertex(vertIdx).uv = center + offset * scale;
    }
}

void ModelingMode::rotateSelectedUVs(const glm::vec2& center, float angleDegrees) {
    float rad = glm::radians(angleDegrees);
    float cosA = std::cos(rad);
    float sinA = std::sin(rad);
    for (auto& [vertIdx, origUV] : m_ctx.uvOriginalCoords) {
        glm::vec2 offset = origUV - center;
        glm::vec2 rotated;
        rotated.x = offset.x * cosA - offset.y * sinA;
        rotated.y = offset.x * sinA + offset.y * cosA;
        m_ctx.editableMesh.getVertex(vertIdx).uv = center + rotated;
    }
}

float ModelingMode::pointToLineSegmentDistUV(const glm::vec2& p, const glm::vec2& a, const glm::vec2& b) {
    glm::vec2 ab = b - a;
    float len2 = glm::dot(ab, ab);
    if (len2 < 0.00001f) return glm::length(p - a);
    float t = glm::clamp(glm::dot(p - a, ab) / len2, 0.0f, 1.0f);
    glm::vec2 proj = a + t * ab;
    return glm::length(p - proj);
}

std::pair<uint32_t, uint32_t> ModelingMode::findUVEdgeAtPoint(const glm::vec2& uvPoint, float threshold) {
    float bestDist = threshold;
    std::pair<uint32_t, uint32_t> bestEdge = {UINT32_MAX, UINT32_MAX};

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        if (faceVerts.size() < 3) continue;

        for (size_t i = 0; i < faceVerts.size(); ++i) {
            size_t next = (i + 1) % faceVerts.size();
            glm::vec2 uv0 = m_ctx.editableMesh.getVertex(faceVerts[i]).uv;
            glm::vec2 uv1 = m_ctx.editableMesh.getVertex(faceVerts[next]).uv;

            float dist = pointToLineSegmentDistUV(uvPoint, uv0, uv1);
            if (dist < bestDist) {
                bestDist = dist;
                bestEdge = {faceIdx, static_cast<uint32_t>(i)};
            }
        }
    }
    return bestEdge;
}

std::pair<glm::vec3, glm::vec3> ModelingMode::getEdge3DPositions(uint32_t faceIdx, uint32_t localEdgeIdx) {
    auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
    uint32_t v0 = faceVerts[localEdgeIdx];
    uint32_t v1 = faceVerts[(localEdgeIdx + 1) % faceVerts.size()];
    return {m_ctx.editableMesh.getVertex(v0).position, m_ctx.editableMesh.getVertex(v1).position};
}

std::pair<glm::vec2, glm::vec2> ModelingMode::getEdgeUVs(uint32_t faceIdx, uint32_t localEdgeIdx) {
    auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
    uint32_t v0 = faceVerts[localEdgeIdx];
    uint32_t v1 = faceVerts[(localEdgeIdx + 1) % faceVerts.size()];
    return {m_ctx.editableMesh.getVertex(v0).uv, m_ctx.editableMesh.getVertex(v1).uv};
}

bool ModelingMode::positions3DEqual(const glm::vec3& a, const glm::vec3& b, float tol) {
    return glm::length(a - b) < tol;
}

void ModelingMode::findTwinUVEdges(uint32_t selectedFaceIdx, uint32_t selectedEdgeIdx) {
    m_ctx.uvTwinEdges.clear();

    if (selectedFaceIdx == UINT32_MAX) return;

    auto [pos0, pos1] = getEdge3DPositions(selectedFaceIdx, selectedEdgeIdx);
    auto [selUV0, selUV1] = getEdgeUVs(selectedFaceIdx, selectedEdgeIdx);

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        if (faceVerts.size() < 3) continue;

        for (size_t i = 0; i < faceVerts.size(); ++i) {
            if (faceIdx == selectedFaceIdx && i == selectedEdgeIdx) continue;

            auto [edgePos0, edgePos1] = getEdge3DPositions(faceIdx, static_cast<uint32_t>(i));
            auto [edgeUV0, edgeUV1] = getEdgeUVs(faceIdx, static_cast<uint32_t>(i));

            bool match = (positions3DEqual(pos0, edgePos0) && positions3DEqual(pos1, edgePos1)) ||
                         (positions3DEqual(pos0, edgePos1) && positions3DEqual(pos1, edgePos0));

            if (match) {
                bool uvSame = (glm::length(selUV0 - edgeUV0) < 0.001f && glm::length(selUV1 - edgeUV1) < 0.001f) ||
                              (glm::length(selUV0 - edgeUV1) < 0.001f && glm::length(selUV1 - edgeUV0) < 0.001f);

                if (!uvSame) {
                    m_ctx.uvTwinEdges.push_back({faceIdx, static_cast<uint32_t>(i)});
                }
            }
        }
    }
}

void ModelingMode::clearUVEdgeSelection() {
    m_ctx.uvSelectedEdge = {UINT32_MAX, UINT32_MAX};
    m_ctx.uvTwinEdges.clear();
}

std::set<uint32_t> ModelingMode::getUVIslandFaces(uint32_t startFace) {
    std::set<uint32_t> island;
    std::queue<uint32_t> toVisit;
    toVisit.push(startFace);
    island.insert(startFace);

    auto uvKey = [](const glm::vec2& uv) {
        return std::make_pair(static_cast<int>(uv.x * 10000), static_cast<int>(uv.y * 10000));
    };

    std::map<std::pair<int, int>, std::vector<uint32_t>> uvToFaces;
    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t vertIdx : faceVerts) {
            glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
            uvToFaces[uvKey(uv)].push_back(faceIdx);
        }
    }

    while (!toVisit.empty()) {
        uint32_t faceIdx = toVisit.front();
        toVisit.pop();

        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t vertIdx : faceVerts) {
            glm::vec2 uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
            auto& adjacentFaces = uvToFaces[uvKey(uv)];
            for (uint32_t adjFace : adjacentFaces) {
                if (island.find(adjFace) == island.end()) {
                    island.insert(adjFace);
                    toVisit.push(adjFace);
                }
            }
        }
    }
    return island;
}

std::set<uint32_t> ModelingMode::getIslandVertices(const std::set<uint32_t>& faces) {
    std::set<uint32_t> verts;
    for (uint32_t faceIdx : faces) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (uint32_t v : faceVerts) {
            verts.insert(v);
        }
    }
    return verts;
}

void ModelingMode::sewSelectedEdge() {
    if (m_ctx.uvSelectedEdge.first == UINT32_MAX || m_ctx.uvTwinEdges.empty()) return;

    m_ctx.editableMesh.saveState();

    auto [selUV0, selUV1] = getEdgeUVs(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);
    auto [selPos0, selPos1] = getEdge3DPositions(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);

    auto [twinFaceIdx, twinEdgeIdx] = m_ctx.uvTwinEdges[0];
    auto [twinPos0, twinPos1] = getEdge3DPositions(twinFaceIdx, twinEdgeIdx);

    bool reversed = positions3DEqual(selPos0, twinPos1) && positions3DEqual(selPos1, twinPos0);

    auto twinFaceVerts = m_ctx.editableMesh.getFaceVertices(twinFaceIdx);
    uint32_t twinV0 = twinFaceVerts[twinEdgeIdx];
    uint32_t twinV1 = twinFaceVerts[(twinEdgeIdx + 1) % twinFaceVerts.size()];

    m_ctx.editableMesh.getVertex(twinV0).uv = reversed ? selUV1 : selUV0;
    m_ctx.editableMesh.getVertex(twinV1).uv = reversed ? selUV0 : selUV1;

    m_ctx.meshDirty = true;
    clearUVEdgeSelection();

    std::cout << "Sewn edge vertices" << std::endl;
}

void ModelingMode::moveAndSewSelectedEdge() {
    if (m_ctx.uvSelectedEdge.first == UINT32_MAX || m_ctx.uvTwinEdges.empty()) return;

    m_ctx.editableMesh.saveState();

    auto [selUV0, selUV1] = getEdgeUVs(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);
    auto [selPos0, selPos1] = getEdge3DPositions(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);

    auto [twinFaceIdx, twinEdgeIdx] = m_ctx.uvTwinEdges[0];
    auto [twinUV0, twinUV1] = getEdgeUVs(twinFaceIdx, twinEdgeIdx);
    auto [twinPos0, twinPos1] = getEdge3DPositions(twinFaceIdx, twinEdgeIdx);

    bool reversed = positions3DEqual(selPos0, twinPos1) && positions3DEqual(selPos1, twinPos0);

    // Get both islands
    std::set<uint32_t> selIsland = getUVIslandFaces(m_ctx.uvSelectedEdge.first);
    std::set<uint32_t> selVerts = getIslandVertices(selIsland);
    std::set<uint32_t> twinIsland = getUVIslandFaces(twinFaceIdx);
    std::set<uint32_t> twinVerts = getIslandVertices(twinIsland);

    auto selFaceVerts = m_ctx.editableMesh.getFaceVertices(m_ctx.uvSelectedEdge.first);
    uint32_t selV0 = selFaceVerts[m_ctx.uvSelectedEdge.second];
    uint32_t selV1 = selFaceVerts[(m_ctx.uvSelectedEdge.second + 1) % selFaceVerts.size()];

    auto twinFaceVerts = m_ctx.editableMesh.getFaceVertices(twinFaceIdx);
    uint32_t twinV0 = twinFaceVerts[twinEdgeIdx];
    uint32_t twinV1 = twinFaceVerts[(twinEdgeIdx + 1) % twinFaceVerts.size()];

    // Calculate midpoints of each edge
    glm::vec2 selMid = (selUV0 + selUV1) * 0.5f;
    glm::vec2 twinMid = (twinUV0 + twinUV1) * 0.5f;

    // Calculate the global midpoint where both edges should meet
    glm::vec2 globalMid = (selMid + twinMid) * 0.5f;

    // Calculate final UV positions at the midpoint
    glm::vec2 selDir = glm::normalize(selUV1 - selUV0);
    float selLen = glm::length(selUV1 - selUV0);
    glm::vec2 finalUV0 = globalMid - selDir * (selLen * 0.5f);
    glm::vec2 finalUV1 = globalMid + selDir * (selLen * 0.5f);

    // Move selected island to the midpoint
    glm::vec2 selOffset = globalMid - selMid;
    for (uint32_t vertIdx : selVerts) {
        m_ctx.editableMesh.getVertex(vertIdx).uv += selOffset;
    }

    // Move twin island: rotate to match selected edge direction, then translate to midpoint
    glm::vec2 twinDir = glm::normalize(twinUV1 - twinUV0);
    glm::vec2 targetDir = reversed ? -selDir : selDir;

    float twinAngle = std::atan2(twinDir.y, twinDir.x);
    float targetAngle = std::atan2(targetDir.y, targetDir.x);
    float rotAngle = targetAngle - twinAngle;

    float cosA = std::cos(rotAngle);
    float sinA = std::sin(rotAngle);

    for (uint32_t vertIdx : twinVerts) {
        glm::vec2& uv = m_ctx.editableMesh.getVertex(vertIdx).uv;
        glm::vec2 offset = uv - twinMid;
        glm::vec2 rotated;
        rotated.x = offset.x * cosA - offset.y * sinA;
        rotated.y = offset.x * sinA + offset.y * cosA;
        uv = rotated + globalMid;
    }

    // Snap edge vertices to exact positions
    m_ctx.editableMesh.getVertex(selV0).uv = finalUV0;
    m_ctx.editableMesh.getVertex(selV1).uv = finalUV1;
    m_ctx.editableMesh.getVertex(twinV0).uv = reversed ? finalUV1 : finalUV0;
    m_ctx.editableMesh.getVertex(twinV1).uv = reversed ? finalUV0 : finalUV1;

    m_ctx.meshDirty = true;
    clearUVEdgeSelection();

    std::cout << "Move & Sew: both islands meet at midpoint" << std::endl;
}

void ModelingMode::unsewSelectedEdge() {
    if (m_ctx.uvSelectedEdge.first == UINT32_MAX) return;

    auto selFaceVerts = m_ctx.editableMesh.getFaceVertices(m_ctx.uvSelectedEdge.first);
    uint32_t selV0 = selFaceVerts[m_ctx.uvSelectedEdge.second];
    uint32_t selV1 = selFaceVerts[(m_ctx.uvSelectedEdge.second + 1) % selFaceVerts.size()];

    glm::vec2 selUV0 = m_ctx.editableMesh.getVertex(selV0).uv;
    glm::vec2 selUV1 = m_ctx.editableMesh.getVertex(selV1).uv;

    std::vector<std::pair<uint32_t, uint32_t>> sharedEdges;

    for (uint32_t faceIdx = 0; faceIdx < m_ctx.editableMesh.getFaceCount(); ++faceIdx) {
        if (faceIdx == m_ctx.uvSelectedEdge.first) continue;

        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        for (size_t i = 0; i < faceVerts.size(); ++i) {
            size_t next = (i + 1) % faceVerts.size();
            glm::vec2 uv0 = m_ctx.editableMesh.getVertex(faceVerts[i]).uv;
            glm::vec2 uv1 = m_ctx.editableMesh.getVertex(faceVerts[next]).uv;

            bool match = (glm::length(selUV0 - uv0) < 0.0001f && glm::length(selUV1 - uv1) < 0.0001f) ||
                         (glm::length(selUV0 - uv1) < 0.0001f && glm::length(selUV1 - uv0) < 0.0001f);

            if (match) {
                sharedEdges.push_back({faceIdx, static_cast<uint32_t>(i)});
            }
        }
    }

    if (sharedEdges.empty()) {
        std::cout << "Edge is not sewn (no shared UV edges found)" << std::endl;
        return;
    }

    m_ctx.editableMesh.saveState();

    glm::vec2 edgeDir = glm::normalize(selUV1 - selUV0);
    glm::vec2 offsetDir(-edgeDir.y, edgeDir.x);
    float offsetAmount = 0.02f;

    for (auto& [faceIdx, edgeIdx] : sharedEdges) {
        auto faceVerts = m_ctx.editableMesh.getFaceVertices(faceIdx);
        uint32_t v0 = faceVerts[edgeIdx];
        uint32_t v1 = faceVerts[(edgeIdx + 1) % faceVerts.size()];

        m_ctx.editableMesh.getVertex(v0).uv += offsetDir * offsetAmount;
        m_ctx.editableMesh.getVertex(v1).uv += offsetDir * offsetAmount;
    }

    m_ctx.meshDirty = true;
    findTwinUVEdges(m_ctx.uvSelectedEdge.first, m_ctx.uvSelectedEdge.second);

    std::cout << "Unsewn edge: separated " << sharedEdges.size() << " shared edge(s)" << std::endl;
}

void ModelingMode::loadReferenceImage(int viewIndex) {
    nfdchar_t* outPath = nullptr;
    nfdfilteritem_t filterItem[1] = {{"Images", "png,jpg,jpeg,bmp,tga"}};

    nfdresult_t result = NFD_OpenDialog(&outPath, filterItem, 1, nullptr);

    if (result == NFD_OKAY && outPath) {
        if (m_ctx.loadReferenceImageCallback) {
            m_ctx.loadReferenceImageCallback(viewIndex, std::string(outPath));
        }
        NFD_FreePath(outPath);
    }
}

// ============================================================================
// Gizmo Implementation
// ============================================================================

glm::vec3 ModelingMode::getGizmoPosition() {
    if (!m_ctx.selectedObject) return glm::vec3(0.0f);

    // Use custom pivot if set (e.g., after face snap)
    if (m_useCustomGizmoPivot) {
        return m_customGizmoPivot;
    }

    glm::vec3 basePos;

    // In object mode, gizmo is on top of the model
    if (m_ctx.objectMode) {
        // Calculate bounding box of mesh and place gizmo on top
        if (m_ctx.editableMesh.getVertexCount() > 0) {
            glm::vec3 center(0.0f);
            float maxY = -std::numeric_limits<float>::max();

            for (size_t i = 0; i < m_ctx.editableMesh.getVertexCount(); ++i) {
                const glm::vec3& pos = m_ctx.editableMesh.getVertex(static_cast<uint32_t>(i)).position;
                center += pos;
                if (pos.y > maxY) {
                    maxY = pos.y;
                }
            }
            center /= static_cast<float>(m_ctx.editableMesh.getVertexCount());

            // Use center X/Z but top Y
            glm::vec3 gizmoLocalPos(center.x, maxY, center.z);
            glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();
            basePos = glm::vec3(modelMatrix * glm::vec4(gizmoLocalPos, 1.0f));
        } else {
            basePos = m_ctx.selectedObject->getTransform().getPosition();
        }
    } else {
        // Count selected components
        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();

        int numSelectedComponents = 0;
        if (!selectedVerts.empty()) numSelectedComponents += selectedVerts.size();
        else if (!selectedEdges.empty()) numSelectedComponents += selectedEdges.size();
        else if (!selectedFaces.empty()) numSelectedComponents += selectedFaces.size();

        // Collect all vertices from any selection type
        std::set<uint32_t> allVerts;

        // Add directly selected vertices
        for (uint32_t vi : selectedVerts) {
            allVerts.insert(vi);
        }

        // Add vertices from selected edges
        for (uint32_t ei : selectedEdges) {
            auto edgeVerts = m_ctx.editableMesh.getEdgeVertices(ei);
            allVerts.insert(edgeVerts.first);
            allVerts.insert(edgeVerts.second);
        }

        // Add vertices from selected faces
        for (uint32_t fi : selectedFaces) {
            auto verts = m_ctx.editableMesh.getFaceVertices(fi);
            for (uint32_t vi : verts) {
                allVerts.insert(vi);
            }
        }

        if (!allVerts.empty()) {
            glm::mat4 modelMatrix = m_ctx.selectedObject->getTransform().getMatrix();

            if (numSelectedComponents == 1) {
                // Single component selected: place gizmo at its center
                glm::vec3 center(0.0f);
                for (uint32_t vi : allVerts) {
                    center += m_ctx.editableMesh.getVertex(vi).position;
                }
                center /= static_cast<float>(allVerts.size());
                basePos = glm::vec3(modelMatrix * glm::vec4(center, 1.0f));
            } else {
                // Multiple components selected: place gizmo on top (highest Y)
                // Calculate center X/Z but use max Y
                glm::vec3 center(0.0f);
                float maxY = -std::numeric_limits<float>::max();

                for (uint32_t vi : allVerts) {
                    glm::vec3 pos = m_ctx.editableMesh.getVertex(vi).position;
                    center += pos;
                    if (pos.y > maxY) {
                        maxY = pos.y;
                    }
                }
                center /= static_cast<float>(allVerts.size());

                // Use center X/Z but top Y
                glm::vec3 gizmoLocalPos(center.x, maxY, center.z);
                basePos = glm::vec3(modelMatrix * glm::vec4(gizmoLocalPos, 1.0f));
            }
        } else {
            // Default to object origin
            basePos = m_ctx.selectedObject->getTransform().getPosition();
        }
    }

    // Apply user offset
    return basePos + m_ctx.gizmoOffset;
}

void ModelingMode::getGizmoAxes(glm::vec3& xAxis, glm::vec3& yAxis, glm::vec3& zAxis) {
    // Default world space axes
    xAxis = glm::vec3(1, 0, 0);
    yAxis = glm::vec3(0, 1, 0);
    zAxis = glm::vec3(0, 0, 1);

    // Only apply local space for Move mode with face selection
    if (!m_ctx.gizmoLocalSpace || m_ctx.gizmoMode != GizmoMode::Move || m_ctx.objectMode) {
        return;
    }

    // Calculate average normal from selected faces
    auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
    if (selectedFaces.empty()) return;

    glm::vec3 avgNormal(0.0f);
    for (uint32_t fi : selectedFaces) {
        glm::vec3 faceNormal = m_ctx.editableMesh.getFaceNormal(fi);
        avgNormal += faceNormal;
    }
    avgNormal = glm::normalize(avgNormal);

    // Transform normal to world space if we have an object
    if (m_ctx.selectedObject) {
        glm::mat4 modelMat = m_ctx.selectedObject->getTransform().getMatrix();
        glm::mat3 normalMat = glm::transpose(glm::inverse(glm::mat3(modelMat)));
        avgNormal = glm::normalize(normalMat * avgNormal);
    }

    // Z axis is the face normal
    zAxis = avgNormal;

    // Build orthonormal basis - X and Y perpendicular to Z
    glm::vec3 up = (std::abs(avgNormal.y) < 0.9f) ? glm::vec3(0, 1, 0) : glm::vec3(1, 0, 0);
    xAxis = glm::normalize(glm::cross(up, zAxis));
    yAxis = glm::normalize(glm::cross(zAxis, xAxis));
}

float ModelingMode::rayAxisDistance(const glm::vec3& rayOrigin, const glm::vec3& rayDir,
                                     const glm::vec3& axisOrigin, const glm::vec3& axisDir) {
    // Find closest point between ray and axis line
    glm::vec3 w0 = rayOrigin - axisOrigin;
    float a = glm::dot(rayDir, rayDir);
    float b = glm::dot(rayDir, axisDir);
    float c = glm::dot(axisDir, axisDir);
    float d = glm::dot(rayDir, w0);
    float e = glm::dot(axisDir, w0);

    float denom = a * c - b * b;
    if (std::abs(denom) < 0.0001f) return FLT_MAX;

    float t = (b * e - c * d) / denom;
    float s = (a * e - b * d) / denom;

    // Clamp s to axis length (0 to gizmoSize)
    s = std::clamp(s, 0.0f, m_ctx.gizmoSize);

    glm::vec3 pointOnRay = rayOrigin + rayDir * t;
    glm::vec3 pointOnAxis = axisOrigin + axisDir * s;

    return glm::length(pointOnRay - pointOnAxis);
}

glm::vec3 ModelingMode::projectPointOntoAxis(const glm::vec3& point, const glm::vec3& axisOrigin, const glm::vec3& axisDir) {
    glm::vec3 v = point - axisOrigin;
    float t = glm::dot(v, axisDir);
    return axisOrigin + axisDir * t;
}

GizmoAxis ModelingMode::pickGizmoAxis(const glm::vec3& rayOrigin, const glm::vec3& rayDir, const glm::vec3& gizmoPos) {
    float threshold = 0.15f * m_ctx.gizmoSize;  // Pick tolerance

    // In scale mode, check center cube first for uniform scaling
    if (m_ctx.gizmoMode == GizmoMode::Scale) {
        float centerCubeSize = m_ctx.gizmoSize * 0.12f * 1.2f;  // Match render size
        // Simple ray-box intersection for center cube
        glm::vec3 toGizmo = gizmoPos - rayOrigin;
        float t = glm::dot(toGizmo, rayDir);
        if (t > 0) {
            glm::vec3 closestPoint = rayOrigin + rayDir * t;
            float dist = glm::length(closestPoint - gizmoPos);
            if (dist < centerCubeSize * 1.5f) {
                return GizmoAxis::Uniform;
            }
        }
    }

    // In rotate mode, pick circles instead of axis lines
    if (m_ctx.gizmoMode == GizmoMode::Rotate) {
        float circleRadius = m_ctx.gizmoSize * 0.9f;
        float ringThreshold = threshold * 1.5f;

        // Helper lambda to check ray-circle intersection
        auto checkCircle = [&](const glm::vec3& normal) -> float {
            // Intersect ray with plane
            float denom = glm::dot(rayDir, normal);
            if (std::abs(denom) < 0.0001f) return 999.0f;
            float t = glm::dot(gizmoPos - rayOrigin, normal) / denom;
            if (t < 0) return 999.0f;
            glm::vec3 hitPoint = rayOrigin + rayDir * t;
            float distFromCenter = glm::length(hitPoint - gizmoPos);
            // Check if hit is on the ring (near the circle radius)
            return std::abs(distFromCenter - circleRadius);
        };

        float distX = checkCircle(glm::vec3(1, 0, 0));
        float distY = checkCircle(glm::vec3(0, 1, 0));
        float distZ = checkCircle(glm::vec3(0, 0, 1));

        float minDist = std::min({distX, distY, distZ});
        if (minDist > ringThreshold) return GizmoAxis::None;

        if (minDist == distX) return GizmoAxis::X;
        if (minDist == distY) return GizmoAxis::Y;
        return GizmoAxis::Z;
    }

    // Move/Scale mode: pick axis lines using local or world space axes
    glm::vec3 gizmoXAxis, gizmoYAxis, gizmoZAxis;
    getGizmoAxes(gizmoXAxis, gizmoYAxis, gizmoZAxis);

    float distX = rayAxisDistance(rayOrigin, rayDir, gizmoPos, gizmoXAxis);
    float distY = rayAxisDistance(rayOrigin, rayDir, gizmoPos, gizmoYAxis);
    float distZ = rayAxisDistance(rayOrigin, rayDir, gizmoPos, gizmoZAxis);

    float minDist = std::min({distX, distY, distZ});

    if (minDist > threshold) return GizmoAxis::None;

    if (minDist == distX) return GizmoAxis::X;
    if (minDist == distY) return GizmoAxis::Y;
    return GizmoAxis::Z;
}

bool ModelingMode::processGizmoInput() {
    if (m_ctx.gizmoMode == GizmoMode::None) return false;
    // Use IsWindowHovered for mouse-over detection
    if (ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)) return false;
    if (!m_ctx.selectedObject) return false;

    // In object mode, gizmo always shows for selected object
    // In component mode, need actual component selection
    if (!m_ctx.objectMode) {
        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
        auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        bool hasSelection = !selectedVerts.empty() || !selectedFaces.empty() || !selectedEdges.empty();
        if (!hasSelection) return false;
    }

    glm::vec3 gizmoPos = getGizmoPosition();

    // Get mouse ray
    glm::vec3 rayOrigin, rayDir;
    m_ctx.getMouseRay(rayOrigin, rayDir);

    // Handle dragging
    if (m_ctx.gizmoDragging) {
        if (!Input::isMouseButtonDown(Input::MOUSE_LEFT)) {
            // End drag
            m_ctx.gizmoDragging = false;
            m_ctx.gizmoActiveAxis = GizmoAxis::None;
        } else {
            // Continue drag
            // Get local or world space axes
            glm::vec3 gizmoXAxis, gizmoYAxis, gizmoZAxis;
            getGizmoAxes(gizmoXAxis, gizmoYAxis, gizmoZAxis);

            glm::vec3 axisDir(0.0f);
            switch (m_ctx.gizmoActiveAxis) {
                case GizmoAxis::X: axisDir = gizmoXAxis; break;
                case GizmoAxis::Y: axisDir = gizmoYAxis; break;
                case GizmoAxis::Z: axisDir = gizmoZAxis; break;
                case GizmoAxis::Uniform: axisDir = glm::normalize(glm::vec3(1, 1, 1)); break;
                default: return true;  // Still dragging, consume input
            }

            // Handle ROTATE mode separately using mouse position delta
            if (m_ctx.gizmoMode == GizmoMode::Rotate) {
                // For rotation, gizmoDragStart.x/y stores the last mouse position
                glm::vec2 currentMouse = Input::getMousePosition();
                glm::vec2 lastMouse(m_ctx.gizmoDragStart.x, m_ctx.gizmoDragStart.y);
                glm::vec2 mouseDelta = currentMouse - lastMouse;

                float sensitivity = 0.5f;  // degrees per pixel
                float angle = -(mouseDelta.x) * sensitivity;

                // Apply rotation snap if enabled
                if (m_ctx.snapEnabled && m_ctx.rotateSnapIncrement > 0.0f) {
                    // Track accumulated rotation and only apply when crossing snap threshold
                    static float accumulatedAngle = 0.0f;
                    accumulatedAngle += angle;
                    float snappedAngle = std::floor(accumulatedAngle / m_ctx.rotateSnapIncrement) * m_ctx.rotateSnapIncrement;
                    angle = snappedAngle;
                    accumulatedAngle -= snappedAngle;
                }

                if (std::abs(angle) > 0.001f) {
                    if (m_ctx.objectMode && m_ctx.selectedObject) {
                        // Object mode: rotate the object's transform
                        m_ctx.selectedObject->getTransform().rotate(angle, axisDir);
                    } else if (!m_ctx.objectMode && m_ctx.selectedObject) {
                        // Component mode: rotate selected vertices around selection center
                        std::set<uint32_t> vertsToTransform;
                        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
                        for (uint32_t vi : selectedVerts) vertsToTransform.insert(vi);
                        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
                        for (uint32_t ei : selectedEdges) {
                            auto edgeVerts = m_ctx.editableMesh.getEdgeVertices(ei);
                            vertsToTransform.insert(edgeVerts.first);
                            vertsToTransform.insert(edgeVerts.second);
                        }
                        auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
                        for (uint32_t fi : selectedFaces) {
                            auto faceVerts = m_ctx.editableMesh.getFaceVertices(fi);
                            for (uint32_t vi : faceVerts) vertsToTransform.insert(vi);
                        }

                        if (!vertsToTransform.empty()) {
                            auto posKey = [](const glm::vec3& p) -> uint64_t {
                                int32_t x = static_cast<int32_t>(p.x * 10000.0f);
                                int32_t y = static_cast<int32_t>(p.y * 10000.0f);
                                int32_t z = static_cast<int32_t>(p.z * 10000.0f);
                                return (static_cast<uint64_t>(x & 0xFFFFF) << 40) |
                                       (static_cast<uint64_t>(y & 0xFFFFF) << 20) |
                                       static_cast<uint64_t>(z & 0xFFFFF);
                            };

                            std::set<uint64_t> positionsToTransform;
                            for (uint32_t vi : vertsToTransform) {
                                positionsToTransform.insert(posKey(m_ctx.editableMesh.getVertex(vi).position));
                            }

                            glm::vec3 pivot = m_ctx.editableMesh.getSelectionCenter();
                            glm::mat4 modelMat = m_ctx.selectedObject->getTransform().getMatrix();
                            glm::mat4 invModel = glm::inverse(modelMat);

                            // Transform axis to local space for rotation (radians for component mode)
                            float angleRad = glm::radians(angle);
                            glm::vec3 localAxis = glm::normalize(glm::vec3(invModel * glm::vec4(axisDir, 0.0f)));
                            glm::quat rotation = glm::angleAxis(angleRad, localAxis);
                            glm::mat4 rotMat = glm::mat4_cast(rotation);

                            for (size_t vi = 0; vi < m_ctx.editableMesh.getVertexCount(); ++vi) {
                                auto& v = m_ctx.editableMesh.getVertex(static_cast<uint32_t>(vi));
                                if (positionsToTransform.count(posKey(v.position))) {
                                    glm::vec3 relPos = v.position - pivot;
                                    v.position = pivot + glm::vec3(rotMat * glm::vec4(relPos, 1.0f));
                                }
                            }
                            m_ctx.meshDirty = true;
                        }
                    }
                }
                // Update stored mouse position for next frame
                m_ctx.gizmoDragStart = glm::vec3(currentMouse.x, currentMouse.y, 0.0f);
                return true;  // Rotation handled, don't continue to move/scale logic
            }

            // For Move/Scale: project mouse onto axis
            glm::vec3 w0 = rayOrigin - m_ctx.gizmoDragStartPos;
            float a = glm::dot(rayDir, rayDir);
            float b = glm::dot(rayDir, axisDir);
            float c = glm::dot(axisDir, axisDir);
            float d = glm::dot(rayDir, w0);
            float e = glm::dot(axisDir, w0);

            float denom = a * c - b * b;
            if (std::abs(denom) > 0.0001f) {
                float s = (a * e - b * d) / denom;
                glm::vec3 currentPoint = m_ctx.gizmoDragStartPos + axisDir * s;
                glm::vec3 startPoint = projectPointOntoAxis(m_ctx.gizmoDragStart, m_ctx.gizmoDragStartPos, axisDir);

                glm::vec3 delta = currentPoint - startPoint;

                // Apply move snap if enabled (for Move mode only)
                bool useSnap = m_ctx.snapEnabled && m_ctx.moveSnapIncrement > 0.0f && m_ctx.gizmoMode == GizmoMode::Move;
                if (useSnap) {
                    // Snap the delta length to the nearest increment
                    float deltaLen = glm::dot(delta, axisDir);  // Signed length along axis
                    float snappedLen = std::round(deltaLen / m_ctx.moveSnapIncrement) * m_ctx.moveSnapIncrement;
                    delta = axisDir * snappedLen;
                }

                if (m_ctx.objectMode && m_ctx.selectedObject) {
                    auto& transform = m_ctx.selectedObject->getTransform();

                    if (m_ctx.gizmoMode == GizmoMode::Scale) {
                        // Object mode scale: adjust transform scale
                        float deltaLen = glm::dot(delta, axisDir);
                        float scaleFactor = 1.0f + deltaLen * 0.5f;
                        scaleFactor = std::max(0.01f, scaleFactor);

                        glm::vec3 currentScale = transform.getScale();
                        if (m_ctx.gizmoActiveAxis == GizmoAxis::X) {
                            currentScale.x *= scaleFactor;
                        } else if (m_ctx.gizmoActiveAxis == GizmoAxis::Y) {
                            currentScale.y *= scaleFactor;
                        } else if (m_ctx.gizmoActiveAxis == GizmoAxis::Z) {
                            currentScale.z *= scaleFactor;
                        } else if (m_ctx.gizmoActiveAxis == GizmoAxis::Uniform) {
                            currentScale *= scaleFactor;
                        }
                        transform.setScale(currentScale);
                        // Update drag start for incremental scale
                        m_ctx.gizmoDragStart = currentPoint;
                        m_ctx.gizmoDragStartPos = getGizmoPosition();
                    } else {
                        // Object mode move
                        if (useSnap) {
                            // For snap: set position relative to original object position
                            // Use stored original position to avoid initial jump
                            transform.setPosition(m_ctx.gizmoOriginalObjPos + delta);
                            // DON'T update gizmoDragStart - keep original for total delta calculation
                        } else {
                            // Non-snap: incremental movement
                            transform.setPosition(transform.getPosition() + delta);
                            // Update drag start for incremental movement
                            m_ctx.gizmoDragStart = currentPoint;
                            m_ctx.gizmoDragStartPos = getGizmoPosition();
                        }
                    }
                } else {
                    // Component mode: move or scale selected vertices/edges/faces
                    std::set<uint32_t> vertsToTransform;

                    // Add directly selected vertices
                    auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
                    for (uint32_t vi : selectedVerts) {
                        vertsToTransform.insert(vi);
                    }

                    // Add vertices from selected edges
                    auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
                    for (uint32_t ei : selectedEdges) {
                        auto edgeVerts = m_ctx.editableMesh.getEdgeVertices(ei);
                        vertsToTransform.insert(edgeVerts.first);
                        vertsToTransform.insert(edgeVerts.second);
                    }

                    // Add vertices from selected faces
                    auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
                    for (uint32_t fi : selectedFaces) {
                        auto faceVerts = m_ctx.editableMesh.getFaceVertices(fi);
                        for (uint32_t vi : faceVerts) {
                            vertsToTransform.insert(vi);
                        }
                    }

                    // Apply transform to all collected vertices AND any duplicates at same positions
                    if (!vertsToTransform.empty() && m_ctx.selectedObject) {
                        // Collect positions of vertices to transform (handles duplicate verts for hard edges)
                        auto posKey = [](const glm::vec3& p) -> uint64_t {
                            int32_t x = static_cast<int32_t>(p.x * 10000.0f);
                            int32_t y = static_cast<int32_t>(p.y * 10000.0f);
                            int32_t z = static_cast<int32_t>(p.z * 10000.0f);
                            return (static_cast<uint64_t>(x & 0xFFFFF) << 40) |
                                   (static_cast<uint64_t>(y & 0xFFFFF) << 20) |
                                   static_cast<uint64_t>(z & 0xFFFFF);
                        };

                        std::set<uint64_t> positionsToTransform;
                        for (uint32_t vi : vertsToTransform) {
                            positionsToTransform.insert(posKey(m_ctx.editableMesh.getVertex(vi).position));
                        }

                        if (m_ctx.gizmoMode == GizmoMode::Scale) {
                            // SCALE MODE: scale along axis around selection center
                            // Calculate scale factor based on movement along axis
                            float deltaLen = glm::dot(delta, axisDir);
                            float scaleFactor = 1.0f + deltaLen * 0.5f;  // Adjust sensitivity
                            scaleFactor = std::max(0.01f, scaleFactor);  // Prevent negative/zero scale

                            // Get selection center in local space as pivot
                            glm::vec3 pivot = m_ctx.editableMesh.getSelectionCenter();

                            // Build scale vector (only scale along active axis, or all for uniform)
                            glm::vec3 scaleVec(1.0f);
                            switch (m_ctx.gizmoActiveAxis) {
                                case GizmoAxis::X: scaleVec.x = scaleFactor; break;
                                case GizmoAxis::Y: scaleVec.y = scaleFactor; break;
                                case GizmoAxis::Z: scaleVec.z = scaleFactor; break;
                                case GizmoAxis::Uniform: scaleVec = glm::vec3(scaleFactor); break;
                                default: break;
                            }

                            // Scale ALL vertices at those positions around pivot
                            for (size_t vi = 0; vi < m_ctx.editableMesh.getVertexCount(); ++vi) {
                                auto& v = m_ctx.editableMesh.getVertex(static_cast<uint32_t>(vi));
                                if (positionsToTransform.count(posKey(v.position))) {
                                    v.position = pivot + (v.position - pivot) * scaleVec;
                                }
                            }
                        } else if (m_ctx.gizmoMode == GizmoMode::Move) {
                            // MOVE MODE: translate vertices
                            glm::mat4 invModel = glm::inverse(m_ctx.selectedObject->getTransform().getMatrix());
                            glm::vec3 localDelta = glm::vec3(invModel * glm::vec4(delta, 0.0f));

                            // Move ALL vertices at those positions
                            for (size_t vi = 0; vi < m_ctx.editableMesh.getVertexCount(); ++vi) {
                                auto& v = m_ctx.editableMesh.getVertex(static_cast<uint32_t>(vi));
                                if (positionsToTransform.count(posKey(v.position))) {
                                    v.position = v.position + localDelta;
                                }
                            }
                        }
                        m_ctx.meshDirty = true;

                        // Update drag start for incremental movement
                        m_ctx.gizmoDragStart = currentPoint;
                    }
                }
            }
        }
    } else {
        // Not dragging - check for hover and start drag
        m_ctx.gizmoHoveredAxis = pickGizmoAxis(rayOrigin, rayDir, gizmoPos);

        if (Input::isMouseButtonPressed(Input::MOUSE_LEFT) && m_ctx.gizmoHoveredAxis != GizmoAxis::None) {
            // Start drag
            m_ctx.gizmoDragging = true;
            m_ctx.gizmoActiveAxis = m_ctx.gizmoHoveredAxis;
            m_ctx.gizmoDragStartPos = gizmoPos;

            // Find initial point on axis - use local or world space axes
            glm::vec3 gizmoXAxis, gizmoYAxis, gizmoZAxis;
            getGizmoAxes(gizmoXAxis, gizmoYAxis, gizmoZAxis);

            glm::vec3 axisDir(0.0f);
            switch (m_ctx.gizmoActiveAxis) {
                case GizmoAxis::X: axisDir = gizmoXAxis; break;
                case GizmoAxis::Y: axisDir = gizmoYAxis; break;
                case GizmoAxis::Z: axisDir = gizmoZAxis; break;
                case GizmoAxis::Uniform: axisDir = glm::normalize(glm::vec3(1, 1, 1)); break;
                default: break;
            }

            if (m_ctx.gizmoMode == GizmoMode::Rotate) {
                // For rotation, store mouse screen position (in x,y of gizmoDragStart)
                glm::vec2 mousePos = Input::getMousePosition();
                m_ctx.gizmoDragStart = glm::vec3(mousePos.x, mousePos.y, 0.0f);
            } else {
                // For move/scale, find point on axis closest to ray
                glm::vec3 w0 = rayOrigin - gizmoPos;
                float a = glm::dot(rayDir, rayDir);
                float b = glm::dot(rayDir, axisDir);
                float c = glm::dot(axisDir, axisDir);
                float d = glm::dot(rayDir, w0);
                float e = glm::dot(axisDir, w0);

                float denom = a * c - b * b;
                if (std::abs(denom) > 0.0001f) {
                    float s = (a * e - b * d) / denom;
                    m_ctx.gizmoDragStart = gizmoPos + axisDir * s;
                } else {
                    m_ctx.gizmoDragStart = gizmoPos;
                }
            }

            // Store original object position for snap mode
            if (m_ctx.objectMode && m_ctx.selectedObject) {
                m_ctx.gizmoOriginalObjPos = m_ctx.selectedObject->getTransform().getPosition();
            }

            // Save state for undo
            m_ctx.editableMesh.saveState();

            return true;  // Gizmo consumed this click
        }
    }

    // Return true if dragging (to block other input) or if hovering over gizmo
    return m_ctx.gizmoDragging || m_ctx.gizmoHoveredAxis != GizmoAxis::None;
}

void ModelingMode::renderGizmo(VkCommandBuffer cmd, const glm::mat4& viewProj) {
    if (m_ctx.gizmoMode == GizmoMode::None) return;
    if (!m_ctx.selectedObject) return;

    // In object mode, always show gizmo for selected object
    // In component mode, need actual component selection
    if (!m_ctx.objectMode) {
        auto selectedVerts = m_ctx.editableMesh.getSelectedVertices();
        auto selectedFaces = m_ctx.editableMesh.getSelectedFaces();
        auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
        bool hasSelection = !selectedVerts.empty() || !selectedFaces.empty() || !selectedEdges.empty();
        if (!hasSelection) return;
    }

    glm::vec3 gizmoPos = getGizmoPosition();
    float size = m_ctx.gizmoSize;

    // Define axis colors
    glm::vec3 xColor = (m_ctx.gizmoHoveredAxis == GizmoAxis::X || m_ctx.gizmoActiveAxis == GizmoAxis::X)
                       ? glm::vec3(1.0f, 1.0f, 0.0f) : glm::vec3(1.0f, 0.2f, 0.2f);  // Red / Yellow
    glm::vec3 yColor = (m_ctx.gizmoHoveredAxis == GizmoAxis::Y || m_ctx.gizmoActiveAxis == GizmoAxis::Y)
                       ? glm::vec3(1.0f, 1.0f, 0.0f) : glm::vec3(0.2f, 1.0f, 0.2f);  // Green / Yellow
    glm::vec3 zColor = (m_ctx.gizmoHoveredAxis == GizmoAxis::Z || m_ctx.gizmoActiveAxis == GizmoAxis::Z)
                       ? glm::vec3(1.0f, 1.0f, 0.0f) : glm::vec3(0.2f, 0.2f, 1.0f);  // Blue / Yellow

    bool isScaleMode = (m_ctx.gizmoMode == GizmoMode::Scale);
    bool isRotateMode = (m_ctx.gizmoMode == GizmoMode::Rotate);
    float cubeSize = size * 0.12f;  // Size of cube handles for scale gizmo

    // Helper lambda to create cube wireframe lines
    auto makeCubeLines = [](glm::vec3 center, float halfSize) -> std::vector<glm::vec3> {
        float s = halfSize;
        std::vector<glm::vec3> lines;
        // Bottom face
        lines.push_back(center + glm::vec3(-s, -s, -s)); lines.push_back(center + glm::vec3(s, -s, -s));
        lines.push_back(center + glm::vec3(s, -s, -s)); lines.push_back(center + glm::vec3(s, -s, s));
        lines.push_back(center + glm::vec3(s, -s, s)); lines.push_back(center + glm::vec3(-s, -s, s));
        lines.push_back(center + glm::vec3(-s, -s, s)); lines.push_back(center + glm::vec3(-s, -s, -s));
        // Top face
        lines.push_back(center + glm::vec3(-s, s, -s)); lines.push_back(center + glm::vec3(s, s, -s));
        lines.push_back(center + glm::vec3(s, s, -s)); lines.push_back(center + glm::vec3(s, s, s));
        lines.push_back(center + glm::vec3(s, s, s)); lines.push_back(center + glm::vec3(-s, s, s));
        lines.push_back(center + glm::vec3(-s, s, s)); lines.push_back(center + glm::vec3(-s, s, -s));
        // Vertical edges
        lines.push_back(center + glm::vec3(-s, -s, -s)); lines.push_back(center + glm::vec3(-s, s, -s));
        lines.push_back(center + glm::vec3(s, -s, -s)); lines.push_back(center + glm::vec3(s, s, -s));
        lines.push_back(center + glm::vec3(s, -s, s)); lines.push_back(center + glm::vec3(s, s, s));
        lines.push_back(center + glm::vec3(-s, -s, s)); lines.push_back(center + glm::vec3(-s, s, s));
        return lines;
    };

    // Helper lambda to create circle lines around an axis
    auto makeCircleLines = [](glm::vec3 center, float radius, glm::vec3 axis, int segments = 32) -> std::vector<glm::vec3> {
        std::vector<glm::vec3> lines;
        // Find perpendicular axes
        glm::vec3 perp1, perp2;
        if (std::abs(axis.x) < 0.9f) {
            perp1 = glm::normalize(glm::cross(axis, glm::vec3(1, 0, 0)));
        } else {
            perp1 = glm::normalize(glm::cross(axis, glm::vec3(0, 1, 0)));
        }
        perp2 = glm::normalize(glm::cross(axis, perp1));

        for (int i = 0; i < segments; ++i) {
            float angle1 = (float)i / segments * 2.0f * 3.14159265f;
            float angle2 = (float)(i + 1) / segments * 2.0f * 3.14159265f;
            glm::vec3 p1 = center + (perp1 * std::cos(angle1) + perp2 * std::sin(angle1)) * radius;
            glm::vec3 p2 = center + (perp1 * std::cos(angle2) + perp2 * std::sin(angle2)) * radius;
            lines.push_back(p1);
            lines.push_back(p2);
        }
        return lines;
    };

    // Get the gizmo axes (local or world space depending on settings)
    glm::vec3 gizmoXAxis, gizmoYAxis, gizmoZAxis;
    getGizmoAxes(gizmoXAxis, gizmoYAxis, gizmoZAxis);

    if (isRotateMode) {
        // ROTATE MODE: Draw circles around each axis
        auto xCircle = makeCircleLines(gizmoPos, size * 0.9f, glm::vec3(1, 0, 0));
        m_ctx.modelRenderer.renderLines(cmd, viewProj, xCircle, xColor);

        auto yCircle = makeCircleLines(gizmoPos, size * 0.9f, glm::vec3(0, 1, 0));
        m_ctx.modelRenderer.renderLines(cmd, viewProj, yCircle, yColor);

        auto zCircle = makeCircleLines(gizmoPos, size * 0.9f, glm::vec3(0, 0, 1));
        m_ctx.modelRenderer.renderLines(cmd, viewProj, zCircle, zColor);
    } else {
        // MOVE or SCALE MODE: Draw axis lines with arrows or cubes

        // Helper to get perpendicular vectors for arrow heads
        auto getArrowPerps = [](const glm::vec3& axis) -> std::pair<glm::vec3, glm::vec3> {
            glm::vec3 up = (std::abs(axis.y) < 0.9f) ? glm::vec3(0, 1, 0) : glm::vec3(1, 0, 0);
            glm::vec3 perp1 = glm::normalize(glm::cross(axis, up));
            glm::vec3 perp2 = glm::normalize(glm::cross(axis, perp1));
            return {perp1, perp2};
        };

        // Draw X axis (red)
        glm::vec3 xEnd = gizmoPos + gizmoXAxis * size;
        std::vector<glm::vec3> xLines = { gizmoPos, xEnd };
        if (isScaleMode) {
            auto cubeLines = makeCubeLines(xEnd, cubeSize);
            xLines.insert(xLines.end(), cubeLines.begin(), cubeLines.end());
        } else {
            // Arrow head for move mode
            auto [xPerp1, xPerp2] = getArrowPerps(gizmoXAxis);
            glm::vec3 arrowBase = gizmoPos + gizmoXAxis * (size * 0.85f);
            xLines.push_back(xEnd); xLines.push_back(arrowBase + xPerp1 * (size * 0.1f));
            xLines.push_back(xEnd); xLines.push_back(arrowBase - xPerp1 * (size * 0.1f));
            xLines.push_back(xEnd); xLines.push_back(arrowBase + xPerp2 * (size * 0.1f));
            xLines.push_back(xEnd); xLines.push_back(arrowBase - xPerp2 * (size * 0.1f));
        }
        m_ctx.modelRenderer.renderLines(cmd, viewProj, xLines, xColor);

        // Draw Y axis (green)
        glm::vec3 yEnd = gizmoPos + gizmoYAxis * size;
        std::vector<glm::vec3> yLines = { gizmoPos, yEnd };
        if (isScaleMode) {
            auto cubeLines = makeCubeLines(yEnd, cubeSize);
            yLines.insert(yLines.end(), cubeLines.begin(), cubeLines.end());
        } else {
            auto [yPerp1, yPerp2] = getArrowPerps(gizmoYAxis);
            glm::vec3 arrowBase = gizmoPos + gizmoYAxis * (size * 0.85f);
            yLines.push_back(yEnd); yLines.push_back(arrowBase + yPerp1 * (size * 0.1f));
            yLines.push_back(yEnd); yLines.push_back(arrowBase - yPerp1 * (size * 0.1f));
            yLines.push_back(yEnd); yLines.push_back(arrowBase + yPerp2 * (size * 0.1f));
            yLines.push_back(yEnd); yLines.push_back(arrowBase - yPerp2 * (size * 0.1f));
        }
        m_ctx.modelRenderer.renderLines(cmd, viewProj, yLines, yColor);

        // Draw Z axis (blue)
        glm::vec3 zEnd = gizmoPos + gizmoZAxis * size;
        std::vector<glm::vec3> zLines = { gizmoPos, zEnd };
        if (isScaleMode) {
            auto cubeLines = makeCubeLines(zEnd, cubeSize);
            zLines.insert(zLines.end(), cubeLines.begin(), cubeLines.end());
        } else {
            auto [zPerp1, zPerp2] = getArrowPerps(gizmoZAxis);
            glm::vec3 arrowBase = gizmoPos + gizmoZAxis * (size * 0.85f);
            zLines.push_back(zEnd); zLines.push_back(arrowBase + zPerp1 * (size * 0.1f));
            zLines.push_back(zEnd); zLines.push_back(arrowBase - zPerp1 * (size * 0.1f));
            zLines.push_back(zEnd); zLines.push_back(arrowBase + zPerp2 * (size * 0.1f));
            zLines.push_back(zEnd); zLines.push_back(arrowBase - zPerp2 * (size * 0.1f));
        }
        m_ctx.modelRenderer.renderLines(cmd, viewProj, zLines, zColor);

        // Draw center cube for uniform scale (only in scale mode)
        if (isScaleMode) {
            glm::vec3 uniformColor = (m_ctx.gizmoHoveredAxis == GizmoAxis::Uniform || m_ctx.gizmoActiveAxis == GizmoAxis::Uniform)
                                     ? glm::vec3(1.0f, 1.0f, 0.0f) : glm::vec3(0.9f, 0.9f, 0.9f);  // White / Yellow
            auto centerCubeLines = makeCubeLines(gizmoPos, cubeSize * 1.2f);
            m_ctx.modelRenderer.renderLines(cmd, viewProj, centerCubeLines, uniformColor);
        }
    }
}

// ============================================================================
// Edge Path Extrusion - Create box tube along selected edges
// ============================================================================

std::vector<uint32_t> ModelingMode::orderSelectedEdgesIntoPath() {
    // Get selected edges as half-edge indices
    auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
    if (selectedEdges.empty()) return {};

    std::cout << "[EdgePath] Ordering " << selectedEdges.size() << " selected edges into path" << std::endl;

    // Build adjacency: for each vertex, which edges touch it
    std::map<uint32_t, std::vector<uint32_t>> vertexToEdges;
    std::set<uint32_t> edgeSet(selectedEdges.begin(), selectedEdges.end());

    for (uint32_t heIdx : selectedEdges) {
        auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(heIdx);
        vertexToEdges[v0].push_back(heIdx);
        vertexToEdges[v1].push_back(heIdx);
    }

    // Find endpoints (vertices with only 1 edge) - these are path start/end
    std::vector<uint32_t> endpoints;
    for (auto& [vertIdx, edges] : vertexToEdges) {
        if (edges.size() == 1) {
            endpoints.push_back(vertIdx);
        }
    }

    if (endpoints.size() != 2) {
        std::cout << "[EdgePath] Warning: Expected 2 endpoints, found " << endpoints.size()
                  << ". Path may be a loop or disconnected." << std::endl;
        if (endpoints.empty() && !vertexToEdges.empty()) {
            // It's a closed loop - pick any vertex as start
            endpoints.push_back(vertexToEdges.begin()->first);
        }
    }

    if (endpoints.empty()) return {};

    // Walk from first endpoint, collecting edges in order
    std::vector<uint32_t> orderedEdges;
    std::set<uint32_t> visitedEdges;
    uint32_t currentVertex = endpoints[0];

    while (orderedEdges.size() < selectedEdges.size()) {
        auto& edges = vertexToEdges[currentVertex];
        uint32_t nextEdge = UINT32_MAX;

        for (uint32_t heIdx : edges) {
            if (visitedEdges.count(heIdx) == 0 && edgeSet.count(heIdx) > 0) {
                nextEdge = heIdx;
                break;
            }
        }

        if (nextEdge == UINT32_MAX) break;  // No more edges to follow

        orderedEdges.push_back(nextEdge);
        visitedEdges.insert(nextEdge);

        // Move to the other vertex of this edge
        auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(nextEdge);
        currentVertex = (currentVertex == v0) ? v1 : v0;
    }

    std::cout << "[EdgePath] Ordered path has " << orderedEdges.size() << " edges" << std::endl;
    return orderedEdges;
}

void ModelingMode::extrudeBoxAlongSelectedEdges(float boxSize, float taper, bool autoUV) {
    // Order selected edges into a path
    std::vector<uint32_t> pathEdges = orderSelectedEdgesIntoPath();
    if (pathEdges.size() < 1) {
        std::cout << "[EdgePath] Need at least 1 edge selected" << std::endl;
        return;
    }

    std::cout << "[EdgePath] Creating box tube along " << pathEdges.size() << " edges, box size: " << boxSize << ", taper: " << taper << ", autoUV: " << autoUV << std::endl;

    // Collect vertices along the path in order
    std::vector<glm::vec3> pathVertices;

    // Add first vertex
    auto [firstV0, firstV1] = m_ctx.editableMesh.getEdgeVertices(pathEdges[0]);
    glm::vec3 firstPos = m_ctx.editableMesh.getVertex(firstV0).position;

    // Determine correct starting vertex by checking connectivity
    if (pathEdges.size() > 1) {
        auto [secondV0, secondV1] = m_ctx.editableMesh.getEdgeVertices(pathEdges[1]);
        // First edge's v1 should connect to second edge
        if (firstV1 == secondV0 || firstV1 == secondV1) {
            pathVertices.push_back(m_ctx.editableMesh.getVertex(firstV0).position);
        } else {
            pathVertices.push_back(m_ctx.editableMesh.getVertex(firstV1).position);
        }
    } else {
        pathVertices.push_back(firstPos);
    }

    // Add remaining vertices
    uint32_t prevVertex = UINT32_MAX;
    for (size_t i = 0; i < pathEdges.size(); ++i) {
        auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(pathEdges[i]);
        glm::vec3 pos0 = m_ctx.editableMesh.getVertex(v0).position;
        glm::vec3 pos1 = m_ctx.editableMesh.getVertex(v1).position;

        // Add the vertex we haven't added yet
        float dist0 = glm::length(pos0 - pathVertices.back());
        float dist1 = glm::length(pos1 - pathVertices.back());

        if (dist0 < 0.0001f) {
            pathVertices.push_back(pos1);
        } else if (dist1 < 0.0001f) {
            pathVertices.push_back(pos0);
        } else {
            // First edge - add both vertices
            if (pathVertices.size() == 1) {
                pathVertices.push_back(pos1);
            }
        }
    }

    std::cout << "[EdgePath] Path has " << pathVertices.size() << " vertices" << std::endl;

    if (pathVertices.size() < 2) {
        std::cout << "[EdgePath] Need at least 2 vertices in path" << std::endl;
        return;
    }

    // Create the box tube mesh
    // For each vertex on the path, create a square cross-section (4 vertices)
    // Connect adjacent cross-sections with quads

    std::vector<ModelVertex> tubeVerts;
    std::vector<uint32_t> tubeIndices;

    float baseHalfSize = boxSize * 0.5f;

    // Get mesh color (random if enabled)
    glm::vec4 meshColor = m_ctx.defaultMeshColor;
    if (m_ctx.randomMeshColors) {
        static std::mt19937 rng(std::random_device{}());
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        meshColor = glm::vec4(dist(rng), dist(rng), dist(rng), 1.0f);
    }

    // Pre-compute tangents for all vertices
    std::vector<glm::vec3> tangents(pathVertices.size());
    for (size_t i = 0; i < pathVertices.size(); ++i) {
        if (i == 0) {
            tangents[i] = glm::normalize(pathVertices[1] - pathVertices[0]);
        } else if (i == pathVertices.size() - 1) {
            tangents[i] = glm::normalize(pathVertices[i] - pathVertices[i - 1]);
        } else {
            glm::vec3 incoming = glm::normalize(pathVertices[i] - pathVertices[i - 1]);
            glm::vec3 outgoing = glm::normalize(pathVertices[i + 1] - pathVertices[i]);
            tangents[i] = glm::normalize(incoming + outgoing);
        }
    }

    // Compute frames using Double Reflection Method (rotation minimizing frames)
    // This avoids the twist accumulation problem of naive parallel transport
    std::vector<glm::vec3> rights(pathVertices.size());
    std::vector<glm::vec3> ups(pathVertices.size());

    // Initial frame
    {
        glm::vec3 tangent = tangents[0];
        glm::vec3 up = glm::vec3(0, 1, 0);
        if (std::abs(glm::dot(tangent, up)) > 0.9f) {
            up = glm::vec3(1, 0, 0);
        }
        rights[0] = glm::normalize(glm::cross(tangent, up));
        ups[0] = glm::normalize(glm::cross(rights[0], tangent));
    }

    // Propagate using Double Reflection Method
    for (size_t i = 1; i < pathVertices.size(); ++i) {
        glm::vec3 t0 = tangents[i - 1];
        glm::vec3 t1 = tangents[i];

        // Reflection 1: reflect previous frame across plane perpendicular to (t0 + t1)/2
        glm::vec3 v1 = pathVertices[i] - pathVertices[i - 1];
        float c1 = glm::dot(v1, v1);
        if (c1 < 0.0001f) {
            // Degenerate case: same position
            rights[i] = rights[i - 1];
            ups[i] = ups[i - 1];
            continue;
        }

        glm::vec3 rL = rights[i - 1] - (2.0f / c1) * glm::dot(v1, rights[i - 1]) * v1;
        glm::vec3 tL = t0 - (2.0f / c1) * glm::dot(v1, t0) * v1;

        // Reflection 2: reflect across plane perpendicular to (tL + t1)/2
        glm::vec3 v2 = t1 - tL;
        float c2 = glm::dot(v2, v2);
        if (c2 < 0.0001f) {
            // Tangents are the same after first reflection
            rights[i] = glm::normalize(rL);
        } else {
            rights[i] = glm::normalize(rL - (2.0f / c2) * glm::dot(v2, rL) * v2);
        }
        ups[i] = glm::normalize(glm::cross(rights[i], t1));
    }

    // For each path vertex, create cross-section
    for (size_t i = 0; i < pathVertices.size(); ++i) {
        glm::vec3 pos = pathVertices[i];
        glm::vec3 right = rights[i];
        glm::vec3 localUp = ups[i];

        // Calculate tapered size at this position along the path
        // t goes from 0 (start) to 1 (end), size interpolates from 1.0 to taper
        float t = (pathVertices.size() > 1) ? static_cast<float>(i) / (pathVertices.size() - 1) : 0.0f;
        float sizeMultiplier = glm::mix(1.0f, taper, t);
        float halfSize = baseHalfSize * sizeMultiplier;

        // Create 4 vertices for square cross-section
        // Order: bottom-left, bottom-right, top-right, top-left (CCW when looking along tangent)
        glm::vec3 corners[4] = {
            pos - right * halfSize - localUp * halfSize,  // 0: bottom-left
            pos + right * halfSize - localUp * halfSize,  // 1: bottom-right
            pos + right * halfSize + localUp * halfSize,  // 2: top-right
            pos - right * halfSize + localUp * halfSize   // 3: top-left
        };

        // V coordinate = position along path (0 to 1)
        float vCoord = (pathVertices.size() > 1) ? static_cast<float>(i) / (pathVertices.size() - 1) : 0.0f;

        // Create 5 vertices per cross-section (4 corners + 1 duplicate for UV seam)
        // U coordinates: 0.0, 0.25, 0.5, 0.75, 1.0 (corner 0 duplicated at U=1 for seam)
        for (int c = 0; c < 5; ++c) {
            ModelVertex v;
            v.position = corners[c % 4];  // Corner 4 is same position as corner 0
            v.normal = glm::vec3(0, 1, 0);  // Will recalculate later
            if (autoUV) {
                v.texCoord = glm::vec2(c / 4.0f, vCoord);  // U around tube, V along path
            } else {
                v.texCoord = glm::vec2(0.0f, 0.0f);  // Default UVs
            }
            v.color = meshColor;
            tubeVerts.push_back(v);
        }
    }

    // Create quad faces connecting adjacent cross-sections
    // Now using 5 vertices per cross-section (with seam duplicate)
    for (size_t i = 0; i < pathVertices.size() - 1; ++i) {
        uint32_t base0 = static_cast<uint32_t>(i * 5);
        uint32_t base1 = static_cast<uint32_t>((i + 1) * 5);

        // 4 quads connecting the two cross-sections (as triangles)
        // Use vertices 0-1, 1-2, 2-3, 3-4 for proper UV continuity
        for (int side = 0; side < 4; ++side) {
            uint32_t v0 = base0 + side;
            uint32_t v1 = base1 + side;
            uint32_t v2 = base1 + side + 1;
            uint32_t v3 = base0 + side + 1;

            // Two triangles per quad
            tubeIndices.push_back(v0);
            tubeIndices.push_back(v1);
            tubeIndices.push_back(v2);

            tubeIndices.push_back(v0);
            tubeIndices.push_back(v2);
            tubeIndices.push_back(v3);
        }
    }

    // Create separate vertices for caps with planar UVs
    // Caps are placed next to the tube in UV space (offset to the right)
    // Start cap at U: 1.05-1.55, V: 0.0-0.5
    // End cap at U: 1.05-1.55, V: 0.5-1.0 (stacked below start cap)

    // Cap UVs: corners map to 0.5x0.5 squares, offset to be visible
    float capScale = 0.5f;
    float capOffsetU = 1.05f;  // Place caps to the right of main UV area

    // Start cap UVs
    glm::vec2 startCapUVs[4] = {
        glm::vec2(capOffsetU, 0.5f),                           // Corner 0 (bottom-left)
        glm::vec2(capOffsetU + capScale, 0.5f),                // Corner 1 (bottom-right)
        glm::vec2(capOffsetU + capScale, 0.5f + capScale),     // Corner 2 (top-right)
        glm::vec2(capOffsetU, 0.5f + capScale)                 // Corner 3 (top-left)
    };

    // End cap UVs (same position - they share texture space)
    glm::vec2 endCapUVs[4] = {
        glm::vec2(capOffsetU, 0.0f),                           // Corner 0 (bottom-left)
        glm::vec2(capOffsetU + capScale, 0.0f),                // Corner 1 (bottom-right)
        glm::vec2(capOffsetU + capScale, capScale),            // Corner 2 (top-right)
        glm::vec2(capOffsetU, capScale)                        // Corner 3 (top-left)
    };

    // Start cap vertices (copy positions from first cross-section, add cap UVs)
    uint32_t startCapBase = static_cast<uint32_t>(tubeVerts.size());
    for (int c = 0; c < 4; ++c) {
        ModelVertex v;
        v.position = tubeVerts[c].position;  // Same position as tube vertex
        v.normal = glm::vec3(0, 1, 0);  // Will recalculate
        v.texCoord = autoUV ? startCapUVs[c] : glm::vec2(0.0f);
        v.color = meshColor;
        tubeVerts.push_back(v);
    }

    // End cap vertices (copy positions from last cross-section, add cap UVs)
    uint32_t endCapBase = static_cast<uint32_t>(tubeVerts.size());
    uint32_t lastTubeBase = static_cast<uint32_t>((pathVertices.size() - 1) * 5);
    for (int c = 0; c < 4; ++c) {
        ModelVertex v;
        v.position = tubeVerts[lastTubeBase + c].position;  // Same position as tube vertex
        v.normal = glm::vec3(0, 1, 0);  // Will recalculate
        v.texCoord = autoUV ? endCapUVs[c] : glm::vec2(0.0f);
        v.color = meshColor;
        tubeVerts.push_back(v);
    }

    // Cap the start - normal points backward (opposite to path direction)
    // Winding: 012, 023 (CCW when viewed from outside/behind)
    tubeIndices.push_back(startCapBase + 0);
    tubeIndices.push_back(startCapBase + 1);
    tubeIndices.push_back(startCapBase + 2);
    tubeIndices.push_back(startCapBase + 0);
    tubeIndices.push_back(startCapBase + 2);
    tubeIndices.push_back(startCapBase + 3);

    // Cap the end - normal points forward (along path direction)
    // Winding: 032, 021 (CCW when viewed from outside/front)
    tubeIndices.push_back(endCapBase + 0);
    tubeIndices.push_back(endCapBase + 3);
    tubeIndices.push_back(endCapBase + 2);
    tubeIndices.push_back(endCapBase + 0);
    tubeIndices.push_back(endCapBase + 2);
    tubeIndices.push_back(endCapBase + 1);

    // Recalculate normals
    // Reset all normals to zero
    for (auto& v : tubeVerts) {
        v.normal = glm::vec3(0);
    }

    // Accumulate face normals
    for (size_t i = 0; i < tubeIndices.size(); i += 3) {
        uint32_t i0 = tubeIndices[i];
        uint32_t i1 = tubeIndices[i + 1];
        uint32_t i2 = tubeIndices[i + 2];

        glm::vec3 p0 = tubeVerts[i0].position;
        glm::vec3 p1 = tubeVerts[i1].position;
        glm::vec3 p2 = tubeVerts[i2].position;

        glm::vec3 faceNormal = glm::cross(p1 - p0, p2 - p0);

        tubeVerts[i0].normal += faceNormal;
        tubeVerts[i1].normal += faceNormal;
        tubeVerts[i2].normal += faceNormal;
    }

    // Normalize all normals
    for (auto& v : tubeVerts) {
        if (glm::length(v.normal) > 0.0001f) {
            v.normal = glm::normalize(v.normal);
        }
    }

    std::cout << "[EdgePath] Created tube with " << tubeVerts.size() << " vertices, "
              << tubeIndices.size() / 3 << " triangles" << std::endl;

    // Build EditableMesh with proper quad topology for wireframe/editing
    EditableMesh tubeMesh;
    tubeMesh.clear();

    // Add vertices (4 per cross-section from the 5-vert pattern, plus cap vertices)
    std::vector<uint32_t> crossSectionStarts;

    // Tube body vertices: pathVertices.size() cross-sections, 5 verts each
    size_t tubeBodyVerts = pathVertices.size() * 5;
    for (size_t v = 0; v < tubeBodyVerts; v += 5) {
        crossSectionStarts.push_back(static_cast<uint32_t>(tubeMesh.getVertexCount()));
        for (int c = 0; c < 4; ++c) {
            HEVertex hv;
            hv.position = tubeVerts[v + c].position;
            hv.normal = tubeVerts[v + c].normal;
            hv.uv = tubeVerts[v + c].texCoord;
            hv.color = tubeVerts[v + c].color;
            hv.halfEdgeIndex = UINT32_MAX;
            hv.selected = false;
            tubeMesh.addVertex(hv);
        }
    }

    // Add cap vertices (startCapBase and endCapBase, 4 verts each)
    uint32_t startCapMeshBase = static_cast<uint32_t>(tubeMesh.getVertexCount());
    for (int c = 0; c < 4; ++c) {
        HEVertex hv;
        hv.position = tubeVerts[startCapBase + c].position;
        hv.normal = tubeVerts[startCapBase + c].normal;
        hv.uv = tubeVerts[startCapBase + c].texCoord;
        hv.color = tubeVerts[startCapBase + c].color;
        hv.halfEdgeIndex = UINT32_MAX;
        hv.selected = false;
        tubeMesh.addVertex(hv);
    }

    uint32_t endCapMeshBase = static_cast<uint32_t>(tubeMesh.getVertexCount());
    for (int c = 0; c < 4; ++c) {
        HEVertex hv;
        hv.position = tubeVerts[endCapBase + c].position;
        hv.normal = tubeVerts[endCapBase + c].normal;
        hv.uv = tubeVerts[endCapBase + c].texCoord;
        hv.color = tubeVerts[endCapBase + c].color;
        hv.halfEdgeIndex = UINT32_MAX;
        hv.selected = false;
        tubeMesh.addVertex(hv);
    }

    // Add quad faces for tube body (not including caps which are triangulated)
    // Tube body indices come before cap indices
    size_t tubeBodyTriangles = (pathVertices.size() - 1) * 4 * 2;  // 4 quads per segment, 2 tris each
    for (size_t i = 0; i < tubeBodyTriangles * 3; i += 6) {
        uint32_t triV0 = tubeIndices[i];
        uint32_t triV1 = tubeIndices[i + 1];
        uint32_t triV2 = tubeIndices[i + 2];
        uint32_t triV3 = tubeIndices[i + 5];

        uint32_t section0 = triV0 / 5;
        uint32_t corner0 = triV0 % 5 % 4;
        uint32_t section1 = triV1 / 5;
        uint32_t corner1 = triV1 % 5 % 4;
        uint32_t section2 = triV2 / 5;
        uint32_t corner2 = triV2 % 5 % 4;
        uint32_t section3 = triV3 / 5;
        uint32_t corner3 = triV3 % 5 % 4;

        if (section0 < crossSectionStarts.size() && section1 < crossSectionStarts.size() &&
            section2 < crossSectionStarts.size() && section3 < crossSectionStarts.size()) {
            std::vector<uint32_t> quadVerts = {
                crossSectionStarts[section0] + corner0,
                crossSectionStarts[section1] + corner1,
                crossSectionStarts[section2] + corner2,
                crossSectionStarts[section3] + corner3
            };
            tubeMesh.addQuadFace(quadVerts);
        }
    }

    // Add cap faces as quads
    tubeMesh.addQuadFace({startCapMeshBase + 0, startCapMeshBase + 1, startCapMeshBase + 2, startCapMeshBase + 3});
    tubeMesh.addQuadFace({endCapMeshBase + 0, endCapMeshBase + 3, endCapMeshBase + 2, endCapMeshBase + 1});

    std::cout << "[EdgePath] EditableMesh: " << tubeMesh.getVertexCount() << " vertices, "
              << tubeMesh.getFaceCount() << " faces" << std::endl;

    // Create a new scene object with this mesh
    auto newObject = std::make_unique<SceneObject>("EdgeTube");

    // Apply the source object's transform to position the tube correctly
    if (m_ctx.selectedObject) {
        newObject->getTransform() = m_ctx.selectedObject->getTransform();
    }

    // Upload to GPU
    uint32_t handle = m_ctx.modelRenderer.createModel(tubeVerts, tubeIndices, nullptr, 0, 0);
    if (handle != UINT32_MAX) {
        newObject->setBufferHandle(handle);
        newObject->setIndexCount(static_cast<uint32_t>(tubeIndices.size()));
        newObject->setVertexCount(static_cast<uint32_t>(tubeVerts.size()));
        newObject->setMeshData(tubeVerts, tubeIndices);

        // Store half-edge data to preserve quad topology
        const auto& meshVerts = tubeMesh.getVerticesData();
        const auto& meshHE = tubeMesh.getHalfEdges();
        const auto& meshFaces = tubeMesh.getFacesData();

        std::vector<SceneObject::StoredHEVertex> storedVerts;
        storedVerts.reserve(meshVerts.size());
        for (const auto& v : meshVerts) {
            storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
        }

        std::vector<SceneObject::StoredHalfEdge> storedHE;
        storedHE.reserve(meshHE.size());
        for (const auto& he : meshHE) {
            storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
        }

        std::vector<SceneObject::StoredHEFace> storedFaces;
        storedFaces.reserve(meshFaces.size());
        for (const auto& f : meshFaces) {
            storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
        }

        newObject->setEditableMeshData(storedVerts, storedHE, storedFaces);

        m_ctx.sceneObjects.push_back(std::move(newObject));
        std::cout << "[EdgePath] Added new object 'EdgeTube' to scene" << std::endl;
    } else {
        std::cout << "[EdgePath] Failed to upload tube mesh to GPU" << std::endl;
    }
}

// ============================================================================
// Pipe Network Extrusion (handles junctions and corners)
// ============================================================================

// Vertex classification for pipe network
enum class PipeVertexType {
    Endpoint,    // 1 edge (path terminus)
    Passthrough, // 2 edges, angle < 45 (smooth continuation)
    Corner,      // 2 edges, angle >= 45 (needs junction block)
    Junction     // 3+ edges (T-junction, cross, etc.)
};

void ModelingMode::extrudePipeNetwork(float boxSize, float blockSizeMultiplier, bool autoUV) {
    // Get selected edges
    auto selectedEdges = m_ctx.editableMesh.getSelectedEdges();
    if (selectedEdges.empty()) {
        std::cout << "[PipeNetwork] No edges selected" << std::endl;
        return;
    }

    std::cout << "[PipeNetwork] Processing " << selectedEdges.size() << " edges" << std::endl;

    // Step 1: Build vertexedges adjacency map
    std::map<uint32_t, std::vector<uint32_t>> vertexToEdges;
    std::set<uint32_t> edgeSet(selectedEdges.begin(), selectedEdges.end());

    for (uint32_t heIdx : selectedEdges) {
        auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(heIdx);
        vertexToEdges[v0].push_back(heIdx);
        vertexToEdges[v1].push_back(heIdx);
    }

    // Step 2: Classify each vertex
    std::map<uint32_t, PipeVertexType> vertexTypes;
    const float cornerAngleThreshold = glm::radians(45.0f);

    for (auto& [vertIdx, edges] : vertexToEdges) {
        if (edges.size() == 1) {
            vertexTypes[vertIdx] = PipeVertexType::Endpoint;
        } else if (edges.size() == 2) {
            auto [e0v0, e0v1] = m_ctx.editableMesh.getEdgeVertices(edges[0]);
            auto [e1v0, e1v1] = m_ctx.editableMesh.getEdgeVertices(edges[1]);
            uint32_t other0 = (e0v0 == vertIdx) ? e0v1 : e0v0;
            uint32_t other1 = (e1v0 == vertIdx) ? e1v1 : e1v0;

            glm::vec3 centerPos = m_ctx.editableMesh.getVertex(vertIdx).position;
            glm::vec3 pos0 = m_ctx.editableMesh.getVertex(other0).position;
            glm::vec3 pos1 = m_ctx.editableMesh.getVertex(other1).position;

            glm::vec3 dir0 = glm::normalize(pos0 - centerPos);
            glm::vec3 dir1 = glm::normalize(pos1 - centerPos);

            float dotProduct = glm::dot(dir0, dir1);
            float angle = std::acos(glm::clamp(dotProduct, -1.0f, 1.0f));
            float deviationFromStraight = std::abs(glm::pi<float>() - angle);

            if (deviationFromStraight >= cornerAngleThreshold) {
                vertexTypes[vertIdx] = PipeVertexType::Corner;
            } else {
                vertexTypes[vertIdx] = PipeVertexType::Passthrough;
            }
        } else {
            vertexTypes[vertIdx] = PipeVertexType::Junction;
        }
    }

    // Count vertex types for debugging
    int endpoints = 0, passthroughs = 0, corners = 0, junctions = 0;
    for (auto& [vertIdx, type] : vertexTypes) {
        switch (type) {
            case PipeVertexType::Endpoint: endpoints++; break;
            case PipeVertexType::Passthrough: passthroughs++; break;
            case PipeVertexType::Corner: corners++; break;
            case PipeVertexType::Junction: junctions++; break;
        }
    }
    std::cout << "[PipeNetwork] Vertex types - Endpoints: " << endpoints
              << ", Passthroughs: " << passthroughs
              << ", Corners: " << corners
              << ", Junctions: " << junctions << std::endl;

    // Step 3: Find segment break points (only endpoints and junctions, NOT corners)
    // Corners are just bends in the continuous tube, not segment breaks
    std::set<uint32_t> blockVertices;
    for (auto& [vertIdx, type] : vertexTypes) {
        if (type == PipeVertexType::Endpoint || type == PipeVertexType::Junction) {
            blockVertices.insert(vertIdx);
        }
    }

    // Step 4: Segment the network into paths between block vertices
    struct PathSegment {
        std::vector<glm::vec3> vertices;
        uint32_t startBlockVertex;
        uint32_t endBlockVertex;
        bool isClosedLoop = false;  // True if this is a closed loop with no junctions
    };
    std::vector<PathSegment> segments;
    std::set<uint32_t> visitedEdges;

    // Special case: closed loop with no block vertices (all passthrough)
    if (blockVertices.empty() && !vertexToEdges.empty()) {
        std::cout << "[PipeNetwork] Detected closed loop with no junctions" << std::endl;

        // Start from any vertex and walk around the loop
        uint32_t startVertex = vertexToEdges.begin()->first;
        PathSegment segment;
        segment.startBlockVertex = startVertex;
        segment.endBlockVertex = startVertex;
        segment.isClosedLoop = true;
        segment.vertices.push_back(m_ctx.editableMesh.getVertex(startVertex).position);

        uint32_t currentVertex = startVertex;
        uint32_t currentEdge = vertexToEdges[startVertex][0];

        while (true) {
            visitedEdges.insert(currentEdge);

            auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(currentEdge);
            uint32_t nextVertex = (currentVertex == v0) ? v1 : v0;

            // If we're back at the start, close the loop
            if (nextVertex == startVertex) {
                break;
            }

            segment.vertices.push_back(m_ctx.editableMesh.getVertex(nextVertex).position);

            // Find next unvisited edge
            auto& nextEdges = vertexToEdges[nextVertex];
            uint32_t nextEdge = UINT32_MAX;
            for (uint32_t e : nextEdges) {
                if (visitedEdges.count(e) == 0) {
                    nextEdge = e;
                    break;
                }
            }

            if (nextEdge == UINT32_MAX) break;

            currentVertex = nextVertex;
            currentEdge = nextEdge;
        }

        if (segment.vertices.size() >= 2) {
            segments.push_back(segment);
        }
    }

    // Normal case: segment between block vertices
    for (uint32_t startVertex : blockVertices) {
        for (uint32_t startEdge : vertexToEdges[startVertex]) {
            if (visitedEdges.count(startEdge) > 0) continue;

            PathSegment segment;
            segment.startBlockVertex = startVertex;
            segment.vertices.push_back(m_ctx.editableMesh.getVertex(startVertex).position);

            uint32_t currentVertex = startVertex;
            uint32_t currentEdge = startEdge;

            while (true) {
                visitedEdges.insert(currentEdge);

                auto [v0, v1] = m_ctx.editableMesh.getEdgeVertices(currentEdge);
                uint32_t nextVertex = (currentVertex == v0) ? v1 : v0;

                segment.vertices.push_back(m_ctx.editableMesh.getVertex(nextVertex).position);

                if (blockVertices.count(nextVertex) > 0) {
                    segment.endBlockVertex = nextVertex;
                    break;
                }

                auto& nextEdges = vertexToEdges[nextVertex];
                uint32_t nextEdge = UINT32_MAX;
                for (uint32_t e : nextEdges) {
                    if (e != currentEdge && visitedEdges.count(e) == 0) {
                        nextEdge = e;
                        break;
                    }
                }

                if (nextEdge == UINT32_MAX) {
                    segment.endBlockVertex = nextVertex;
                    break;
                }

                currentVertex = nextVertex;
                currentEdge = nextEdge;
            }

            if (segment.vertices.size() >= 2) {
                segments.push_back(segment);
            }
        }
    }

    std::cout << "[PipeNetwork] Created " << segments.size() << " path segments" << std::endl;

    // Collect all geometry
    std::vector<ModelVertex> allVerts;
    std::vector<uint32_t> allIndices;

    float baseHalfSize = boxSize * 0.5f;

    // Get mesh color (random if enabled)
    glm::vec4 meshColor = m_ctx.defaultMeshColor;
    if (m_ctx.randomMeshColors) {
        static std::mt19937 rng(std::random_device{}());
        std::uniform_real_distribution<float> dist(0.0f, 1.0f);
        meshColor = glm::vec4(dist(rng), dist(rng), dist(rng), 1.0f);
    }

    // No junction blocks - tubes pass through each other at junctions
    std::cout << "[PipeNetwork] Creating tubes without junction blocks" << std::endl;

    // Step 6: Create tube segments (no junction blocks, tubes pass through each other)
    for (const auto& segment : segments) {
        if (segment.vertices.size() < 2) continue;

        std::vector<glm::vec3> pathVertices = segment.vertices;

        // Pre-compute tangents
        std::vector<glm::vec3> tangents(pathVertices.size());
        for (size_t i = 0; i < pathVertices.size(); ++i) {
            if (segment.isClosedLoop) {
                // For closed loops, wrap around
                size_t prevIdx = (i == 0) ? pathVertices.size() - 1 : i - 1;
                size_t nextIdx = (i == pathVertices.size() - 1) ? 0 : i + 1;
                glm::vec3 incoming = glm::normalize(pathVertices[i] - pathVertices[prevIdx]);
                glm::vec3 outgoing = glm::normalize(pathVertices[nextIdx] - pathVertices[i]);
                tangents[i] = glm::normalize(incoming + outgoing);
            } else if (i == 0) {
                tangents[i] = glm::normalize(pathVertices[1] - pathVertices[0]);
            } else if (i == pathVertices.size() - 1) {
                tangents[i] = glm::normalize(pathVertices[i] - pathVertices[i - 1]);
            } else {
                glm::vec3 incoming = glm::normalize(pathVertices[i] - pathVertices[i - 1]);
                glm::vec3 outgoing = glm::normalize(pathVertices[i + 1] - pathVertices[i]);
                tangents[i] = glm::normalize(incoming + outgoing);
            }
        }

        // Compute frames using consistent world-up reference
        std::vector<glm::vec3> rights(pathVertices.size());
        std::vector<glm::vec3> ups(pathVertices.size());

        // Use world Y as reference, fall back to X if tangent is vertical
        glm::vec3 worldUp = glm::vec3(0, 1, 0);

        // Check if most tangents are vertical - if so, use X as reference
        float avgVertical = 0.0f;
        for (const auto& t : tangents) {
            avgVertical += std::abs(glm::dot(t, worldUp));
        }
        avgVertical /= tangents.size();
        if (avgVertical > 0.7f) {
            worldUp = glm::vec3(1, 0, 0);
        }

        for (size_t i = 0; i < pathVertices.size(); ++i) {
            glm::vec3 tangent = tangents[i];
            // Project worldUp onto plane perpendicular to tangent
            glm::vec3 projected = worldUp - tangent * glm::dot(worldUp, tangent);
            float projLen = glm::length(projected);
            if (projLen > 0.0001f) {
                ups[i] = glm::normalize(projected);
            } else {
                // Tangent is parallel to worldUp, use fallback
                glm::vec3 fallback = (worldUp.y != 0.0f) ? glm::vec3(1, 0, 0) : glm::vec3(0, 1, 0);
                ups[i] = glm::normalize(fallback - tangent * glm::dot(fallback, tangent));
            }
            rights[i] = glm::normalize(glm::cross(tangent, ups[i]));
        }

        if (!segment.isClosedLoop) {
            // For open paths: use Double Reflection Method
            // Initial frame
            {
                glm::vec3 tangent = tangents[0];
                glm::vec3 up = glm::vec3(0, 1, 0);
                if (std::abs(glm::dot(tangent, up)) > 0.9f) {
                    up = glm::vec3(1, 0, 0);
                }
                rights[0] = glm::normalize(glm::cross(tangent, up));
                ups[0] = glm::normalize(glm::cross(rights[0], tangent));
            }

            // Propagate using Double Reflection Method
            for (size_t i = 1; i < pathVertices.size(); ++i) {
                glm::vec3 t0 = tangents[i - 1];
                glm::vec3 t1 = tangents[i];

                glm::vec3 v1 = pathVertices[i] - pathVertices[i - 1];
                float c1 = glm::dot(v1, v1);
                if (c1 < 0.0001f) {
                    rights[i] = rights[i - 1];
                    ups[i] = ups[i - 1];
                    continue;
                }

                glm::vec3 rL = rights[i - 1] - (2.0f / c1) * glm::dot(v1, rights[i - 1]) * v1;
                glm::vec3 tL = t0 - (2.0f / c1) * glm::dot(v1, t0) * v1;

                glm::vec3 v2 = t1 - tL;
                float c2 = glm::dot(v2, v2);
                if (c2 < 0.0001f) {
                    rights[i] = glm::normalize(rL);
                } else {
                    rights[i] = glm::normalize(rL - (2.0f / c2) * glm::dot(v2, rL) * v2);
                }
                ups[i] = glm::normalize(glm::cross(rights[i], t1));
            }
        }

        uint32_t tubeBaseIdx = static_cast<uint32_t>(allVerts.size());

        for (size_t i = 0; i < pathVertices.size(); ++i) {
            glm::vec3 pos = pathVertices[i];
            glm::vec3 right = rights[i];
            glm::vec3 localUp = ups[i];

            glm::vec3 corners[4] = {
                pos - right * baseHalfSize - localUp * baseHalfSize,
                pos + right * baseHalfSize - localUp * baseHalfSize,
                pos + right * baseHalfSize + localUp * baseHalfSize,
                pos - right * baseHalfSize + localUp * baseHalfSize
            };

            float vCoord = (pathVertices.size() > 1) ? static_cast<float>(i) / (pathVertices.size() - 1) : 0.0f;

            for (int c = 0; c < 5; ++c) {
                ModelVertex v;
                v.position = corners[c % 4];
                v.normal = glm::vec3(0, 1, 0);
                v.texCoord = autoUV ? glm::vec2(c / 4.0f, vCoord) : glm::vec2(0.0f);
                v.color = meshColor;
                allVerts.push_back(v);
            }
        }

        // Create quads connecting adjacent cross-sections
        for (size_t i = 0; i < pathVertices.size() - 1; ++i) {
            uint32_t base0 = tubeBaseIdx + static_cast<uint32_t>(i * 5);
            uint32_t base1 = tubeBaseIdx + static_cast<uint32_t>((i + 1) * 5);

            for (int side = 0; side < 4; ++side) {
                uint32_t v0 = base0 + side;
                uint32_t v1 = base1 + side;
                uint32_t v2 = base1 + side + 1;
                uint32_t v3 = base0 + side + 1;

                allIndices.push_back(v0);
                allIndices.push_back(v1);
                allIndices.push_back(v2);
                allIndices.push_back(v0);
                allIndices.push_back(v2);
                allIndices.push_back(v3);
            }
        }

        // For closed loops, connect last cross-section back to first
        // Need to find corner correspondence since frames may have rotated
        if (segment.isClosedLoop && pathVertices.size() >= 2) {
            uint32_t baseLast = tubeBaseIdx + static_cast<uint32_t>((pathVertices.size() - 1) * 5);
            uint32_t baseFirst = tubeBaseIdx;

            // Find which corner of the last cross-section best matches corner 0 of the first
            // We compare directions from center, not absolute positions
            glm::vec3 firstCenter = pathVertices[0];
            glm::vec3 lastCenter = pathVertices[pathVertices.size() - 1];

            glm::vec3 firstCorner0Dir = glm::normalize(allVerts[baseFirst].position - firstCenter);

            int bestOffset = 0;
            float bestDot = -2.0f;
            for (int c = 0; c < 4; ++c) {
                glm::vec3 lastCornerDir = glm::normalize(allVerts[baseLast + c].position - lastCenter);
                float d = glm::dot(firstCorner0Dir, lastCornerDir);
                if (d > bestDot) {
                    bestDot = d;
                    bestOffset = c;
                }
            }

            // Connect with the correct corner correspondence
            for (int side = 0; side < 4; ++side) {
                // Map last cross-section corners with offset
                int lastSide0 = (side + bestOffset) % 4;
                int lastSide1 = (side + 1 + bestOffset) % 4;

                uint32_t v0 = baseLast + lastSide0;
                uint32_t v1 = baseFirst + side;
                uint32_t v2 = baseFirst + side + 1;
                uint32_t v3 = baseLast + lastSide1;

                allIndices.push_back(v0);
                allIndices.push_back(v1);
                allIndices.push_back(v2);
                allIndices.push_back(v0);
                allIndices.push_back(v2);
                allIndices.push_back(v3);
            }
        }
    }

    std::cout << "[PipeNetwork] Created " << segments.size() << " tube segments" << std::endl;

    // Recalculate normals
    for (auto& v : allVerts) {
        v.normal = glm::vec3(0);
    }

    for (size_t i = 0; i < allIndices.size(); i += 3) {
        uint32_t i0 = allIndices[i];
        uint32_t i1 = allIndices[i + 1];
        uint32_t i2 = allIndices[i + 2];

        glm::vec3 p0 = allVerts[i0].position;
        glm::vec3 p1 = allVerts[i1].position;
        glm::vec3 p2 = allVerts[i2].position;

        glm::vec3 faceNormal = glm::cross(p1 - p0, p2 - p0);

        allVerts[i0].normal += faceNormal;
        allVerts[i1].normal += faceNormal;
        allVerts[i2].normal += faceNormal;
    }

    for (auto& v : allVerts) {
        if (glm::length(v.normal) > 0.0001f) {
            v.normal = glm::normalize(v.normal);
        }
    }

    std::cout << "[PipeNetwork] Total: " << allVerts.size() << " vertices, "
              << allIndices.size() / 3 << " triangles" << std::endl;

    // Build EditableMesh with proper quad topology for wireframe/editing
    // This preserves the quad structure so wireframe doesn't show triangle diagonals
    EditableMesh pipeMesh;
    pipeMesh.clear();

    // Rebuild with quads - use 4 verts per cross-section (not 5)
    // We need to re-add vertices and build quad faces
    uint32_t quadVertBase = 0;
    std::vector<uint32_t> crossSectionStarts;  // Track where each cross-section's verts start

    // Add vertices (4 per cross-section, from the 5-vert pattern)
    for (size_t v = 0; v < allVerts.size(); v += 5) {
        crossSectionStarts.push_back(static_cast<uint32_t>(pipeMesh.getVertexCount()));
        for (int c = 0; c < 4; ++c) {
            HEVertex hv;
            hv.position = allVerts[v + c].position;
            hv.normal = allVerts[v + c].normal;
            hv.uv = allVerts[v + c].texCoord;
            hv.color = allVerts[v + c].color;
            hv.halfEdgeIndex = UINT32_MAX;
            hv.selected = false;
            pipeMesh.addVertex(hv);
        }
    }

    // Add quad faces for each tube segment
    // Walk through the original index buffer in groups of 6 (2 triangles per quad)
    for (size_t i = 0; i < allIndices.size(); i += 6) {
        // The triangles are (v0,v1,v2) and (v0,v2,v3)
        // So the quad is v0,v1,v2,v3
        uint32_t triV0 = allIndices[i];
        uint32_t triV1 = allIndices[i + 1];
        uint32_t triV2 = allIndices[i + 2];
        uint32_t triV3 = allIndices[i + 5];  // From second triangle

        // Convert from 5-vert indexing to 4-vert indexing
        uint32_t section0 = triV0 / 5;
        uint32_t corner0 = triV0 % 5;
        uint32_t section1 = triV1 / 5;
        uint32_t corner1 = triV1 % 5;
        uint32_t section2 = triV2 / 5;
        uint32_t corner2 = triV2 % 5;
        uint32_t section3 = triV3 / 5;
        uint32_t corner3 = triV3 % 5;

        // Map corner indices (corner 4 wraps to corner 0)
        corner0 = corner0 % 4;
        corner1 = corner1 % 4;
        corner2 = corner2 % 4;
        corner3 = corner3 % 4;

        // Build quad vertex indices
        if (section0 < crossSectionStarts.size() && section1 < crossSectionStarts.size() &&
            section2 < crossSectionStarts.size() && section3 < crossSectionStarts.size()) {
            std::vector<uint32_t> quadVerts = {
                crossSectionStarts[section0] + corner0,
                crossSectionStarts[section1] + corner1,
                crossSectionStarts[section2] + corner2,
                crossSectionStarts[section3] + corner3
            };
            pipeMesh.addQuadFace(quadVerts);
        }
    }

    std::cout << "[PipeNetwork] EditableMesh: " << pipeMesh.getVertexCount() << " vertices, "
              << pipeMesh.getFaceCount() << " quad faces" << std::endl;

    // Create scene object
    auto newObject = std::make_unique<SceneObject>("PipeNetwork");
    if (m_ctx.selectedObject) {
        newObject->getTransform() = m_ctx.selectedObject->getTransform();
    }

    uint32_t handle = m_ctx.modelRenderer.createModel(allVerts, allIndices, nullptr, 0, 0);
    if (handle != UINT32_MAX) {
        newObject->setBufferHandle(handle);
        newObject->setIndexCount(static_cast<uint32_t>(allIndices.size()));
        newObject->setVertexCount(static_cast<uint32_t>(allVerts.size()));
        newObject->setMeshData(allVerts, allIndices);

        // Store half-edge data to preserve quad topology
        // Convert from EditableMesh types to SceneObject storage types
        const auto& meshVerts = pipeMesh.getVerticesData();
        const auto& meshHE = pipeMesh.getHalfEdges();
        const auto& meshFaces = pipeMesh.getFacesData();

        std::vector<SceneObject::StoredHEVertex> storedVerts;
        storedVerts.reserve(meshVerts.size());
        for (const auto& v : meshVerts) {
            storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
        }

        std::vector<SceneObject::StoredHalfEdge> storedHE;
        storedHE.reserve(meshHE.size());
        for (const auto& he : meshHE) {
            storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
        }

        std::vector<SceneObject::StoredHEFace> storedFaces;
        storedFaces.reserve(meshFaces.size());
        for (const auto& f : meshFaces) {
            storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
        }

        newObject->setEditableMeshData(storedVerts, storedHE, storedFaces);

        m_ctx.sceneObjects.push_back(std::move(newObject));
        std::cout << "[PipeNetwork] Added new object 'PipeNetwork' to scene" << std::endl;
    } else {
        std::cout << "[PipeNetwork] Failed to upload mesh to GPU" << std::endl;
    }
}

// ============================================================================
// Face Snap Methods
// ============================================================================

void ModelingMode::cancelSnapMode() {
    m_snapMode = false;
    m_snapMergeMode = false;
    m_snapSourceObject = nullptr;
    m_snapSourceFace = -1;
}

void ModelingMode::cancelSnapVertexMode() {
    m_snapVertexMode = false;
    m_snapSrcObj = nullptr;
    m_snapDstObj = nullptr;
    m_snapSrcVerts.clear();
    m_snapDstVerts.clear();
    m_snapSrcVertIndices.clear();
    m_snapDstVertIndices.clear();
}

glm::vec3 ModelingMode::getFaceCenter(SceneObject* obj, int faceIdx) {
    if (!obj || !obj->hasEditableMeshData()) return glm::vec3(0.0f);

    const auto& heVerts = obj->getHEVertices();
    const auto& heEdges = obj->getHEHalfEdges();
    const auto& heFaces = obj->getHEFaces();

    if (faceIdx < 0 || faceIdx >= static_cast<int>(heFaces.size())) return glm::vec3(0.0f);

    // Collect face vertices by walking half-edges
    std::vector<uint32_t> faceVertIndices;
    uint32_t startHE = heFaces[faceIdx].halfEdgeIndex;
    uint32_t currHE = startHE;
    do {
        faceVertIndices.push_back(heEdges[currHE].vertexIndex);
        currHE = heEdges[currHE].nextIndex;
    } while (currHE != startHE && faceVertIndices.size() < 10);

    if (faceVertIndices.empty()) return glm::vec3(0.0f);

    glm::mat4 modelMatrix = obj->getTransform().getMatrix();
    glm::vec3 center(0.0f);

    for (uint32_t vi : faceVertIndices) {
        glm::vec3 worldPos = glm::vec3(modelMatrix * glm::vec4(heVerts[vi].position, 1.0f));
        center += worldPos;
    }

    return center / static_cast<float>(faceVertIndices.size());
}

glm::vec3 ModelingMode::getFaceNormal(SceneObject* obj, int faceIdx) {
    if (!obj || !obj->hasEditableMeshData()) return glm::vec3(0.0f, 1.0f, 0.0f);

    const auto& heVerts = obj->getHEVertices();
    const auto& heEdges = obj->getHEHalfEdges();
    const auto& heFaces = obj->getHEFaces();

    if (faceIdx < 0 || faceIdx >= static_cast<int>(heFaces.size())) return glm::vec3(0.0f, 1.0f, 0.0f);

    // Collect face vertices by walking half-edges
    std::vector<uint32_t> faceVertIndices;
    uint32_t startHE = heFaces[faceIdx].halfEdgeIndex;
    uint32_t currHE = startHE;
    do {
        faceVertIndices.push_back(heEdges[currHE].vertexIndex);
        currHE = heEdges[currHE].nextIndex;
    } while (currHE != startHE && faceVertIndices.size() < 10);

    if (faceVertIndices.size() < 3) return glm::vec3(0.0f, 1.0f, 0.0f);

    glm::mat4 modelMatrix = obj->getTransform().getMatrix();
    glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));

    // Get local positions
    glm::vec3 v0 = heVerts[faceVertIndices[0]].position;
    glm::vec3 v1 = heVerts[faceVertIndices[1]].position;
    glm::vec3 v2 = heVerts[faceVertIndices[2]].position;

    // Calculate normal in local space, then transform to world
    glm::vec3 localNormal = glm::normalize(glm::cross(v1 - v0, v2 - v0));
    return glm::normalize(normalMatrix * localNormal);
}

void ModelingMode::snapObjectToFace(SceneObject* srcObj, int srcFace, SceneObject* dstObj, int dstFace) {
    if (!srcObj || !dstObj) return;

    // Get face info
    glm::vec3 srcCenter = getFaceCenter(srcObj, srcFace);
    glm::vec3 srcNormal = getFaceNormal(srcObj, srcFace);
    glm::vec3 dstCenter = getFaceCenter(dstObj, dstFace);
    glm::vec3 dstNormal = getFaceNormal(dstObj, dstFace);

    // We want the source face to align with target face
    // Source normal should point opposite to target normal (faces touching)
    glm::vec3 targetNormal = -dstNormal;

    // Calculate rotation to align source normal to target normal
    glm::vec3 rotationAxis = glm::cross(srcNormal, targetNormal);
    float dotProduct = glm::dot(srcNormal, targetNormal);

    glm::quat rotation;
    if (glm::length(rotationAxis) < 0.0001f) {
        // Normals are parallel
        if (dotProduct > 0.0f) {
            // Same direction, no rotation needed
            rotation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);
        } else {
            // Opposite direction, 180 degree rotation around any perpendicular axis
            glm::vec3 perpAxis = glm::abs(srcNormal.x) < 0.9f ? glm::vec3(1, 0, 0) : glm::vec3(0, 1, 0);
            perpAxis = glm::normalize(glm::cross(srcNormal, perpAxis));
            rotation = glm::angleAxis(glm::pi<float>(), perpAxis);
        }
    } else {
        rotationAxis = glm::normalize(rotationAxis);
        float angle = std::acos(glm::clamp(dotProduct, -1.0f, 1.0f));
        rotation = glm::angleAxis(angle, rotationAxis);
    }

    // Apply rotation to source object
    auto& srcTransform = srcObj->getTransform();
    glm::quat currentRot = srcTransform.getRotation();
    srcTransform.setRotation(rotation * currentRot);

    // Recalculate source face center after rotation
    glm::vec3 newSrcCenter = getFaceCenter(srcObj, srcFace);

    // Translate so face centers align
    glm::vec3 translation = dstCenter - newSrcCenter;
    srcTransform.setPosition(srcTransform.getPosition() + translation);

    std::cout << "[Snap] Snapped " << srcObj->getName() << " to " << dstObj->getName() << std::endl;
}

void ModelingMode::snapAndMergeObjects(SceneObject* srcObj, int srcFace, SceneObject* dstObj, int dstFace) {
    if (!srcObj || !dstObj) return;

    // First snap the objects together (aligns centers and normals)
    snapObjectToFace(srcObj, srcFace, dstObj, dstFace);

    // Get data from both objects
    const auto& srcHeVerts = srcObj->getHEVertices();
    const auto& srcHeEdges = srcObj->getHEHalfEdges();
    const auto& srcHeFaces = srcObj->getHEFaces();
    const auto& dstHeVerts = dstObj->getHEVertices();
    const auto& dstHeEdges = dstObj->getHEHalfEdges();
    const auto& dstHeFaces = dstObj->getHEFaces();

    // Get vertices of both snap faces
    std::vector<uint32_t> srcFaceVerts, dstFaceVerts;

    uint32_t startHE = srcHeFaces[srcFace].halfEdgeIndex;
    uint32_t currHE = startHE;
    do {
        srcFaceVerts.push_back(srcHeEdges[currHE].vertexIndex);
        currHE = srcHeEdges[currHE].nextIndex;
    } while (currHE != startHE && srcFaceVerts.size() < 10);

    startHE = dstHeFaces[dstFace].halfEdgeIndex;
    currHE = startHE;
    do {
        dstFaceVerts.push_back(dstHeEdges[currHE].vertexIndex);
        currHE = dstHeEdges[currHE].nextIndex;
    } while (currHE != startHE && dstFaceVerts.size() < 10);

    // Transform matrices
    glm::mat4 srcModelMatrix = srcObj->getTransform().getMatrix();
    glm::mat4 dstModelMatrix = dstObj->getTransform().getMatrix();
    glm::mat4 dstInvMatrix = glm::inverse(dstModelMatrix);

    // Get world positions of destination snap face vertices
    std::vector<glm::vec3> dstFaceWorldPos;
    for (uint32_t vi : dstFaceVerts) {
        dstFaceWorldPos.push_back(glm::vec3(dstModelMatrix * glm::vec4(dstHeVerts[vi].position, 1.0f)));
    }

    // Build position-based correspondence: map source snap vertex POSITIONS to destination positions
    std::vector<std::pair<glm::vec3, glm::vec3>> positionMapping;  // (srcWorldPos, dstWorldPos)

    for (size_t i = 0; i < srcFaceVerts.size(); ++i) {
        uint32_t srcVi = srcFaceVerts[i];
        glm::vec3 srcWorldPos = glm::vec3(srcModelMatrix * glm::vec4(srcHeVerts[srcVi].position, 1.0f));

        // Find closest destination vertex
        float minDist = std::numeric_limits<float>::max();
        int closestIdx = -1;
        for (size_t j = 0; j < dstFaceWorldPos.size(); ++j) {
            float dist = glm::length(srcWorldPos - dstFaceWorldPos[j]);
            if (dist < minDist) {
                minDist = dist;
                closestIdx = static_cast<int>(j);
            }
        }

        if (closestIdx >= 0) {
            positionMapping.push_back({srcWorldPos, dstFaceWorldPos[closestIdx]});
        }
    }

    // Build vertex positions in target's local space
    std::vector<glm::vec3> combinedPositions;
    std::vector<glm::vec2> combinedUVs;
    std::vector<glm::vec4> combinedColors;

    // Map from source vertex index to combined index
    std::map<uint32_t, uint32_t> srcVertexMap;

    // Start with target mesh vertices
    for (const auto& v : dstHeVerts) {
        combinedPositions.push_back(v.position);
        combinedUVs.push_back(v.uv);
        combinedColors.push_back(v.color);
    }

    // Add source mesh vertices
    // For ANY vertex at a snap face position, move it to the destination position
    const float posTolerance = 0.001f;

    for (size_t i = 0; i < srcHeVerts.size(); ++i) {
        const auto& v = srcHeVerts[i];
        uint32_t vi = static_cast<uint32_t>(i);
        glm::vec3 worldPos = glm::vec3(srcModelMatrix * glm::vec4(v.position, 1.0f));

        // Check if this vertex is at a snap face position (by position, not index)
        glm::vec3 finalWorldPos = worldPos;
        for (const auto& [srcPos, dstPos] : positionMapping) {
            if (glm::length(worldPos - srcPos) < posTolerance) {
                finalWorldPos = dstPos;  // Move to destination position
                break;
            }
        }

        glm::vec3 localPos = glm::vec3(dstInvMatrix * glm::vec4(finalWorldPos, 1.0f));

        // Add as new vertex
        srcVertexMap[vi] = static_cast<uint32_t>(combinedPositions.size());
        combinedPositions.push_back(localPos);
        combinedUVs.push_back(v.uv);
        combinedColors.push_back(v.color);
    }

    // Build faces, excluding the snap faces
    std::vector<std::vector<uint32_t>> allFaces;

    // Add target faces (excluding snap face)
    for (size_t fi = 0; fi < dstHeFaces.size(); ++fi) {
        if (static_cast<int>(fi) == dstFace) continue;  // Skip snap face

        std::vector<uint32_t> faceVerts;
        startHE = dstHeFaces[fi].halfEdgeIndex;
        currHE = startHE;
        do {
            faceVerts.push_back(dstHeEdges[currHE].vertexIndex);
            currHE = dstHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);
        allFaces.push_back(faceVerts);
    }

    // Add source faces (excluding snap face, with remapped vertex indices)
    for (size_t fi = 0; fi < srcHeFaces.size(); ++fi) {
        if (static_cast<int>(fi) == srcFace) continue;  // Skip snap face

        std::vector<uint32_t> faceVerts;
        startHE = srcHeFaces[fi].halfEdgeIndex;
        currHE = startHE;
        do {
            uint32_t srcVi = srcHeEdges[currHE].vertexIndex;
            faceVerts.push_back(srcVertexMap[srcVi]);
            currHE = srcHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);
        allFaces.push_back(faceVerts);
    }

    // Build the combined mesh
    std::vector<eden::ModelVertex> combinedVerts;
    std::vector<uint32_t> combinedIndices;

    for (size_t fi = 0; fi < allFaces.size(); ++fi) {
        const auto& faceVerts = allFaces[fi];
        if (faceVerts.size() < 3) continue;

        // Calculate face normal
        glm::vec3 v0 = combinedPositions[faceVerts[0]];
        glm::vec3 v1 = combinedPositions[faceVerts[1]];
        glm::vec3 v2 = combinedPositions[faceVerts[2]];
        glm::vec3 normal = glm::normalize(glm::cross(v1 - v0, v2 - v0));

        uint32_t baseIdx = static_cast<uint32_t>(combinedVerts.size());

        // Add vertices for this face
        for (uint32_t vi : faceVerts) {
            eden::ModelVertex mv;
            mv.position = combinedPositions[vi];
            mv.normal = normal;
            mv.texCoord = combinedUVs[vi];
            mv.color = combinedColors[vi];
            combinedVerts.push_back(mv);
        }

        // Triangulate (fan)
        for (size_t i = 1; i + 1 < faceVerts.size(); ++i) {
            combinedIndices.push_back(baseIdx);
            combinedIndices.push_back(baseIdx + static_cast<uint32_t>(i));
            combinedIndices.push_back(baseIdx + static_cast<uint32_t>(i + 1));
        }
    }

    // Update target object with combined mesh
    uint32_t handle = m_ctx.modelRenderer.createModel(combinedVerts, combinedIndices, nullptr, 0, 0);
    dstObj->setBufferHandle(handle);
    dstObj->setIndexCount(static_cast<uint32_t>(combinedIndices.size()));
    dstObj->setVertexCount(static_cast<uint32_t>(combinedVerts.size()));
    dstObj->setMeshData(combinedVerts, combinedIndices);
    dstObj->setName(dstObj->getName() + "_merged");

    // Build quad indices for half-edge structure (4 indices per face, not triangulated)
    std::vector<uint32_t> quadIndices;
    uint32_t vertexOffset = 0;
    for (const auto& faceVerts : allFaces) {
        if (faceVerts.size() == 4) {
            // Quad face - add 4 indices
            quadIndices.push_back(vertexOffset);
            quadIndices.push_back(vertexOffset + 1);
            quadIndices.push_back(vertexOffset + 2);
            quadIndices.push_back(vertexOffset + 3);
        } else if (faceVerts.size() == 3) {
            // Triangle face - pad to 4 indices by repeating last vertex
            quadIndices.push_back(vertexOffset);
            quadIndices.push_back(vertexOffset + 1);
            quadIndices.push_back(vertexOffset + 2);
            quadIndices.push_back(vertexOffset + 2);  // Repeat last vertex
        }
        vertexOffset += static_cast<uint32_t>(faceVerts.size());
    }

    // Rebuild half-edge data using quad indices
    m_ctx.editableMesh.buildFromQuads(combinedVerts, quadIndices);

    // Convert EditableMesh data to SceneObject storage format
    const auto& heVerts = m_ctx.editableMesh.getVerticesData();
    const auto& heHalfEdges = m_ctx.editableMesh.getHalfEdges();
    const auto& heFaces = m_ctx.editableMesh.getFacesData();

    std::vector<SceneObject::StoredHEVertex> storedVerts;
    storedVerts.reserve(heVerts.size());
    for (const auto& v : heVerts) {
        storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
    }

    std::vector<SceneObject::StoredHalfEdge> storedHE;
    storedHE.reserve(heHalfEdges.size());
    for (const auto& he : heHalfEdges) {
        storedHE.push_back({he.vertexIndex, he.faceIndex, he.nextIndex, he.prevIndex, he.twinIndex});
    }

    std::vector<SceneObject::StoredHEFace> storedFaces;
    storedFaces.reserve(heFaces.size());
    for (const auto& f : heFaces) {
        storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
    }

    dstObj->setEditableMeshData(storedVerts, storedHE, storedFaces);

    // Delete source object
    m_ctx.pendingDeletions.push_back(srcObj);

    // Select the combined object
    m_ctx.selectedObject = dstObj;
    m_ctx.objectMode = true;
    buildEditableMeshFromObject();

    std::cout << "[Snap] Merged objects into " << dstObj->getName() << std::endl;
}

void ModelingMode::snapAndMergeWithVertexCorrespondence() {
    if (!m_snapSrcObj || !m_snapDstObj) return;
    if (m_snapSrcVerts.empty() || m_snapSrcVerts.size() != m_snapDstVerts.size()) return;

    std::cout << "[Snap] Merging with " << m_snapSrcVerts.size() << " vertex correspondences" << std::endl;

    // Get data from both objects
    const auto& srcHeVerts = m_snapSrcObj->getHEVertices();
    const auto& srcHeEdges = m_snapSrcObj->getHEHalfEdges();
    const auto& srcHeFaces = m_snapSrcObj->getHEFaces();
    const auto& dstHeVerts = m_snapDstObj->getHEVertices();
    const auto& dstHeEdges = m_snapDstObj->getHEHalfEdges();
    const auto& dstHeFaces = m_snapDstObj->getHEFaces();

    // Transform matrices
    glm::mat4 srcModelMatrix = m_snapSrcObj->getTransform().getMatrix();
    glm::mat4 dstModelMatrix = m_snapDstObj->getTransform().getMatrix();
    glm::mat4 dstInvMatrix = glm::inverse(dstModelMatrix);

    // Build position-based correspondence from user-selected vertices
    // Map: source world position -> destination world position
    std::vector<std::pair<glm::vec3, glm::vec3>> positionMapping;
    const float posTolerance = 0.001f;

    for (size_t i = 0; i < m_snapSrcVerts.size(); ++i) {
        positionMapping.push_back({m_snapSrcVerts[i], m_snapDstVerts[i]});
    }

    // Calculate transformation to align ENTIRE source mesh to target
    // Step 1: Calculate centroids of snap vertices
    glm::vec3 srcCentroid(0.0f);
    glm::vec3 dstCentroid(0.0f);
    for (size_t i = 0; i < m_snapSrcVerts.size(); ++i) {
        srcCentroid += m_snapSrcVerts[i];
        dstCentroid += m_snapDstVerts[i];
    }
    srcCentroid /= static_cast<float>(m_snapSrcVerts.size());
    dstCentroid /= static_cast<float>(m_snapDstVerts.size());

    // Step 2: Calculate translation to align centroids
    glm::vec3 translationOffset = dstCentroid - srcCentroid;

    std::cout << "[Snap] Source centroid: " << srcCentroid.x << ", " << srcCentroid.y << ", " << srcCentroid.z << std::endl;
    std::cout << "[Snap] Target centroid: " << dstCentroid.x << ", " << dstCentroid.y << ", " << dstCentroid.z << std::endl;
    std::cout << "[Snap] Translation offset: " << translationOffset.x << ", " << translationOffset.y << ", " << translationOffset.z << std::endl;

    // Build vertex positions in target's local space
    std::vector<glm::vec3> combinedPositions;
    std::vector<glm::vec2> combinedUVs;
    std::vector<glm::vec4> combinedColors;

    // Map from source vertex index to combined index
    std::map<uint32_t, uint32_t> srcVertexMap;

    // Start with target mesh vertices
    for (const auto& v : dstHeVerts) {
        combinedPositions.push_back(v.position);
        combinedUVs.push_back(v.uv);
        combinedColors.push_back(v.color);
    }

    // Add source mesh vertices - transform ALL vertices by the alignment offset
    for (size_t i = 0; i < srcHeVerts.size(); ++i) {
        const auto& v = srcHeVerts[i];
        uint32_t vi = static_cast<uint32_t>(i);

        // Transform to world space
        glm::vec3 worldPos = glm::vec3(srcModelMatrix * glm::vec4(v.position, 1.0f));

        // Apply alignment translation to move entire mesh to target
        glm::vec3 alignedWorldPos = worldPos + translationOffset;

        // For snap vertices specifically, use exact destination position to avoid floating point errors
        for (const auto& [srcPos, dstPos] : positionMapping) {
            if (glm::length(worldPos - srcPos) < posTolerance) {
                alignedWorldPos = dstPos;  // Use exact position for snap vertices
                break;
            }
        }

        // Transform to target's local space
        glm::vec3 localPos = glm::vec3(dstInvMatrix * glm::vec4(alignedWorldPos, 1.0f));

        // Add as new vertex
        srcVertexMap[vi] = static_cast<uint32_t>(combinedPositions.size());
        combinedPositions.push_back(localPos);
        combinedUVs.push_back(v.uv);
        combinedColors.push_back(v.color);
    }

    // Find faces that use snap vertices (these will be removed as they're the joining faces)
    std::set<int> srcSnapFaces, dstSnapFaces;

    // Find source faces that contain snap vertices
    for (size_t fi = 0; fi < srcHeFaces.size(); ++fi) {
        std::vector<uint32_t> faceVerts;
        uint32_t startHE = srcHeFaces[fi].halfEdgeIndex;
        uint32_t currHE = startHE;
        do {
            faceVerts.push_back(srcHeEdges[currHE].vertexIndex);
            currHE = srcHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);

        // Check if ALL vertices of this face are snap vertices
        bool allSnapVerts = true;
        for (uint32_t vIdx : faceVerts) {
            glm::vec3 worldPos = glm::vec3(srcModelMatrix * glm::vec4(srcHeVerts[vIdx].position, 1.0f));
            bool isSnapVert = false;
            for (const auto& [srcPos, dstPos] : positionMapping) {
                if (glm::length(worldPos - srcPos) < posTolerance) {
                    isSnapVert = true;
                    break;
                }
            }
            if (!isSnapVert) {
                allSnapVerts = false;
                break;
            }
        }
        if (allSnapVerts && faceVerts.size() == m_snapSrcVerts.size()) {
            srcSnapFaces.insert(static_cast<int>(fi));
        }
    }

    // Find destination faces that contain snap vertices
    for (size_t fi = 0; fi < dstHeFaces.size(); ++fi) {
        std::vector<uint32_t> faceVerts;
        uint32_t startHE = dstHeFaces[fi].halfEdgeIndex;
        uint32_t currHE = startHE;
        do {
            faceVerts.push_back(dstHeEdges[currHE].vertexIndex);
            currHE = dstHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);

        // Check if ALL vertices of this face are snap vertices
        bool allSnapVerts = true;
        for (uint32_t vIdx : faceVerts) {
            glm::vec3 worldPos = glm::vec3(dstModelMatrix * glm::vec4(dstHeVerts[vIdx].position, 1.0f));
            bool isSnapVert = false;
            for (const auto& [srcPos, dstPos] : positionMapping) {
                if (glm::length(worldPos - dstPos) < posTolerance) {
                    isSnapVert = true;
                    break;
                }
            }
            if (!isSnapVert) {
                allSnapVerts = false;
                break;
            }
        }
        if (allSnapVerts && faceVerts.size() == m_snapDstVerts.size()) {
            dstSnapFaces.insert(static_cast<int>(fi));
        }
    }

    std::cout << "[Snap] Removing " << srcSnapFaces.size() << " source faces and "
              << dstSnapFaces.size() << " target faces" << std::endl;

    // Build faces, excluding the snap faces
    std::vector<std::vector<uint32_t>> allFaces;

    // Add target faces (excluding snap faces)
    for (size_t fi = 0; fi < dstHeFaces.size(); ++fi) {
        if (dstSnapFaces.count(static_cast<int>(fi)) > 0) continue;

        std::vector<uint32_t> faceVerts;
        uint32_t startHE = dstHeFaces[fi].halfEdgeIndex;
        uint32_t currHE = startHE;
        do {
            faceVerts.push_back(dstHeEdges[currHE].vertexIndex);
            currHE = dstHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);
        allFaces.push_back(faceVerts);
    }

    // Add source faces (excluding snap faces, with remapped vertex indices)
    for (size_t fi = 0; fi < srcHeFaces.size(); ++fi) {
        if (srcSnapFaces.count(static_cast<int>(fi)) > 0) continue;

        std::vector<uint32_t> faceVerts;
        uint32_t startHE = srcHeFaces[fi].halfEdgeIndex;
        uint32_t currHE = startHE;
        do {
            uint32_t srcVi = srcHeEdges[currHE].vertexIndex;
            faceVerts.push_back(srcVertexMap[srcVi]);
            currHE = srcHeEdges[currHE].nextIndex;
        } while (currHE != startHE && faceVerts.size() < 10);
        allFaces.push_back(faceVerts);
    }

    // Build combined editable mesh directly (preserves quad topology)
    eden::EditableMesh tempMesh;
    tempMesh.clear();

    // Add all vertices to editable mesh
    for (size_t i = 0; i < combinedPositions.size(); ++i) {
        eden::HEVertex v;
        v.position = combinedPositions[i];
        v.normal = glm::vec3(0, 1, 0);  // Will recalculate
        v.uv = combinedUVs[i];
        v.color = combinedColors[i];
        v.halfEdgeIndex = UINT32_MAX;
        v.selected = false;
        tempMesh.addVertex(v);
    }

    // Add all faces (preserves quads!)
    for (const auto& faceVerts : allFaces) {
        if (faceVerts.size() >= 3) {
            tempMesh.addQuadFace(faceVerts);
        }
    }

    // Recalculate normals
    tempMesh.recalculateNormals();

    // Triangulate for GPU rendering
    std::vector<eden::ModelVertex> combinedVerts;
    std::vector<uint32_t> combinedIndices;
    tempMesh.triangulate(combinedVerts, combinedIndices);

    // Upload combined mesh to GPU
    uint32_t newHandle = m_ctx.modelRenderer.createModel(combinedVerts, combinedIndices, nullptr, 0, 0);
    if (newHandle == UINT32_MAX) {
        std::cout << "[Snap] Failed to create combined mesh" << std::endl;
        return;
    }

    // Delete source object
    m_ctx.pendingDeletions.push_back(m_snapSrcObj);

    // Update destination object with combined mesh
    m_snapDstObj->setBufferHandle(newHandle);
    m_snapDstObj->setIndexCount(static_cast<uint32_t>(combinedIndices.size()));
    m_snapDstObj->setVertexCount(static_cast<uint32_t>(combinedVerts.size()));
    m_snapDstObj->setMeshData(combinedVerts, combinedIndices);
    m_snapDstObj->clearEditableMeshData();  // Force rebuild

    // Store the editable mesh data (quad topology preserved)
    std::vector<SceneObject::StoredHEVertex> storedVerts;
    std::vector<SceneObject::StoredHalfEdge> storedEdges;
    std::vector<SceneObject::StoredHEFace> storedFaces;

    for (size_t i = 0; i < tempMesh.getVertexCount(); ++i) {
        const auto& v = tempMesh.getVertex(static_cast<uint32_t>(i));
        storedVerts.push_back({v.position, v.normal, v.uv, v.color, v.halfEdgeIndex, v.selected});
    }
    for (size_t i = 0; i < tempMesh.getHalfEdgeCount(); ++i) {
        const auto& e = tempMesh.getHalfEdge(static_cast<uint32_t>(i));
        storedEdges.push_back({e.vertexIndex, e.faceIndex, e.nextIndex, e.prevIndex, e.twinIndex});
    }
    for (size_t i = 0; i < tempMesh.getFaceCount(); ++i) {
        const auto& f = tempMesh.getFace(static_cast<uint32_t>(i));
        storedFaces.push_back({f.halfEdgeIndex, f.vertexCount, f.selected});
    }
    m_snapDstObj->setEditableMeshData(storedVerts, storedEdges, storedFaces);

    // Update local bounds
    glm::vec3 minBounds(FLT_MAX), maxBounds(-FLT_MAX);
    for (const auto& v : combinedVerts) {
        minBounds = glm::min(minBounds, v.position);
        maxBounds = glm::max(maxBounds, v.position);
    }
    AABB bounds;
    bounds.min = minBounds;
    bounds.max = maxBounds;
    m_snapDstObj->setLocalBounds(bounds);

    // Select the combined object
    m_ctx.selectedObject = m_snapDstObj;
    m_ctx.selectedObjects.clear();
    m_ctx.selectedObjects.insert(m_snapDstObj);
    m_ctx.objectMode = true;
    buildEditableMeshFromObject();

    std::cout << "[Snap] Merged objects using vertex correspondence into " << m_snapDstObj->getName() << std::endl;
}
